//
// PIL - portable imaging library
// Copyright (c) 2000-2017 BitBank Software, Inc.
// Written by Larry Bank
// Project started 12/9/2000
// A highly optimized imaging library designed for resource-constrained
// environments such as mobile/embedded devices
//
// pil_jpeg.c - functions related to JPEG compression
//

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <SD.h>
#include "pil.h"
#include "pil_io.h"

#define JPEG_PROGRESSIVE

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern unsigned short PILTIFFSHORT(unsigned char *p, int bMotorola);
extern uint32_t PILTIFFLONG(unsigned char *p, int bMotorola);

#ifdef __cplusplus
}
#endif // __cplusplus

extern int PILTIFFInfo(PIL_FILE *pFile, PIL_PAGE *pPage, int iOptions);
extern int PILReadAtOffset(PIL_FILE *pf, int iOffset, unsigned char *pDest, int iLen);
extern void PILReadBlock(PIL_PAGE *pPage, int *iOff);
int JPEGGetSOF(unsigned char *buf, int *iOff, JPEGDATA *pJPEG);
extern void PILDraw1Line(unsigned char *irlcptr, unsigned char *pDest, int Start, int iWidth);
extern void PILCalcDICOMRange(PIL_PAGE *pPage);
extern void JPEGIDCT_SIMD(JPEGDATA *pJPEG, signed short *pMCUSrc, int iQuantTable, int iACFlags);
void JPEGPutMCU12(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCU12HALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCU12QUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCU21(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCU21QUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCU21HALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCURGB(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCURGBHALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCURGBQUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCUYCCK(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCUCMYK(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCUGray(PIL_PAGE *inpage, unsigned char *pSrc, unsigned char *cOutput, JPEGDATA *pJPEG, int x, int y, int lsize);
void JPEGPutMCU11(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCU11HALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
void JPEGPutMCU11QUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
extern void JPEGPutMCU21_SIMD(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
extern void JPEGPutMCU22_SIMD(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
extern int PILTIFFVALUE(unsigned char *p, int bMotorola);
extern int JPEGSimpleFilter_SIMD(PIL_PAGE *inpage, int iOffset, JPEGDATA *pJPEG, JPEG_SLICE *pJPEGSlices, int iNumThreads, int *iNumSlices, unsigned char *pOut, int bThumbnail);
extern void JPEGSubSample24_SIMD(unsigned char *pSrc, signed short *pLUM, signed short *pCb, signed short *pCr, int lsize, int cx, int cy);
extern void JPEGSubSample32_SIMD(unsigned char *pSrc, signed short *pLUM, signed short *pCb, signed short *pCr, int lsize, int cx, int cy);
extern void JPEGSample24_SIMD(unsigned char *pSrc, signed short *pMCU, int lsize, int cx, int cy);
extern void JPEGPutMCU11_SIMD(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
extern void JPEGPutMCU21_SIMD(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG);
extern void JPEGFDCT_SIMD(signed short *pMCUSrc);
extern void JPEGIDCT_SIMD(JPEGDATA *pJPEG, signed short *pMCUSrc, int iQuantTable, int iACFlags);
extern char *strupr (char *a);
void PILGetEXIFInfo(unsigned char *buf, int iEXIF1, int iEXIF2, int bMotorola, PIL_PAGE *outpage);

const int iBitMasks[33] = {0,1,3,7,0xf,0x1f,0x3f,0x7f,0xff,0x1ff,0x3ff,0x7ff,0x0fff,0x1fff,0x3fff,0x7fff,0xffff,0x1ffff,0x3ffff,0x7ffff,0xfffff,0x1fffff,0x3fffff,0x7fffff,0xffffff,0x1ffffff,0x3ffffff,0x7ffffff,0xfffffff,0x1fffffff,0x3fffffff,0x7fffffff,1};

// Bit cutoffs for fast/slow huffman decode tables
#define FAST_DC_BITS 6
#define FAST_DC_MASK 0x3f
#define FAST_AC_BITS 8
#define FAST_AC_MASK 0xff

// Returns the magnitude and fixes negative values for JPEG encoding
// Upper 16 bits is the new delta value, lower 16 is the magnitude
const uint32_t ulMagnitudeFix[2048] = {
    0x03ff000b, 0x0000000a, 0x0001000a, 0x0002000a, 0x0003000a, 0x0004000a, 0x0005000a, 0x0006000a,
    0x0007000a, 0x0008000a, 0x0009000a, 0x000a000a, 0x000b000a, 0x000c000a, 0x000d000a, 0x000e000a,
    0x000f000a, 0x0010000a, 0x0011000a, 0x0012000a, 0x0013000a, 0x0014000a, 0x0015000a, 0x0016000a,
    0x0017000a, 0x0018000a, 0x0019000a, 0x001a000a, 0x001b000a, 0x001c000a, 0x001d000a, 0x001e000a,
    0x001f000a, 0x0020000a, 0x0021000a, 0x0022000a, 0x0023000a, 0x0024000a, 0x0025000a, 0x0026000a,
    0x0027000a, 0x0028000a, 0x0029000a, 0x002a000a, 0x002b000a, 0x002c000a, 0x002d000a, 0x002e000a,
    0x002f000a, 0x0030000a, 0x0031000a, 0x0032000a, 0x0033000a, 0x0034000a, 0x0035000a, 0x0036000a,
    0x0037000a, 0x0038000a, 0x0039000a, 0x003a000a, 0x003b000a, 0x003c000a, 0x003d000a, 0x003e000a,
    0x003f000a, 0x0040000a, 0x0041000a, 0x0042000a, 0x0043000a, 0x0044000a, 0x0045000a, 0x0046000a,
    0x0047000a, 0x0048000a, 0x0049000a, 0x004a000a, 0x004b000a, 0x004c000a, 0x004d000a, 0x004e000a,
    0x004f000a, 0x0050000a, 0x0051000a, 0x0052000a, 0x0053000a, 0x0054000a, 0x0055000a, 0x0056000a,
    0x0057000a, 0x0058000a, 0x0059000a, 0x005a000a, 0x005b000a, 0x005c000a, 0x005d000a, 0x005e000a,
    0x005f000a, 0x0060000a, 0x0061000a, 0x0062000a, 0x0063000a, 0x0064000a, 0x0065000a, 0x0066000a,
    0x0067000a, 0x0068000a, 0x0069000a, 0x006a000a, 0x006b000a, 0x006c000a, 0x006d000a, 0x006e000a,
    0x006f000a, 0x0070000a, 0x0071000a, 0x0072000a, 0x0073000a, 0x0074000a, 0x0075000a, 0x0076000a,
    0x0077000a, 0x0078000a, 0x0079000a, 0x007a000a, 0x007b000a, 0x007c000a, 0x007d000a, 0x007e000a,
    0x007f000a, 0x0080000a, 0x0081000a, 0x0082000a, 0x0083000a, 0x0084000a, 0x0085000a, 0x0086000a,
    0x0087000a, 0x0088000a, 0x0089000a, 0x008a000a, 0x008b000a, 0x008c000a, 0x008d000a, 0x008e000a,
    0x008f000a, 0x0090000a, 0x0091000a, 0x0092000a, 0x0093000a, 0x0094000a, 0x0095000a, 0x0096000a,
    0x0097000a, 0x0098000a, 0x0099000a, 0x009a000a, 0x009b000a, 0x009c000a, 0x009d000a, 0x009e000a,
    0x009f000a, 0x00a0000a, 0x00a1000a, 0x00a2000a, 0x00a3000a, 0x00a4000a, 0x00a5000a, 0x00a6000a,
    0x00a7000a, 0x00a8000a, 0x00a9000a, 0x00aa000a, 0x00ab000a, 0x00ac000a, 0x00ad000a, 0x00ae000a,
    0x00af000a, 0x00b0000a, 0x00b1000a, 0x00b2000a, 0x00b3000a, 0x00b4000a, 0x00b5000a, 0x00b6000a,
    0x00b7000a, 0x00b8000a, 0x00b9000a, 0x00ba000a, 0x00bb000a, 0x00bc000a, 0x00bd000a, 0x00be000a,
    0x00bf000a, 0x00c0000a, 0x00c1000a, 0x00c2000a, 0x00c3000a, 0x00c4000a, 0x00c5000a, 0x00c6000a,
    0x00c7000a, 0x00c8000a, 0x00c9000a, 0x00ca000a, 0x00cb000a, 0x00cc000a, 0x00cd000a, 0x00ce000a,
    0x00cf000a, 0x00d0000a, 0x00d1000a, 0x00d2000a, 0x00d3000a, 0x00d4000a, 0x00d5000a, 0x00d6000a,
    0x00d7000a, 0x00d8000a, 0x00d9000a, 0x00da000a, 0x00db000a, 0x00dc000a, 0x00dd000a, 0x00de000a,
    0x00df000a, 0x00e0000a, 0x00e1000a, 0x00e2000a, 0x00e3000a, 0x00e4000a, 0x00e5000a, 0x00e6000a,
    0x00e7000a, 0x00e8000a, 0x00e9000a, 0x00ea000a, 0x00eb000a, 0x00ec000a, 0x00ed000a, 0x00ee000a,
    0x00ef000a, 0x00f0000a, 0x00f1000a, 0x00f2000a, 0x00f3000a, 0x00f4000a, 0x00f5000a, 0x00f6000a,
    0x00f7000a, 0x00f8000a, 0x00f9000a, 0x00fa000a, 0x00fb000a, 0x00fc000a, 0x00fd000a, 0x00fe000a,
    0x00ff000a, 0x0100000a, 0x0101000a, 0x0102000a, 0x0103000a, 0x0104000a, 0x0105000a, 0x0106000a,
    0x0107000a, 0x0108000a, 0x0109000a, 0x010a000a, 0x010b000a, 0x010c000a, 0x010d000a, 0x010e000a,
    0x010f000a, 0x0110000a, 0x0111000a, 0x0112000a, 0x0113000a, 0x0114000a, 0x0115000a, 0x0116000a,
    0x0117000a, 0x0118000a, 0x0119000a, 0x011a000a, 0x011b000a, 0x011c000a, 0x011d000a, 0x011e000a,
    0x011f000a, 0x0120000a, 0x0121000a, 0x0122000a, 0x0123000a, 0x0124000a, 0x0125000a, 0x0126000a,
    0x0127000a, 0x0128000a, 0x0129000a, 0x012a000a, 0x012b000a, 0x012c000a, 0x012d000a, 0x012e000a,
    0x012f000a, 0x0130000a, 0x0131000a, 0x0132000a, 0x0133000a, 0x0134000a, 0x0135000a, 0x0136000a,
    0x0137000a, 0x0138000a, 0x0139000a, 0x013a000a, 0x013b000a, 0x013c000a, 0x013d000a, 0x013e000a,
    0x013f000a, 0x0140000a, 0x0141000a, 0x0142000a, 0x0143000a, 0x0144000a, 0x0145000a, 0x0146000a,
    0x0147000a, 0x0148000a, 0x0149000a, 0x014a000a, 0x014b000a, 0x014c000a, 0x014d000a, 0x014e000a,
    0x014f000a, 0x0150000a, 0x0151000a, 0x0152000a, 0x0153000a, 0x0154000a, 0x0155000a, 0x0156000a,
    0x0157000a, 0x0158000a, 0x0159000a, 0x015a000a, 0x015b000a, 0x015c000a, 0x015d000a, 0x015e000a,
    0x015f000a, 0x0160000a, 0x0161000a, 0x0162000a, 0x0163000a, 0x0164000a, 0x0165000a, 0x0166000a,
    0x0167000a, 0x0168000a, 0x0169000a, 0x016a000a, 0x016b000a, 0x016c000a, 0x016d000a, 0x016e000a,
    0x016f000a, 0x0170000a, 0x0171000a, 0x0172000a, 0x0173000a, 0x0174000a, 0x0175000a, 0x0176000a,
    0x0177000a, 0x0178000a, 0x0179000a, 0x017a000a, 0x017b000a, 0x017c000a, 0x017d000a, 0x017e000a,
    0x017f000a, 0x0180000a, 0x0181000a, 0x0182000a, 0x0183000a, 0x0184000a, 0x0185000a, 0x0186000a,
    0x0187000a, 0x0188000a, 0x0189000a, 0x018a000a, 0x018b000a, 0x018c000a, 0x018d000a, 0x018e000a,
    0x018f000a, 0x0190000a, 0x0191000a, 0x0192000a, 0x0193000a, 0x0194000a, 0x0195000a, 0x0196000a,
    0x0197000a, 0x0198000a, 0x0199000a, 0x019a000a, 0x019b000a, 0x019c000a, 0x019d000a, 0x019e000a,
    0x019f000a, 0x01a0000a, 0x01a1000a, 0x01a2000a, 0x01a3000a, 0x01a4000a, 0x01a5000a, 0x01a6000a,
    0x01a7000a, 0x01a8000a, 0x01a9000a, 0x01aa000a, 0x01ab000a, 0x01ac000a, 0x01ad000a, 0x01ae000a,
    0x01af000a, 0x01b0000a, 0x01b1000a, 0x01b2000a, 0x01b3000a, 0x01b4000a, 0x01b5000a, 0x01b6000a,
    0x01b7000a, 0x01b8000a, 0x01b9000a, 0x01ba000a, 0x01bb000a, 0x01bc000a, 0x01bd000a, 0x01be000a,
    0x01bf000a, 0x01c0000a, 0x01c1000a, 0x01c2000a, 0x01c3000a, 0x01c4000a, 0x01c5000a, 0x01c6000a,
    0x01c7000a, 0x01c8000a, 0x01c9000a, 0x01ca000a, 0x01cb000a, 0x01cc000a, 0x01cd000a, 0x01ce000a,
    0x01cf000a, 0x01d0000a, 0x01d1000a, 0x01d2000a, 0x01d3000a, 0x01d4000a, 0x01d5000a, 0x01d6000a,
    0x01d7000a, 0x01d8000a, 0x01d9000a, 0x01da000a, 0x01db000a, 0x01dc000a, 0x01dd000a, 0x01de000a,
    0x01df000a, 0x01e0000a, 0x01e1000a, 0x01e2000a, 0x01e3000a, 0x01e4000a, 0x01e5000a, 0x01e6000a,
    0x01e7000a, 0x01e8000a, 0x01e9000a, 0x01ea000a, 0x01eb000a, 0x01ec000a, 0x01ed000a, 0x01ee000a,
    0x01ef000a, 0x01f0000a, 0x01f1000a, 0x01f2000a, 0x01f3000a, 0x01f4000a, 0x01f5000a, 0x01f6000a,
    0x01f7000a, 0x01f8000a, 0x01f9000a, 0x01fa000a, 0x01fb000a, 0x01fc000a, 0x01fd000a, 0x01fe000a,
    0x01ff000a, 0x00000009, 0x00010009, 0x00020009, 0x00030009, 0x00040009, 0x00050009, 0x00060009,
    0x00070009, 0x00080009, 0x00090009, 0x000a0009, 0x000b0009, 0x000c0009, 0x000d0009, 0x000e0009,
    0x000f0009, 0x00100009, 0x00110009, 0x00120009, 0x00130009, 0x00140009, 0x00150009, 0x00160009,
    0x00170009, 0x00180009, 0x00190009, 0x001a0009, 0x001b0009, 0x001c0009, 0x001d0009, 0x001e0009,
    0x001f0009, 0x00200009, 0x00210009, 0x00220009, 0x00230009, 0x00240009, 0x00250009, 0x00260009,
    0x00270009, 0x00280009, 0x00290009, 0x002a0009, 0x002b0009, 0x002c0009, 0x002d0009, 0x002e0009,
    0x002f0009, 0x00300009, 0x00310009, 0x00320009, 0x00330009, 0x00340009, 0x00350009, 0x00360009,
    0x00370009, 0x00380009, 0x00390009, 0x003a0009, 0x003b0009, 0x003c0009, 0x003d0009, 0x003e0009,
    0x003f0009, 0x00400009, 0x00410009, 0x00420009, 0x00430009, 0x00440009, 0x00450009, 0x00460009,
    0x00470009, 0x00480009, 0x00490009, 0x004a0009, 0x004b0009, 0x004c0009, 0x004d0009, 0x004e0009,
    0x004f0009, 0x00500009, 0x00510009, 0x00520009, 0x00530009, 0x00540009, 0x00550009, 0x00560009,
    0x00570009, 0x00580009, 0x00590009, 0x005a0009, 0x005b0009, 0x005c0009, 0x005d0009, 0x005e0009,
    0x005f0009, 0x00600009, 0x00610009, 0x00620009, 0x00630009, 0x00640009, 0x00650009, 0x00660009,
    0x00670009, 0x00680009, 0x00690009, 0x006a0009, 0x006b0009, 0x006c0009, 0x006d0009, 0x006e0009,
    0x006f0009, 0x00700009, 0x00710009, 0x00720009, 0x00730009, 0x00740009, 0x00750009, 0x00760009,
    0x00770009, 0x00780009, 0x00790009, 0x007a0009, 0x007b0009, 0x007c0009, 0x007d0009, 0x007e0009,
    0x007f0009, 0x00800009, 0x00810009, 0x00820009, 0x00830009, 0x00840009, 0x00850009, 0x00860009,
    0x00870009, 0x00880009, 0x00890009, 0x008a0009, 0x008b0009, 0x008c0009, 0x008d0009, 0x008e0009,
    0x008f0009, 0x00900009, 0x00910009, 0x00920009, 0x00930009, 0x00940009, 0x00950009, 0x00960009,
    0x00970009, 0x00980009, 0x00990009, 0x009a0009, 0x009b0009, 0x009c0009, 0x009d0009, 0x009e0009,
    0x009f0009, 0x00a00009, 0x00a10009, 0x00a20009, 0x00a30009, 0x00a40009, 0x00a50009, 0x00a60009,
    0x00a70009, 0x00a80009, 0x00a90009, 0x00aa0009, 0x00ab0009, 0x00ac0009, 0x00ad0009, 0x00ae0009,
    0x00af0009, 0x00b00009, 0x00b10009, 0x00b20009, 0x00b30009, 0x00b40009, 0x00b50009, 0x00b60009,
    0x00b70009, 0x00b80009, 0x00b90009, 0x00ba0009, 0x00bb0009, 0x00bc0009, 0x00bd0009, 0x00be0009,
    0x00bf0009, 0x00c00009, 0x00c10009, 0x00c20009, 0x00c30009, 0x00c40009, 0x00c50009, 0x00c60009,
    0x00c70009, 0x00c80009, 0x00c90009, 0x00ca0009, 0x00cb0009, 0x00cc0009, 0x00cd0009, 0x00ce0009,
    0x00cf0009, 0x00d00009, 0x00d10009, 0x00d20009, 0x00d30009, 0x00d40009, 0x00d50009, 0x00d60009,
    0x00d70009, 0x00d80009, 0x00d90009, 0x00da0009, 0x00db0009, 0x00dc0009, 0x00dd0009, 0x00de0009,
    0x00df0009, 0x00e00009, 0x00e10009, 0x00e20009, 0x00e30009, 0x00e40009, 0x00e50009, 0x00e60009,
    0x00e70009, 0x00e80009, 0x00e90009, 0x00ea0009, 0x00eb0009, 0x00ec0009, 0x00ed0009, 0x00ee0009,
    0x00ef0009, 0x00f00009, 0x00f10009, 0x00f20009, 0x00f30009, 0x00f40009, 0x00f50009, 0x00f60009,
    0x00f70009, 0x00f80009, 0x00f90009, 0x00fa0009, 0x00fb0009, 0x00fc0009, 0x00fd0009, 0x00fe0009,
    0x00ff0009, 0x00000008, 0x00010008, 0x00020008, 0x00030008, 0x00040008, 0x00050008, 0x00060008,
    0x00070008, 0x00080008, 0x00090008, 0x000a0008, 0x000b0008, 0x000c0008, 0x000d0008, 0x000e0008,
    0x000f0008, 0x00100008, 0x00110008, 0x00120008, 0x00130008, 0x00140008, 0x00150008, 0x00160008,
    0x00170008, 0x00180008, 0x00190008, 0x001a0008, 0x001b0008, 0x001c0008, 0x001d0008, 0x001e0008,
    0x001f0008, 0x00200008, 0x00210008, 0x00220008, 0x00230008, 0x00240008, 0x00250008, 0x00260008,
    0x00270008, 0x00280008, 0x00290008, 0x002a0008, 0x002b0008, 0x002c0008, 0x002d0008, 0x002e0008,
    0x002f0008, 0x00300008, 0x00310008, 0x00320008, 0x00330008, 0x00340008, 0x00350008, 0x00360008,
    0x00370008, 0x00380008, 0x00390008, 0x003a0008, 0x003b0008, 0x003c0008, 0x003d0008, 0x003e0008,
    0x003f0008, 0x00400008, 0x00410008, 0x00420008, 0x00430008, 0x00440008, 0x00450008, 0x00460008,
    0x00470008, 0x00480008, 0x00490008, 0x004a0008, 0x004b0008, 0x004c0008, 0x004d0008, 0x004e0008,
    0x004f0008, 0x00500008, 0x00510008, 0x00520008, 0x00530008, 0x00540008, 0x00550008, 0x00560008,
    0x00570008, 0x00580008, 0x00590008, 0x005a0008, 0x005b0008, 0x005c0008, 0x005d0008, 0x005e0008,
    0x005f0008, 0x00600008, 0x00610008, 0x00620008, 0x00630008, 0x00640008, 0x00650008, 0x00660008,
    0x00670008, 0x00680008, 0x00690008, 0x006a0008, 0x006b0008, 0x006c0008, 0x006d0008, 0x006e0008,
    0x006f0008, 0x00700008, 0x00710008, 0x00720008, 0x00730008, 0x00740008, 0x00750008, 0x00760008,
    0x00770008, 0x00780008, 0x00790008, 0x007a0008, 0x007b0008, 0x007c0008, 0x007d0008, 0x007e0008,
    0x007f0008, 0x00000007, 0x00010007, 0x00020007, 0x00030007, 0x00040007, 0x00050007, 0x00060007,
    0x00070007, 0x00080007, 0x00090007, 0x000a0007, 0x000b0007, 0x000c0007, 0x000d0007, 0x000e0007,
    0x000f0007, 0x00100007, 0x00110007, 0x00120007, 0x00130007, 0x00140007, 0x00150007, 0x00160007,
    0x00170007, 0x00180007, 0x00190007, 0x001a0007, 0x001b0007, 0x001c0007, 0x001d0007, 0x001e0007,
    0x001f0007, 0x00200007, 0x00210007, 0x00220007, 0x00230007, 0x00240007, 0x00250007, 0x00260007,
    0x00270007, 0x00280007, 0x00290007, 0x002a0007, 0x002b0007, 0x002c0007, 0x002d0007, 0x002e0007,
    0x002f0007, 0x00300007, 0x00310007, 0x00320007, 0x00330007, 0x00340007, 0x00350007, 0x00360007,
    0x00370007, 0x00380007, 0x00390007, 0x003a0007, 0x003b0007, 0x003c0007, 0x003d0007, 0x003e0007,
    0x003f0007, 0x00000006, 0x00010006, 0x00020006, 0x00030006, 0x00040006, 0x00050006, 0x00060006,
    0x00070006, 0x00080006, 0x00090006, 0x000a0006, 0x000b0006, 0x000c0006, 0x000d0006, 0x000e0006,
    0x000f0006, 0x00100006, 0x00110006, 0x00120006, 0x00130006, 0x00140006, 0x00150006, 0x00160006,
    0x00170006, 0x00180006, 0x00190006, 0x001a0006, 0x001b0006, 0x001c0006, 0x001d0006, 0x001e0006,
    0x001f0006, 0x00000005, 0x00010005, 0x00020005, 0x00030005, 0x00040005, 0x00050005, 0x00060005,
    0x00070005, 0x00080005, 0x00090005, 0x000a0005, 0x000b0005, 0x000c0005, 0x000d0005, 0x000e0005,
    0x000f0005, 0x00000004, 0x00010004, 0x00020004, 0x00030004, 0x00040004, 0x00050004, 0x00060004,
    0x00070004, 0x00000003, 0x00010003, 0x00020003, 0x00030003, 0x00000002, 0x00010002, 0x00000001,
    0x00000000, 0x00010001, 0x00020002, 0x00030002, 0x00040003, 0x00050003, 0x00060003, 0x00070003,
    0x00080004, 0x00090004, 0x000a0004, 0x000b0004, 0x000c0004, 0x000d0004, 0x000e0004, 0x000f0004,
    0x00100005, 0x00110005, 0x00120005, 0x00130005, 0x00140005, 0x00150005, 0x00160005, 0x00170005,
    0x00180005, 0x00190005, 0x001a0005, 0x001b0005, 0x001c0005, 0x001d0005, 0x001e0005, 0x001f0005,
    0x00200006, 0x00210006, 0x00220006, 0x00230006, 0x00240006, 0x00250006, 0x00260006, 0x00270006,
    0x00280006, 0x00290006, 0x002a0006, 0x002b0006, 0x002c0006, 0x002d0006, 0x002e0006, 0x002f0006,
    0x00300006, 0x00310006, 0x00320006, 0x00330006, 0x00340006, 0x00350006, 0x00360006, 0x00370006,
    0x00380006, 0x00390006, 0x003a0006, 0x003b0006, 0x003c0006, 0x003d0006, 0x003e0006, 0x003f0006,
    0x00400007, 0x00410007, 0x00420007, 0x00430007, 0x00440007, 0x00450007, 0x00460007, 0x00470007,
    0x00480007, 0x00490007, 0x004a0007, 0x004b0007, 0x004c0007, 0x004d0007, 0x004e0007, 0x004f0007,
    0x00500007, 0x00510007, 0x00520007, 0x00530007, 0x00540007, 0x00550007, 0x00560007, 0x00570007,
    0x00580007, 0x00590007, 0x005a0007, 0x005b0007, 0x005c0007, 0x005d0007, 0x005e0007, 0x005f0007,
    0x00600007, 0x00610007, 0x00620007, 0x00630007, 0x00640007, 0x00650007, 0x00660007, 0x00670007,
    0x00680007, 0x00690007, 0x006a0007, 0x006b0007, 0x006c0007, 0x006d0007, 0x006e0007, 0x006f0007,
    0x00700007, 0x00710007, 0x00720007, 0x00730007, 0x00740007, 0x00750007, 0x00760007, 0x00770007,
    0x00780007, 0x00790007, 0x007a0007, 0x007b0007, 0x007c0007, 0x007d0007, 0x007e0007, 0x007f0007,
    0x00800008, 0x00810008, 0x00820008, 0x00830008, 0x00840008, 0x00850008, 0x00860008, 0x00870008,
    0x00880008, 0x00890008, 0x008a0008, 0x008b0008, 0x008c0008, 0x008d0008, 0x008e0008, 0x008f0008,
    0x00900008, 0x00910008, 0x00920008, 0x00930008, 0x00940008, 0x00950008, 0x00960008, 0x00970008,
    0x00980008, 0x00990008, 0x009a0008, 0x009b0008, 0x009c0008, 0x009d0008, 0x009e0008, 0x009f0008,
    0x00a00008, 0x00a10008, 0x00a20008, 0x00a30008, 0x00a40008, 0x00a50008, 0x00a60008, 0x00a70008,
    0x00a80008, 0x00a90008, 0x00aa0008, 0x00ab0008, 0x00ac0008, 0x00ad0008, 0x00ae0008, 0x00af0008,
    0x00b00008, 0x00b10008, 0x00b20008, 0x00b30008, 0x00b40008, 0x00b50008, 0x00b60008, 0x00b70008,
    0x00b80008, 0x00b90008, 0x00ba0008, 0x00bb0008, 0x00bc0008, 0x00bd0008, 0x00be0008, 0x00bf0008,
    0x00c00008, 0x00c10008, 0x00c20008, 0x00c30008, 0x00c40008, 0x00c50008, 0x00c60008, 0x00c70008,
    0x00c80008, 0x00c90008, 0x00ca0008, 0x00cb0008, 0x00cc0008, 0x00cd0008, 0x00ce0008, 0x00cf0008,
    0x00d00008, 0x00d10008, 0x00d20008, 0x00d30008, 0x00d40008, 0x00d50008, 0x00d60008, 0x00d70008,
    0x00d80008, 0x00d90008, 0x00da0008, 0x00db0008, 0x00dc0008, 0x00dd0008, 0x00de0008, 0x00df0008,
    0x00e00008, 0x00e10008, 0x00e20008, 0x00e30008, 0x00e40008, 0x00e50008, 0x00e60008, 0x00e70008,
    0x00e80008, 0x00e90008, 0x00ea0008, 0x00eb0008, 0x00ec0008, 0x00ed0008, 0x00ee0008, 0x00ef0008,
    0x00f00008, 0x00f10008, 0x00f20008, 0x00f30008, 0x00f40008, 0x00f50008, 0x00f60008, 0x00f70008,
    0x00f80008, 0x00f90008, 0x00fa0008, 0x00fb0008, 0x00fc0008, 0x00fd0008, 0x00fe0008, 0x00ff0008,
    0x01000009, 0x01010009, 0x01020009, 0x01030009, 0x01040009, 0x01050009, 0x01060009, 0x01070009,
    0x01080009, 0x01090009, 0x010a0009, 0x010b0009, 0x010c0009, 0x010d0009, 0x010e0009, 0x010f0009,
    0x01100009, 0x01110009, 0x01120009, 0x01130009, 0x01140009, 0x01150009, 0x01160009, 0x01170009,
    0x01180009, 0x01190009, 0x011a0009, 0x011b0009, 0x011c0009, 0x011d0009, 0x011e0009, 0x011f0009,
    0x01200009, 0x01210009, 0x01220009, 0x01230009, 0x01240009, 0x01250009, 0x01260009, 0x01270009,
    0x01280009, 0x01290009, 0x012a0009, 0x012b0009, 0x012c0009, 0x012d0009, 0x012e0009, 0x012f0009,
    0x01300009, 0x01310009, 0x01320009, 0x01330009, 0x01340009, 0x01350009, 0x01360009, 0x01370009,
    0x01380009, 0x01390009, 0x013a0009, 0x013b0009, 0x013c0009, 0x013d0009, 0x013e0009, 0x013f0009,
    0x01400009, 0x01410009, 0x01420009, 0x01430009, 0x01440009, 0x01450009, 0x01460009, 0x01470009,
    0x01480009, 0x01490009, 0x014a0009, 0x014b0009, 0x014c0009, 0x014d0009, 0x014e0009, 0x014f0009,
    0x01500009, 0x01510009, 0x01520009, 0x01530009, 0x01540009, 0x01550009, 0x01560009, 0x01570009,
    0x01580009, 0x01590009, 0x015a0009, 0x015b0009, 0x015c0009, 0x015d0009, 0x015e0009, 0x015f0009,
    0x01600009, 0x01610009, 0x01620009, 0x01630009, 0x01640009, 0x01650009, 0x01660009, 0x01670009,
    0x01680009, 0x01690009, 0x016a0009, 0x016b0009, 0x016c0009, 0x016d0009, 0x016e0009, 0x016f0009,
    0x01700009, 0x01710009, 0x01720009, 0x01730009, 0x01740009, 0x01750009, 0x01760009, 0x01770009,
    0x01780009, 0x01790009, 0x017a0009, 0x017b0009, 0x017c0009, 0x017d0009, 0x017e0009, 0x017f0009,
    0x01800009, 0x01810009, 0x01820009, 0x01830009, 0x01840009, 0x01850009, 0x01860009, 0x01870009,
    0x01880009, 0x01890009, 0x018a0009, 0x018b0009, 0x018c0009, 0x018d0009, 0x018e0009, 0x018f0009,
    0x01900009, 0x01910009, 0x01920009, 0x01930009, 0x01940009, 0x01950009, 0x01960009, 0x01970009,
    0x01980009, 0x01990009, 0x019a0009, 0x019b0009, 0x019c0009, 0x019d0009, 0x019e0009, 0x019f0009,
    0x01a00009, 0x01a10009, 0x01a20009, 0x01a30009, 0x01a40009, 0x01a50009, 0x01a60009, 0x01a70009,
    0x01a80009, 0x01a90009, 0x01aa0009, 0x01ab0009, 0x01ac0009, 0x01ad0009, 0x01ae0009, 0x01af0009,
    0x01b00009, 0x01b10009, 0x01b20009, 0x01b30009, 0x01b40009, 0x01b50009, 0x01b60009, 0x01b70009,
    0x01b80009, 0x01b90009, 0x01ba0009, 0x01bb0009, 0x01bc0009, 0x01bd0009, 0x01be0009, 0x01bf0009,
    0x01c00009, 0x01c10009, 0x01c20009, 0x01c30009, 0x01c40009, 0x01c50009, 0x01c60009, 0x01c70009,
    0x01c80009, 0x01c90009, 0x01ca0009, 0x01cb0009, 0x01cc0009, 0x01cd0009, 0x01ce0009, 0x01cf0009,
    0x01d00009, 0x01d10009, 0x01d20009, 0x01d30009, 0x01d40009, 0x01d50009, 0x01d60009, 0x01d70009,
    0x01d80009, 0x01d90009, 0x01da0009, 0x01db0009, 0x01dc0009, 0x01dd0009, 0x01de0009, 0x01df0009,
    0x01e00009, 0x01e10009, 0x01e20009, 0x01e30009, 0x01e40009, 0x01e50009, 0x01e60009, 0x01e70009,
    0x01e80009, 0x01e90009, 0x01ea0009, 0x01eb0009, 0x01ec0009, 0x01ed0009, 0x01ee0009, 0x01ef0009,
    0x01f00009, 0x01f10009, 0x01f20009, 0x01f30009, 0x01f40009, 0x01f50009, 0x01f60009, 0x01f70009,
    0x01f80009, 0x01f90009, 0x01fa0009, 0x01fb0009, 0x01fc0009, 0x01fd0009, 0x01fe0009, 0x01ff0009,
    0x0200000a, 0x0201000a, 0x0202000a, 0x0203000a, 0x0204000a, 0x0205000a, 0x0206000a, 0x0207000a,
    0x0208000a, 0x0209000a, 0x020a000a, 0x020b000a, 0x020c000a, 0x020d000a, 0x020e000a, 0x020f000a,
    0x0210000a, 0x0211000a, 0x0212000a, 0x0213000a, 0x0214000a, 0x0215000a, 0x0216000a, 0x0217000a,
    0x0218000a, 0x0219000a, 0x021a000a, 0x021b000a, 0x021c000a, 0x021d000a, 0x021e000a, 0x021f000a,
    0x0220000a, 0x0221000a, 0x0222000a, 0x0223000a, 0x0224000a, 0x0225000a, 0x0226000a, 0x0227000a,
    0x0228000a, 0x0229000a, 0x022a000a, 0x022b000a, 0x022c000a, 0x022d000a, 0x022e000a, 0x022f000a,
    0x0230000a, 0x0231000a, 0x0232000a, 0x0233000a, 0x0234000a, 0x0235000a, 0x0236000a, 0x0237000a,
    0x0238000a, 0x0239000a, 0x023a000a, 0x023b000a, 0x023c000a, 0x023d000a, 0x023e000a, 0x023f000a,
    0x0240000a, 0x0241000a, 0x0242000a, 0x0243000a, 0x0244000a, 0x0245000a, 0x0246000a, 0x0247000a,
    0x0248000a, 0x0249000a, 0x024a000a, 0x024b000a, 0x024c000a, 0x024d000a, 0x024e000a, 0x024f000a,
    0x0250000a, 0x0251000a, 0x0252000a, 0x0253000a, 0x0254000a, 0x0255000a, 0x0256000a, 0x0257000a,
    0x0258000a, 0x0259000a, 0x025a000a, 0x025b000a, 0x025c000a, 0x025d000a, 0x025e000a, 0x025f000a,
    0x0260000a, 0x0261000a, 0x0262000a, 0x0263000a, 0x0264000a, 0x0265000a, 0x0266000a, 0x0267000a,
    0x0268000a, 0x0269000a, 0x026a000a, 0x026b000a, 0x026c000a, 0x026d000a, 0x026e000a, 0x026f000a,
    0x0270000a, 0x0271000a, 0x0272000a, 0x0273000a, 0x0274000a, 0x0275000a, 0x0276000a, 0x0277000a,
    0x0278000a, 0x0279000a, 0x027a000a, 0x027b000a, 0x027c000a, 0x027d000a, 0x027e000a, 0x027f000a,
    0x0280000a, 0x0281000a, 0x0282000a, 0x0283000a, 0x0284000a, 0x0285000a, 0x0286000a, 0x0287000a,
    0x0288000a, 0x0289000a, 0x028a000a, 0x028b000a, 0x028c000a, 0x028d000a, 0x028e000a, 0x028f000a,
    0x0290000a, 0x0291000a, 0x0292000a, 0x0293000a, 0x0294000a, 0x0295000a, 0x0296000a, 0x0297000a,
    0x0298000a, 0x0299000a, 0x029a000a, 0x029b000a, 0x029c000a, 0x029d000a, 0x029e000a, 0x029f000a,
    0x02a0000a, 0x02a1000a, 0x02a2000a, 0x02a3000a, 0x02a4000a, 0x02a5000a, 0x02a6000a, 0x02a7000a,
    0x02a8000a, 0x02a9000a, 0x02aa000a, 0x02ab000a, 0x02ac000a, 0x02ad000a, 0x02ae000a, 0x02af000a,
    0x02b0000a, 0x02b1000a, 0x02b2000a, 0x02b3000a, 0x02b4000a, 0x02b5000a, 0x02b6000a, 0x02b7000a,
    0x02b8000a, 0x02b9000a, 0x02ba000a, 0x02bb000a, 0x02bc000a, 0x02bd000a, 0x02be000a, 0x02bf000a,
    0x02c0000a, 0x02c1000a, 0x02c2000a, 0x02c3000a, 0x02c4000a, 0x02c5000a, 0x02c6000a, 0x02c7000a,
    0x02c8000a, 0x02c9000a, 0x02ca000a, 0x02cb000a, 0x02cc000a, 0x02cd000a, 0x02ce000a, 0x02cf000a,
    0x02d0000a, 0x02d1000a, 0x02d2000a, 0x02d3000a, 0x02d4000a, 0x02d5000a, 0x02d6000a, 0x02d7000a,
    0x02d8000a, 0x02d9000a, 0x02da000a, 0x02db000a, 0x02dc000a, 0x02dd000a, 0x02de000a, 0x02df000a,
    0x02e0000a, 0x02e1000a, 0x02e2000a, 0x02e3000a, 0x02e4000a, 0x02e5000a, 0x02e6000a, 0x02e7000a,
    0x02e8000a, 0x02e9000a, 0x02ea000a, 0x02eb000a, 0x02ec000a, 0x02ed000a, 0x02ee000a, 0x02ef000a,
    0x02f0000a, 0x02f1000a, 0x02f2000a, 0x02f3000a, 0x02f4000a, 0x02f5000a, 0x02f6000a, 0x02f7000a,
    0x02f8000a, 0x02f9000a, 0x02fa000a, 0x02fb000a, 0x02fc000a, 0x02fd000a, 0x02fe000a, 0x02ff000a,
    0x0300000a, 0x0301000a, 0x0302000a, 0x0303000a, 0x0304000a, 0x0305000a, 0x0306000a, 0x0307000a,
    0x0308000a, 0x0309000a, 0x030a000a, 0x030b000a, 0x030c000a, 0x030d000a, 0x030e000a, 0x030f000a,
    0x0310000a, 0x0311000a, 0x0312000a, 0x0313000a, 0x0314000a, 0x0315000a, 0x0316000a, 0x0317000a,
    0x0318000a, 0x0319000a, 0x031a000a, 0x031b000a, 0x031c000a, 0x031d000a, 0x031e000a, 0x031f000a,
    0x0320000a, 0x0321000a, 0x0322000a, 0x0323000a, 0x0324000a, 0x0325000a, 0x0326000a, 0x0327000a,
    0x0328000a, 0x0329000a, 0x032a000a, 0x032b000a, 0x032c000a, 0x032d000a, 0x032e000a, 0x032f000a,
    0x0330000a, 0x0331000a, 0x0332000a, 0x0333000a, 0x0334000a, 0x0335000a, 0x0336000a, 0x0337000a,
    0x0338000a, 0x0339000a, 0x033a000a, 0x033b000a, 0x033c000a, 0x033d000a, 0x033e000a, 0x033f000a,
    0x0340000a, 0x0341000a, 0x0342000a, 0x0343000a, 0x0344000a, 0x0345000a, 0x0346000a, 0x0347000a,
    0x0348000a, 0x0349000a, 0x034a000a, 0x034b000a, 0x034c000a, 0x034d000a, 0x034e000a, 0x034f000a,
    0x0350000a, 0x0351000a, 0x0352000a, 0x0353000a, 0x0354000a, 0x0355000a, 0x0356000a, 0x0357000a,
    0x0358000a, 0x0359000a, 0x035a000a, 0x035b000a, 0x035c000a, 0x035d000a, 0x035e000a, 0x035f000a,
    0x0360000a, 0x0361000a, 0x0362000a, 0x0363000a, 0x0364000a, 0x0365000a, 0x0366000a, 0x0367000a,
    0x0368000a, 0x0369000a, 0x036a000a, 0x036b000a, 0x036c000a, 0x036d000a, 0x036e000a, 0x036f000a,
    0x0370000a, 0x0371000a, 0x0372000a, 0x0373000a, 0x0374000a, 0x0375000a, 0x0376000a, 0x0377000a,
    0x0378000a, 0x0379000a, 0x037a000a, 0x037b000a, 0x037c000a, 0x037d000a, 0x037e000a, 0x037f000a,
    0x0380000a, 0x0381000a, 0x0382000a, 0x0383000a, 0x0384000a, 0x0385000a, 0x0386000a, 0x0387000a,
    0x0388000a, 0x0389000a, 0x038a000a, 0x038b000a, 0x038c000a, 0x038d000a, 0x038e000a, 0x038f000a,
    0x0390000a, 0x0391000a, 0x0392000a, 0x0393000a, 0x0394000a, 0x0395000a, 0x0396000a, 0x0397000a,
    0x0398000a, 0x0399000a, 0x039a000a, 0x039b000a, 0x039c000a, 0x039d000a, 0x039e000a, 0x039f000a,
    0x03a0000a, 0x03a1000a, 0x03a2000a, 0x03a3000a, 0x03a4000a, 0x03a5000a, 0x03a6000a, 0x03a7000a,
    0x03a8000a, 0x03a9000a, 0x03aa000a, 0x03ab000a, 0x03ac000a, 0x03ad000a, 0x03ae000a, 0x03af000a,
    0x03b0000a, 0x03b1000a, 0x03b2000a, 0x03b3000a, 0x03b4000a, 0x03b5000a, 0x03b6000a, 0x03b7000a,
    0x03b8000a, 0x03b9000a, 0x03ba000a, 0x03bb000a, 0x03bc000a, 0x03bd000a, 0x03be000a, 0x03bf000a,
    0x03c0000a, 0x03c1000a, 0x03c2000a, 0x03c3000a, 0x03c4000a, 0x03c5000a, 0x03c6000a, 0x03c7000a,
    0x03c8000a, 0x03c9000a, 0x03ca000a, 0x03cb000a, 0x03cc000a, 0x03cd000a, 0x03ce000a, 0x03cf000a,
    0x03d0000a, 0x03d1000a, 0x03d2000a, 0x03d3000a, 0x03d4000a, 0x03d5000a, 0x03d6000a, 0x03d7000a,
    0x03d8000a, 0x03d9000a, 0x03da000a, 0x03db000a, 0x03dc000a, 0x03dd000a, 0x03de000a, 0x03df000a,
    0x03e0000a, 0x03e1000a, 0x03e2000a, 0x03e3000a, 0x03e4000a, 0x03e5000a, 0x03e6000a, 0x03e7000a,
    0x03e8000a, 0x03e9000a, 0x03ea000a, 0x03eb000a, 0x03ec000a, 0x03ed000a, 0x03ee000a, 0x03ef000a,
    0x03f0000a, 0x03f1000a, 0x03f2000a, 0x03f3000a, 0x03f4000a, 0x03f5000a, 0x03f6000a, 0x03f7000a,
    0x03f8000a, 0x03f9000a, 0x03fa000a, 0x03fb000a, 0x03fc000a, 0x03fd000a, 0x03fe000a, 0x03ff000a};

const unsigned char cMagnitudes[512] = {0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,
    5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9};

/* JPEG DHT Segment for YCrCb omitted from MJPG data */
const unsigned char MJPGDHTSeg[0x1A4] = {
    0xFF,0xC4,0x01,0xA2,
    0x00,0x00,0x01,0x05,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x01,0x00,0x03,0x01,0x01,0x01,0x01,
    0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
    0x08,0x09,0x0A,0x0B,0x10,0x00,0x02,0x01,0x03,0x03,0x02,0x04,0x03,0x05,0x05,0x04,0x04,0x00,
    0x00,0x01,0x7D,0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,0x21,0x31,0x41,0x06,0x13,0x51,0x61,
    0x07,0x22,0x71,0x14,0x32,0x81,0x91,0xA1,0x08,0x23,0x42,0xB1,0xC1,0x15,0x52,0xD1,0xF0,0x24,
    0x33,0x62,0x72,0x82,0x09,0x0A,0x16,0x17,0x18,0x19,0x1A,0x25,0x26,0x27,0x28,0x29,0x2A,0x34,
    0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,
    0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,
    0x79,0x7A,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,
    0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,
    0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,
    0xDA,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,
    0xF8,0xF9,0xFA,0x11,0x00,0x02,0x01,0x02,0x04,0x04,0x03,0x04,0x07,0x05,0x04,0x04,0x00,0x01,
    0x02,0x77,0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
    0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,0xA1,0xB1,0xC1,0x09,0x23,0x33,0x52,0xF0,0x15,0x62,
    0x72,0xD1,0x0A,0x16,0x24,0x34,0xE1,0x25,0xF1,0x17,0x18,0x19,0x1A,0x26,0x27,0x28,0x29,0x2A,
    0x35,0x36,0x37,0x38,0x39,0x3A,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4A,0x53,0x54,0x55,0x56,
    0x57,0x58,0x59,0x5A,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x73,0x74,0x75,0x76,0x77,0x78,
    0x79,0x7A,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
    0x99,0x9A,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,
    0xB9,0xBA,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,
    0xD9,0xDA,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,
    0xF9,0xFA
};

/* JPEG tables */
// zigzag ordering of DCT coefficients
const unsigned char cZigZag[64] = {0,1,5,6,14,15,27,28,
    2,4,7,13,16,26,29,42,
    3,8,12,17,25,30,41,43,
    9,11,18,24,31,40,44,53,
    10,19,23,32,39,45,52,54,
    20,22,33,38,46,51,55,60,
    21,34,37,47,50,56,59,61,
    35,36,48,49,57,58,62,63};

// needed for H263 decoder
const unsigned char cZigZag2[64] = {0,1,8,16,9,2,3,10,
    17,24,32,25,18,11,4,5,
    12,19,26,33,40,48,41,34,
    27,20,13,6,7,14,21,28,
    35,42,49,56,57,50,43,36,
    29,22,15,23,30,37,44,51,
    58,59,52,45,38,31,39,46,
    53,60,61,54,47,55,62,63};

// For AA&N IDCT method, multipliers are equal to quantization
// coefficients scaled by scalefactor[row]*scalefactor[col], where
// scalefactor[0] = 1
// scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
// For integer operation, the multiplier table is to be scaled by
// IFAST_SCALE_BITS.
const int iScaleBits[64] = {16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
    22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
    21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
    19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
    16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
    12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
    8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
    4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247};

//
// Typical DC difference huffman tables for luminance and chrominance
//
const unsigned char huffl_dc[28] = {0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0,
    0,1,2,3,4,5,6,7,8,9,0xa,0xb};
const unsigned char huffcr_dc[28] = {0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0,
    0,1,2,3,4,5,6,7,8,9,0xa,0xb};
//
// Typical AC difference huffman tables for luminance and chrominance
//
const unsigned char huffl_ac[256] = {0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d,
    1,2,3,0,4,0x11,5,0x12,0x21,0x31,0x41,6,0x13,0x51,0x61,7,
    0x22,0x71,0x14,0x32,0x81,0x91,0xa1,8,0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
    0x24,0x33,0x62,0x72,0x82,9,0xa,0x16,0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
    0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
    0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
    0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
    0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
    0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
    0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
    0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    0xf9,0xfa};
const unsigned char huffcr_ac[256] = {0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77,
    0,1,2,3,0x11,4,5,0x21,0x31,6,0x12,0x41,0x51,7,0x61,0x71,
    0x13,0x22,0x32,0x81,0x8,0x14,0x42,0x91,0xa1,0xb1,0xc1,9,0x23,0x33,0x52,0xf0,
    0x15,0x62,0x72,0xd1,0xa,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
    0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
    0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
    0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
    0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
    0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
    0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
    0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    0xf9,0xfa};
// Sample quantization table which can be divided by 2 or 4 or multiplied by 2
// to give different quality levels
const unsigned char quant_lum[64] =
{16,11,12,14,12,10,16,14,13,14,18,17,16,19,24,
    40,26,24,22,22,24,49,35,37,29,40,58,51,61,60,
    57,51,56,55,64,72,92,78,64,68,87,69,55,56,80,
    109,81,87,95,98,103,104,103,62,77,113,121,112,
    100,120,92,101,103,99};
const unsigned char quant_color[64] =
{17,18,18,24,21,24,47,26,26,47,99,66,56,66,99,99,
    99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,
    99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99};

const unsigned char quant95_lum[64] =
{ 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,
    0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x04,
    0x03, 0x02, 0x02, 0x02, 0x02, 0x05, 0x04, 0x04,
    0x03, 0x04, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05,
    0x06, 0x06, 0x06, 0x07, 0x09, 0x08, 0x06, 0x07,
    0x09, 0x07, 0x06, 0x06, 0x08, 0x0b, 0x08, 0x09,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x06, 0x08, 0x0b,
    0x0c, 0x0b, 0x0a, 0x0c, 0x09, 0x0a, 0x0a, 0x0a };
unsigned char quant95_color[64] =
{ 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x05, 0x03,
    0x03, 0x05, 0x0a, 0x07, 0x06, 0x07, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a };

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILReadEXIFThumb()                                         *
 *                                                                          *
 *  PURPOSE    : Try to read the EXIF thumbnail from a JPEG file.           *
 *                                                                          *
 ****************************************************************************/
int PILReadEXIFThumb(PIL_FILE *pFile, PIL_PAGE *pPage, int iOptions)
{
int iErr = 0;
int i, j, iSize, iMarker;
int bDone = FALSE;
int bMotorola;
PIL_FILE pf;
unsigned char pTemp[4096]; // use stack to avoid allocating memory

	memset(&pf, 0, sizeof(pf));
//	i = PILReadAtOffset(pFile, 0, pTemp, 4096);
i = 0;
	if (i != 4096 && i != pFile->iFileSize) // something went wrong
	{
		iErr = PIL_ERROR_IO;
		goto exifthumb_z;
	}
   i = 2; // starting offset to look for tags
   iMarker = 0;
   while (!bDone && i < 4096)
      {
      iMarker = MOTOSHORT(&pTemp[i]);
      i += 2;
	  iSize = MOTOSHORT(&pTemp[i]);
	  if (iMarker < 0xff00) // invalid marker, could be generated by "Arles Image Web Page Creator" or Accusoft
         continue; // skip 2 bytes and try to resync
	  if (0xffed == iMarker) // Adobe
	  {
		  if (memcmp(&pTemp[i + 2], "Photoshop", 9) == 0) // Adobe Photoshop thumbnail
		  {
			  int iAdobeTag, iAdobeLen;
			  int iStartingOffset = 0;
			  // skip past string to start parsing "8BIM" fields
			  i += 12;
			  while (i < iSize && pTemp[i] != '\0') // look for string terminator
			  {
				  i++;
			  }
			  if (pTemp[i] == 0) i++;
			  while (i < iSize && 0x3842494d == MOTOLONG(&pTemp[i])) // start of 8BIM data chain
			  {
				  i += 4;
				  iAdobeTag = MOTOSHORT(&pTemp[i]);
				  i += 2;
				  if (pTemp[i] == 0 && pTemp[i + 1] == 0) // no name string
				  {
					  i += 2;
				  }
				  else
				  {
					  i += (pTemp[i] + 1);
				  }
				  iAdobeLen = MOTOLONG(&pTemp[i]); // get the length of the actual tag data
				  i += 4;
				  if (iAdobeTag != 0x40c && iAdobeTag != 0x409) // we're looking for the thumbnail (4.0/5.0) image only
				  { // skip forward to the next tag
					  i += iAdobeLen;
					  if (iAdobeLen & 1) // padded to make it an even length
					  {
						  i++;
					  }
					  iSize -= i;
					  iStartingOffset += i;
					  i = 0;
//					  PILReadAtOffset(pFile, iStartingOffset, pTemp, 256);
					  continue;
				  }
				  // We found the potential thumbnail. Make sure it's what we expect
				  pPage->iWidth = MOTOLONG(&pTemp[i + 4]);
				  pPage->iHeight = MOTOLONG(&pTemp[i + 8]);
				  pPage->cBitsperpixel = 24;
				  pPage->cCompression = PIL_COMP_JPEG;
				  pPage->iDataSize = iAdobeLen;
				  i += 28; // prefix we're not interested in the rest of this
				  if (0xffd8 == MOTOSHORT(&pTemp[i])) // got what we want
				  {
					  if (iAdobeLen < iSize) // the size is reasonable
					  {
						  pPage->pData = (unsigned char *)PILIOAllocNoClear(iAdobeLen);
						  if (pPage->pData != NULL)
						  {
//							  i = PILReadAtOffset(pFile, iStartingOffset + i, pPage->pData, iAdobeLen);
							  pPage->cState = PIL_PAGE_STATE_LOADED;
							  if (i == iAdobeLen)
							  {
								  iErr = PIL_ERROR_SUCCESS;
								  goto exifthumb_z;
							  }
							  PILIOFree(pPage->pData); // something went wrong
							  pPage->pData = NULL;
							  iErr = PIL_ERROR_UNKNOWN;
							  goto exifthumb_z;
						  }
						  else
						  {
							  iErr = PIL_ERROR_MEMORY;
							  goto exifthumb_z;
						  }
					  }
				  }
			  }
		  }
	  }
      if (0xffe1 == iMarker) // look for EXIF thumbnail
         {
         if (pTemp[i+2] == 'E' && pTemp[i+3] == 'x' && (pTemp[i+8] == 'I' || pTemp[i+8] == 'M')) // APP1, Exif - this is the one we want
            {
            iSize = MOTOSHORT(&pTemp[i]);
			if (iSize < 1024) // too small to have an embedded thumbnail
			{
				iErr = PIL_ERROR_PAGENF;
				goto exifthumb_z;
			}
			pf.iFileSize = iSize;
			pf.cState = PIL_FILE_STATE_LOADED;
			if (pFile->cState == PIL_FILE_STATE_LOADED) // the file is already in memory, set up a fake sub file with a pointer change
			{
				pf.pData = &pFile->pData[i + 8]; // start of embedded TIFF file
				pf.iFileSize = iSize;
			}
			else // need to allocated and read the file data into memory
			{
				pf.pData = (unsigned char *) PILIOAllocNoClear(iSize);
				if (pf.pData == NULL)
				{
					iErr = PIL_ERROR_MEMORY;
					goto exifthumb_z;
				}
//				j = PILReadAtOffset(pFile, i + 8, pf.pData, iSize); // seek to the start of the embedded TIFF File and read just the thumbnail image data (TIFF header too)
				if (j != iSize) // something went wrong, free buffer and leave with error
				{
					iErr = PIL_ERROR_IO;
					goto exifthumb_z;
				}
			}
            bMotorola = (pTemp[i+8] == 'M');
            if (!bMotorola) // Intel byte order
               {
               j = INTELLONG(&pTemp[i+12]); // get offset to first IFD (info)
               pPage->iOffset = j; // scan the first IFD for the camera settings
               pPage->iFrameDelay = 0;
               PILTIFFInfo(&pf, pPage, iOptions);
               if (pPage->iFrameDelay) // sub section has special EXIF tags
                  PILGetEXIFInfo(pf.pData, 0, pPage->iFrameDelay, bMotorola, pPage);
               j += 2 + 12*(INTELSHORT(&pf.pData[j])); // point to second IFD (image)
               pPage->iOffset = INTELLONG(&pf.pData[j]); // offset to this IFD
               }
            else
               {
               j = MOTOLONG(&pTemp[i+12]); // get offset to first IFD (info)
               pPage->iOffset = j; // scan the first IFD for the camera settings
               pPage->iFrameDelay = 0;
               PILTIFFInfo(&pf, pPage, iOptions);
               if (pPage->iFrameDelay) // sub section has special EXIF tags
                  PILGetEXIFInfo(pf.pData, 0, pPage->iFrameDelay, bMotorola, pPage);
               j += 2 + 12*(MOTOSHORT(&pf.pData[j])); // point to second IFD (image)
               pPage->iOffset = MOTOLONG(&pf.pData[j]); // offset to this IFD
               }
            if (pPage->iOffset > iSize) // points past the end of our EXIF data, abort
               {
               iErr = PIL_ERROR_BADHEADER;
			   goto exifthumb_z;
               }
			if (pPage->iOffset == 0) // no second IFD means no embedded thumbnail
			{
				iErr = PIL_ERROR_PAGENF;
				goto exifthumb_z;
			}
//            if (pFile->pData == NULL)
//               pFile->pData = pPage->pData; // allow TIFFInfo function to find the data
            pPage->iWidth = pPage->iHeight = 24; // thumbnail EXIF info may not contain size
            pPage->cBitsperpixel = 24; // this will make it error out of PILTIFFInfo() even though it may be valid
            PILTIFFInfo(&pf, pPage, iOptions); // scan the sub-image IFD for the image data pointer
            if (pPage->cCompression == 0) // some thumbnail images are missing the TIFF tag which specifies JPEG data
               pPage->cCompression = PIL_COMP_JPEG;
			if (pPage->cState != PIL_PAGE_STATE_LOADED) // something went wrong in reading the JPEG image
               {
				if (pFile->cState != PIL_FILE_STATE_LOADED)
				{
					PILIOFree(pf.pData);
					pf.pData = NULL;
				}
               iErr = PIL_ERROR_PAGENF;
               }
            break;
            }
         else
            {
            i += iSize;
            continue;
            }
         } // APP1 marker
      if (iMarker == 0xffc0) // found SOF0 (Start Of Frame) and no EXIF
         {
         iErr = PIL_ERROR_PAGENF;
         break;
         }
      else // other markers, just skip
         {
         i += iSize;
         }
      }
   if (i >= 4096 && iMarker != 0xffc0)
	   iErr = PIL_ERROR_PAGENF; // we never found valid markers
exifthumb_z:
   if (pFile->cState != PIL_FILE_STATE_LOADED) // we allocated a buffer for a memory-file
	   PILIOFree(pf.pData);
   if (iErr == PIL_ERROR_SUCCESS)
      {
	  // get full sized image info into PIL_FILE struct, but don't overwrite it if it was not parsed from the EXIF data
	  if (pPage->iOriginalWidth > 0)
		 pFile->iX = pPage->iOriginalWidth;
	  if (pPage->iOriginalHeight > 0)
		 pFile->iY = pPage->iOriginalHeight;
	  pFile->cBpp = pPage->cBitsperpixel;
	  pFile->iOrientation = pPage->iOrientation;
      }
   return iErr;

} /* PILReadEXIFThumb() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGetHuffTables(char *, int , JPEGDATA *)                *
 *                                                                          *
 *  PURPOSE    : Get the Huffman table(s) into my internal structure.       *
 *                                                                          *
 ****************************************************************************/
int JPEGGetHuffTables(unsigned char *pBuf, int iLen, JPEGDATA *pJPEG)
{
    int i, j, iOffset, iTableOffset;
    unsigned char ucTable;
    
    iOffset = 0;
    while (iLen > 17)  // while there are tables to copy (we may have combined more than 1 table together)
    {
        ucTable = pBuf[iOffset++]; // get table index
        if (ucTable & 0x10) // convert AC offset of 0x10 into offset of 4
            ucTable ^= 0x14;
        pJPEG->ucHuffTableUsed[ucTable] = 1; // mark this table as being defined
        if (ucTable <= 7) // tables are 0-3, AC+DC
        {
            iTableOffset = ucTable * HUFF_TABLEN;
            j = 0; // total bits
            for (i=0; i<16; i++)
            {
                j += pBuf[iOffset];
                pJPEG->ucHuffVals[iTableOffset+i] = pBuf[iOffset++];
            }
            iLen -= 17; // subtract length of bit lengths
            if (j == 0 || j > 256 || j > iLen) // bogus bit lengths
            {
                return -1;
            }
            iTableOffset += 16;
            for (i=0; i<j; i++)
            {  // copy huffman table
                pJPEG->ucHuffVals[iTableOffset+i] = pBuf[iOffset++];
            }
            iLen -= j;
        }
    }
    return 0;
} /* JPEGGetHuffTables() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGProcessTables(char *, int *, char *)                   *
 *                                                                          *
 *  PURPOSE    : Read useful data tables from the header (markers).         *
 *                                                                          *
 ****************************************************************************/
unsigned char JPEGProcessTables(unsigned char *buf, int *iOff, JPEGDATA *pJPEG, int iDataSize, PIL_PAGE *inpage)
{
    int iOffset = *iOff;
    int i, iTableOffset;
    unsigned char cMarker, ucTable;
    unsigned short sLen;
    int bDone;
    int iLimit;
    
    if (inpage->cState == PIL_PAGE_STATE_LOADED)
        iLimit = iDataSize-2;
    else
        iLimit = PIL_BUFFER_SIZE;
    
    bDone = FALSE;
    cMarker = 0;
    while (!bDone && iOffset <= iLimit && iOffset <= (iDataSize-2))
    {
        if (buf[iOffset] != 0xff) // invalid marker, try to resync
        {
            iOffset += 2;
            continue;
        }
        cMarker = buf[iOffset+1];
        iOffset += 2;
        if (cMarker == 0xd8) // SOI
            continue;
        if (cMarker == 0xd9)
            return cMarker; // we've reached the end
        else
            sLen = MOTOSHORT(&buf[iOffset]);
        if (iOffset+sLen > iLimit) // not enough data
        {
            if ((iOffset+sLen) > iDataSize-2) // not enough data in the file, quit
                return 0; // return invalid marker
            if (!bDone && iOffset >= PIL_BUFFER_SIZE-4 && inpage != NULL && inpage->cState == PIL_FILE_STATE_OPEN && inpage->file != 0)
            {
//                PILReadBlock(inpage, &iOffset); // need to read more data
            }
        }
        switch (cMarker)
        {
            case 0xe1: /* APP1 = EXIF info */
                if (memcmp(&buf[iOffset+2],"Exif",4) == 0) // YES!
                {
                    if (sLen > 8) // if there is any EXIF info (found a file with EXIF header and no info)
                        pJPEG->iEXIF = iOffset+8; // save the EXIF offset for later
                }
                iOffset += (int)sLen;   // skip this data for now
                break;
            case 0xe0: /* APP0 */
                iOffset += 2; // skip length
                sLen -= 2;
                pJPEG->xdpi = MOTOSHORT(&buf[iOffset + 8]);
                pJPEG->ydpi = MOTOSHORT(&buf[iOffset + 10]);
                if (buf[iOffset + 7] == 2) /* If not DPI, convert DPCM */
                {
                    pJPEG->xdpi = (pJPEG->xdpi * 254) / 100;
                    pJPEG->ydpi = (pJPEG->ydpi * 254) / 100;
                }
                iOffset += (int)sLen;
                break;
            case 0xee: // APP14 - Adobe defines the colorspace
                // 0 (3 channel = RGB, 4 channel = CMYK)
                // 1 YCbCr (normal JPEG colorspace)
                // 2 YCCK (basically inverted YCbCr)
                if (memcmp(&buf[iOffset+2],"Adobe",5) == 0)
                {
                    if (buf[iOffset + 13] == 0)
                        pJPEG->iOptions |= PIL_CONVERT_JPEG_RGB;
                    if (buf[iOffset + 13] == 2)
                        pJPEG->iOptions |= PIL_CONVERT_JPEG_YCCK;
                }
                
                iOffset += (int)sLen; // skip to next marker
                break;
            case 0xcc: /* M_DAC */ // I don't support arithmetic tables, so ignore
                iOffset += (int)sLen;
                break;
            case 0xdb: /* M_DQT */
                pJPEG->ulHeaderFlags |= PIL_JPEGHDR_QUANT;
                /* Get the quantization tables */
                /* first byte has PPPPNNNN where P = precision and N = table number 0-3 */
                iOffset += 2; // skip length
                sLen -= 2; // subtract length length
                while (sLen > 0)
                {
                    if (iOffset > iLimit) // something is very wrong
                        return 0;
                    ucTable = buf[iOffset++]; // table number
                    if ((ucTable & 0xf) > 3) // invalid table number
                        return 0;
                    iTableOffset = (ucTable & 0xf) * DCTSIZE2;
                    if (ucTable & 0xf0) // if word precision
                    {
                        for (i=0; i<DCTSIZE2; i++)
                        {
                            pJPEG->sQuantTable[i+iTableOffset] = MOTOSHORT(&buf[iOffset]);
                            iOffset += 2;
                        }
                        sLen -= (DCTSIZE2*2 + 1);
                    }
                    else
                    {
                        for (i=0; i<DCTSIZE2; i++)
                        {
                            pJPEG->sQuantTable[i+iTableOffset] = (unsigned short)buf[iOffset++];
                        }
                        sLen -= (DCTSIZE2 + 1);
                    }
                }
                break;
            case 0xc4: /* M_DHT */ // get Huffman tables
                pJPEG->ulHeaderFlags |= PIL_JPEGHDR_HUFF;
                iOffset += 2; // skip length
                sLen -= 2; // subtract length length
                if (JPEGGetHuffTables(&buf[iOffset], sLen, pJPEG) != 0) // bad tables?
                    return 0;
                iOffset += sLen; // skip to next marker
                break;
            case 0xdd: /* M_DRI - restart interval */
                pJPEG->ulHeaderFlags |= PIL_JPEGHDR_RST;
                if (sLen == 4)
                    pJPEG->iResInterval = pJPEG->iResCount = MOTOSHORT(&buf[iOffset+2]);
                iOffset += sLen;
                break;
            case 0xfe: /* M_COM - comment - copy to page structure */
                i = sLen-2;
                if (i > 127)
                    i = 127; // max length we can handle
//                memset(pJPEG->szComment, 0, 128);
//                memcpy(pJPEG->szComment, &buf[iOffset+2], i);
                iOffset += sLen;
                break;
            case 0xd8: /* SOI, return */
            case 0xd9: /* EOI, return */
                bDone = TRUE;
                break;
            case 0xda: /* SOS, return */
                pJPEG->ulHeaderFlags |= PIL_JPEGHDR_SOS;
                bDone = TRUE;
                break;
            case 0xc0:  // baseline sequential DCT
            case 0xc1:  // Extended sequential DCT
            case 0xc2:  // Progressive baseline DCT
            case 0xc3:  // lossless (sequential)
                pJPEG->iMode = cMarker;
                pJPEG->ulHeaderFlags |= PIL_JPEGHDR_SOF;
                if (JPEGGetSOF(buf, &iOffset, pJPEG)) // problem
                {
                    cMarker = 0x01; // return a bogus marker to indicate a problem
                    bDone = TRUE;
                }
                break;
            case 0xff: // not sure why, but Ricoh adds an extra 0xff
                iOffset--;
                break;
            default: /* Skip the unknown marker */
                iOffset += (int)sLen;
                break;
        }
        // Need to read more data
        if (!bDone && iOffset >= PIL_BUFFER_SIZE-4 && inpage != NULL && inpage->cState == PIL_FILE_STATE_OPEN && inpage->file != 0)
        {
//            PILReadBlock(inpage, &iOffset);
        }
    }
    
    *iOff = iOffset;
    return cMarker; /* Return the marker which allowed us to exit from the loop */
    
} /* JPEGProcessTables() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGetSOI(JPEGDATA *)                                     *
 *                                                                          *
 *  PURPOSE    : Process the start of image marker.                         *
 *                                                                          *
 ****************************************************************************/
void JPEGGetSOI(JPEGDATA *pJPEG)
{
    pJPEG->iResInterval = 0;
    pJPEG->xdpi = pJPEG->ydpi = 1;  // assume no valid DPI info
    
} /* JPEGGetSOI() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGetSOF(char *, int *, JPEGDATA *)                      *
 *                                                                          *
 *  PURPOSE    : Process the start of frame marker.                         *
 *                                                                          *
 ****************************************************************************/
int JPEGGetSOF(unsigned char *buf, int *iOff, JPEGDATA *pJPEG)
{
    int iOffset = *iOff;
    int i;
    unsigned short usLen;
    unsigned char ucSamp;
    
    usLen = MOTOSHORT(&buf[iOffset]);
    iOffset += 2;
    pJPEG->ucBitsPerSample = buf[iOffset++];
    if (pJPEG->ucBitsPerSample < 8 || pJPEG->ucBitsPerSample > 16) // we only support 8-16 bits per pixel
        return TRUE;
    pJPEG->cy = (int)MOTOSHORT(&buf[iOffset]); // ysize
    iOffset += 2;
    pJPEG->cx = (int)MOTOSHORT(&buf[iOffset]); // xsize
    iOffset += 2;
    pJPEG->ucNumComponents = buf[iOffset++]; // number of color components
    if (usLen != (8 + pJPEG->ucNumComponents*3)) // invalid length
        return TRUE;
    for (i=0; i<pJPEG->ucNumComponents; i++)
    {
        pJPEG->JPCI[i].component_id = buf[iOffset++];
        pJPEG->JPCI[i].component_index = (unsigned char)i;
        ucSamp = buf[iOffset++]; // get the h+v sampling factor
        if (i == 0) // Y component?
            pJPEG->jpegsample = ucSamp;
        pJPEG->JPCI[i].h_samp_factor = ucSamp >> 4;
        pJPEG->JPCI[i].v_samp_factor = ucSamp & 0xf;
        pJPEG->JPCI[i].quant_tbl_no = buf[iOffset++]; // quantization table number
    }
    if (pJPEG->ucNumComponents == 1)
        pJPEG->jpegsample = 0; // use this to differentiate from color 1:1
    *iOff = iOffset;
    return FALSE;
    
} /* JPEGGetSOF() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGetSOS(char *, int *, JPEGDATA *)                      *
 *                                                                          *
 *  PURPOSE    : Process the start of scan marker.                          *
 *                                                                          *
 ****************************************************************************/
int JPEGGetSOS(unsigned char *buf, int *iOff, JPEGDATA *pJPEG)
{
    short sLen;
    int iOffset = *iOff;
    int i, j;
    unsigned char uc,c,cc;
    
    sLen = MOTOSHORT(&buf[iOffset]);
    iOffset += 2;
    
    // Assume no components in this scan
    for (i=0; i<4; i++)
        pJPEG->JPCI[i].component_needed = 0;
    
    uc = buf[iOffset++]; // get number of components
    pJPEG->ucComponentsInScan = uc;
    sLen -= 3;
    if (uc < 1 || uc > MAX_COMPS_IN_SCAN || sLen != (uc*2+3)) // check length of data packet
        return TRUE; // error
    for (i=0; i<uc; i++)
    {
        cc = buf[iOffset++];
        c = buf[iOffset++];
        sLen -= 2;
        for (j=0; j<4; j++) // search for component id
        {
            if (pJPEG->JPCI[j].component_id == cc)
                break;
        }
        if (j == 4) // error, not found
            return TRUE;
        if ((c & 0xf) > 3 || (c & 0xf0) > 0x30)
            return TRUE; // bogus table numbers
        pJPEG->JPCI[j].dc_tbl_no = c >> 4;
        pJPEG->JPCI[j].ac_tbl_no = c & 0xf;
        pJPEG->JPCI[j].component_needed = 1; // mark this component as being included in the scan
    }
    pJPEG->iScanStart = buf[iOffset++]; // Get the scan start (or lossless predictor) for this scan
    pJPEG->iScanEnd = buf[iOffset++]; // Get the scan end for this scan
    c = buf[iOffset++]; // successive approximation bits
    pJPEG->cApproxBitsLow = c & 0xf; // also point transform in lossless mode
    pJPEG->cApproxBitsHigh = c >> 4;
    
    *iOff = iOffset;
    return FALSE;
    
} /* JPEGGetSOS() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGMakeHuffTables_Slow(JPEGDATA *, int)                  *
 *                                                                          *
 *  PURPOSE    : Create the expanded Huffman tables for "slow" decode.      *
 *                                                                          *
 ****************************************************************************/
int JPEGMakeHuffTables_Slow(JPEGDATA *pJPEG, int bThumbnail)
{
    int code, repeat, count, codestart;
    int j;
    int iLen, iTable;
    unsigned short *pTable, *pShort, *pLong;
    unsigned char *pucTable, *pucShort, *pucLong;
    uint32_t ul, *pLongTable;
    int iBitNum; // current code bit length
    int cc; // code
    unsigned char *p, *pBits, ucCode;
    int iMaxLength, iMaxMask;
    
    pJPEG->b11Bit = 1; // indicate we're using the bigger A/C decode tables
    // first do DC components (up to 4 tables of 12-bit codes)
    // we can save time and memory for the DC codes by knowing that there exist short codes (<= 6 bits)
    // and long codes (>6 bits, but the first 5 bits are 1's).  This allows us to create 2 tables: a 6-bit and 7 or 8-bit
    // to handle any DC codes
    iMaxLength = 12; // assume DC codes can be 12-bits
    iMaxMask = 0x7f; // lower 7 bits after truncate 5 leading 1's
    if (pJPEG->iMode == 0xc3) // create 13-bit tables for lossless mode
    {
        iMaxLength = 13;
        iMaxMask = 0xff;
    }
    for (iTable = 0; iTable < 2; iTable++)
    {
        if (pJPEG->ucHuffTableUsed[iTable])
        {
            //         pJPEG->huffdcFast[iTable] = (int *)PILIOAlloc(0x180); // short table = 128 bytes, long table = 256 bytes
            pucShort = (unsigned char *)pJPEG->huffdcFast[iTable];
            //         pJPEG->huffdc[iTable] = pJPEG->huffdcFast[iTable] + 0x20; // 0x20 longs = 128 bytes
            pucLong = (unsigned char *)pJPEG->huffdc[iTable];
            pBits = &pJPEG->ucHuffVals[iTable * HUFF_TABLEN];
            p = pBits;
            p += 16; // point to bit data
            cc = 0; // start with a code of 0
            for (iBitNum = 1; iBitNum <= 16; iBitNum++)
            {
                iLen = *pBits++; // get number of codes for this bit length
                if (iBitNum > iMaxLength && iLen > 0) // we can't handle codes longer a certain length
                {
                    return -1;
                }
                while (iLen)
                {
                    //               if (iBitNum > 6) // do long table
                    if ((cc >> (iBitNum-5)) == 0x1f) // first 5 bits are 1 - use long table
                    {
                        count = iMaxLength - iBitNum;
                        codestart = cc << count;
                        pucTable = &pucLong[codestart & iMaxMask]; // use lower 7/8 bits of code
                    }
                    else // do short table
                    {
                        count = 6 - iBitNum;
                        if (count < 0)
                            return -1; // DEBUG - something went wrong
                        codestart = cc << count;
                        pucTable = &pucShort[codestart];
                    }
                    ucCode = *p++;  // get actual huffman code
                    if (ucCode == 16 && pJPEG->iMode == 0xc3) // lossless mode
                    {
                        // in lossless mode, this code won't fit in 4 bits, so save it's length in the next slot
                        ucCode = 255;
                        pucLong[256] = (unsigned char)iBitNum;
                    }
                    // does precalculating the DC value save time on ARM?
#ifndef USE_ARM_ASM
                    if (ucCode != 0 && (ucCode + iBitNum) <= 6 && pJPEG->iMode != 0xc2) // we can fit the magnitude value in the code lookup (not for progressive)
                    {
                        int k, iLoop;
                        unsigned char ucCoeff;
                        unsigned char *d = &pucTable[512];
                        unsigned char ucMag = ucCode;
                        ucCode |= ((iBitNum+ucCode) << 4); // add magnitude bits to length
                        repeat = 1<<ucMag;
                        iLoop = 1<<(count-ucMag);
                        for (j=0; j<repeat; j++)
                        { // calcuate the magnitude coeff already
                            if (j & 1<<(ucMag-1)) // positive number
                                ucCoeff = (unsigned char)j;
                            else // negative number
                                ucCoeff = (unsigned char)(j - ((1<<ucMag)-1));
                            for (k=0; k<iLoop; k++)
                            {
                                *d++ = ucCoeff;
                            } // for k
                        } // for j
                    }
#endif
                    else
                    {
                        ucCode |= (iBitNum << 4);
                    }
                    if (count) // do it as dwords to save time
                    {
                        repeat = (1<<count);
                        memset(pucTable, ucCode, repeat);
                        //                  pLongTable = (uint32_t *)pTable;
                        //                  repeat = 1 << (count-2); // store as dwords (/4)
                        //                  ul = code | (code << 16);
                        //                  for (j=0; j<repeat; j++)
                        //                     *pLongTable++ = ul;
                    }
                    else
                    {
                        pucTable[0] = ucCode;
                    }
                    cc++;
                    iLen--;
                }
                cc <<= 1;
            }
        } // if table defined
    }
    // now do AC components (up to 2 tables of 16-bit codes)
    // We split the codes into a short table (9 bits or less) and a long table (first 5 bits are 1)
    for (iTable = 0; iTable < 2; iTable++)
    {
        if (pJPEG->ucHuffTableUsed[iTable+2])  // if this table is defined
        {
            pBits = &pJPEG->ucHuffVals[(iTable+2) * HUFF_TABLEN];
            p = pBits;
            p += 16; // point to bit data
            //         pJPEG->huffacFast[iTable] = (int *)PILIOAlloc(0x1400); // fast table = 1024 bytes, slow = 4096
            //         pJPEG->huffac[iTable] = pJPEG->huffacFast[iTable] + 0x100; // 0x100 longs = 1024 bytes
//            if (iTable > 0) // use other buffer
//                pShort = (unsigned short *)&pJPEG->ucAltHuff[(iTable-1)*0x4000];
//            else
                pShort = (unsigned short *)pJPEG->huffacFast[0];
            pLong = &pShort[0x1000]; //(unsigned short *)pJPEG->huffac[iTable*2];
            cc = 0; // start with a code of 0
            // construct the decode table
            for (iBitNum = 1; iBitNum <= 16; iBitNum++)
            {
                iLen = *pBits++; // get number of codes for this bit length
                while (iLen)
                {
                    if ((cc >> (iBitNum-4)) == 0xf) // first 4 bits are 1 - use long table
                    {
                        count = 16 - iBitNum;
                        codestart = cc << count;
                        pTable = &pLong[codestart & 0xfff]; // use lower 12 bits of code
                    }
                    else
                    {
                        count = 12 - iBitNum;
                        if (count < 0) // a 13-bit? code - that doesn't fit our optimized scheme, see if we can do a bigger table version
                        {
                            return -1; // DEBUG - fatal error, we currently don't support it
                        }
                        codestart = cc << count;
                        pTable = &pShort[codestart]; // 11 bits or shorter
                    }
                    code = *p++;  // get actual huffman code
                    if (bThumbnail && code != 0) // add "extra" bits to code length since we skip these codes
                    {
                        // get rid of extra bits in code and add increment (1) for AC index
                        code = ((iBitNum+(code & 0xf)) << 8) | ((code >> 4)+1);
                    }
                    else
                    {
                        code |= (iBitNum << 8);
                    }
                    if (count) // do it as dwords to save time
                    {
                        repeat = 1 << (count-1); // store as dwords (/2)
                        ul = code | (code << 16);
                        pLongTable = (uint32_t *)pTable;
                        for (j=0; j<repeat; j++)
                            *pLongTable++ = ul;
                    }
                    else
                    {
                        pTable[0] = (unsigned short)code;
                    }
                    cc++;
                    iLen--;
                }
                cc <<= 1;
            } // for each bit length
        } // if table defined
    }
    return 0;
} /* JPEGMakeHuffTables_Slow() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGMakeHuffTables(JPEGDATA *, int)                       *
 *                                                                          *
 *  PURPOSE    : Create the expanded Huffman tables for fast decode.        *
 *                                                                          *
 ****************************************************************************/
int JPEGMakeHuffTables(JPEGDATA *pJPEG, int bThumbnail)
{
    int code, repeat, count, codestart;
    int j;
    int iLen, iTable;
    unsigned short *pTable, *pShort, *pLong;
    unsigned char *pucTable, *pucShort, *pucLong;
    uint32_t ul, *pLongTable;
    int iBitNum; // current code bit length
    int cc; // code
    unsigned char *p, *pBits, ucCode;
    int iMaxLength, iMaxMask;
    int iTablesUsed;
    
    iTablesUsed = 0;
    for (j=0; j<4; j++)
    {
        if (pJPEG->ucHuffTableUsed[j] != 0)
            iTablesUsed++;
    }
    // first do DC components (up to 4 tables of 12-bit codes)
    // we can save time and memory for the DC codes by knowing that there exist short codes (<= 6 bits)
    // and long codes (>6 bits, but the first 5 bits are 1's).  This allows us to create 2 tables: a 6-bit and 7 or 8-bit
    // to handle any DC codes
    iMaxLength = 12; // assume DC codes can be 12-bits
    iMaxMask = 0x7f; // lower 7 bits after truncate 5 leading 1's
    if (pJPEG->iMode == 0xc3) // create 13-bit tables for lossless mode
    {
        iMaxLength = 13;
        iMaxMask = 0xff;
    }
    for (iTable = 0; iTable < 4; iTable++)
    {
        if (pJPEG->ucHuffTableUsed[iTable])
        {
            //         pJPEG->huffdcFast[iTable] = (int *)PILIOAlloc(0x180); // short table = 128 bytes, long table = 256 bytes
            pucShort = (unsigned char *)pJPEG->huffdcFast[iTable];
            //         pJPEG->huffdc[iTable] = pJPEG->huffdcFast[iTable] + 0x20; // 0x20 longs = 128 bytes
            pucLong = (unsigned char *)pJPEG->huffdc[iTable];
            pBits = &pJPEG->ucHuffVals[iTable * HUFF_TABLEN];
            p = pBits;
            p += 16; // point to bit data
            cc = 0; // start with a code of 0
            for (iBitNum = 1; iBitNum <= 16; iBitNum++)
            {
                iLen = *pBits++; // get number of codes for this bit length
                if (iBitNum > iMaxLength && iLen > 0) // we can't handle codes longer a certain length
                {
                    return -1;
                }
                while (iLen)
                {
                    //               if (iBitNum > 6) // do long table
                    if ((cc >> (iBitNum-5)) == 0x1f) // first 5 bits are 1 - use long table
                    {
                        count = iMaxLength - iBitNum;
                        codestart = cc << count;
                        pucTable = &pucLong[codestart & iMaxMask]; // use lower 7/8 bits of code
                    }
                    else // do short table
                    {
                        count = 6 - iBitNum;
                        if (count < 0)
                            return -1; // DEBUG - something went wrong
                        codestart = cc << count;
                        pucTable = &pucShort[codestart];
                    }
                    ucCode = *p++;  // get actual huffman code
                    if (ucCode == 16 && pJPEG->iMode == 0xc3) // lossless mode
                    {
                        // in lossless mode, this code won't fit in 4 bits, so save it's length in the next slot
                        ucCode = 255;
                        pucLong[256] = (unsigned char)iBitNum;
                    }
                    // does precalculating the DC value save time on ARM?
#ifndef USE_ARM_ASM
                    if (ucCode != 0 && (ucCode + iBitNum) <= 6 && pJPEG->iMode != 0xc2) // we can fit the magnitude value in the code lookup (not for progressive)
                    {
                        int k, iLoop;
                        unsigned char ucCoeff;
                        unsigned char *d = &pucTable[512];
                        unsigned char ucMag = ucCode;
                        ucCode |= ((iBitNum+ucCode) << 4); // add magnitude bits to length
                        repeat = 1<<ucMag;
                        iLoop = 1<<(count-ucMag);
                        for (j=0; j<repeat; j++)
                        { // calcuate the magnitude coeff already
                            if (j & 1<<(ucMag-1)) // positive number
                                ucCoeff = (unsigned char)j;
                            else // negative number
                                ucCoeff = (unsigned char)(j - ((1<<ucMag)-1));
                            for (k=0; k<iLoop; k++)
                            {
                                *d++ = ucCoeff;
                            } // for k
                        } // for j
                    }
#endif
                    else
                    {
                        ucCode |= (iBitNum << 4);
                    }
                    if (count) // do it as dwords to save time
                    {
                        repeat = (1<<count);
                        memset(pucTable, ucCode, repeat);
                        //                  pLongTable = (uint32_t *)pTable;
                        //                  repeat = 1 << (count-2); // store as dwords (/4)
                        //                  ul = code | (code << 16);
                        //                  for (j=0; j<repeat; j++)
                        //                     *pLongTable++ = ul;
                    }
                    else
                    {
                        pucTable[0] = ucCode;
                    }
                    cc++;
                    iLen--;
                }
                cc <<= 1;
            }
        } // if table defined
    }
    // now do AC components (up to 2 tables of 16-bit codes)
    // We split the codes into a short table (9 bits or less) and a long table (first 5 bits are 1)
    for (iTable = 0; iTable < 2; iTable++)
    {
        if (pJPEG->ucHuffTableUsed[iTable+2])  // if this table is defined
        {
            pBits = &pJPEG->ucHuffVals[(iTable+2) * HUFF_TABLEN];
            p = pBits;
            p += 16; // point to bit data
            //         pJPEG->huffacFast[iTable] = (int *)PILIOAlloc(0x1400); // fast table = 1024 bytes, slow = 4096
            //         pJPEG->huffac[iTable] = pJPEG->huffacFast[iTable] + 0x100; // 0x100 longs = 1024 bytes
            pShort = (unsigned short *)pJPEG->huffacFast[iTable];
            pLong = (unsigned short *)pJPEG->huffac[iTable];
            cc = 0; // start with a code of 0
            // construct the decode table
            for (iBitNum = 1; iBitNum <= 16; iBitNum++)
            {
                iLen = *pBits++; // get number of codes for this bit length
                while (iLen)
                {
                    if ((cc >> (iBitNum-6)) == 0x3f) // first 6 bits are 1 - use long table
                    {
                        count = 16 - iBitNum;
                        codestart = cc << count;
                        pTable = &pLong[codestart & 0x3ff]; // use lower 10 bits of code
                    }
                    else
                    {
                        count = 10 - iBitNum;
                        if (count < 0) // an 11/12-bit? code - that doesn't fit our optimized scheme, see if we can do a bigger table version
                        {
                            if (count == -1 && iTablesUsed <= 4) // we need to create "slow" tables
                            {
                                j = JPEGMakeHuffTables_Slow(pJPEG, bThumbnail);
//                                pJPEG->huffacFast[1] = (int *) &pJPEG->ucAltHuff[0x0000];
//                                pJPEG->huffacFast[2] = (int *) &pJPEG->ucAltHuff[0x4000];
//                                pJPEG->huffacFast[3] = (int *) &pJPEG->ucAltHuff[0x8000];
                                return j;
                            }
                            else
                                return -1; // DEBUG - fatal error, more than 2 big tables we currently don't support
                        }
                        codestart = cc << count;
                        pTable = &pShort[codestart]; // 10 bits or shorter
                    }
                    code = *p++;  // get actual huffman code
                    if (bThumbnail && code != 0) // add "extra" bits to code length since we skip these codes
                    {
                        // get rid of extra bits in code and add increment (1) for AC index
                        code = ((iBitNum+(code & 0xf)) << 8) | ((code >> 4)+1);
                    }
#ifdef BOGUS // precalculating the AC coeff makes it run slightly slower
                    else if ((code & 0xf) != 0 && (code + iBitNum) <= 10) // we can fit the magnitude value + huffman code in a single read
                    {
                        int k, iLoop;
                        unsigned short usCoeff;
                        unsigned short *d = &pTable[4096]; // use unused table slots 2+3 for extra coeff data
                        unsigned char ucMag = (unsigned char)(code & 0xf);
                        code |= ((iBitNum + (code & 0xf)) << 8); // add magnitude bits to length
                        repeat = 1<<ucMag;
                        iLoop = 1<<(count-ucMag);
                        for (j=0; j<repeat; j++)
                        { // calcuate the magnitude coeff already
                            if (j & 1<<(ucMag-1)) // positive number
                                usCoeff = (unsigned short)j;
                            else // negative number
                                usCoeff = (unsigned short)(j - ((1<<ucMag)-1));
                            for (k=0; k<iLoop; k++)
                            {
                                *d++ = usCoeff;
                            } // for k
                        } // for j
                    }
#endif
                    else
                    {
                        code |= (iBitNum << 8);
                    }
                    if (count) // do it as dwords to save time
                    {
                        repeat = 1 << (count-1); // store as dwords (/2)
                        ul = code | (code << 16);
                        pLongTable = (uint32_t *)pTable;
                        for (j=0; j<repeat; j++)
                            *pLongTable++ = ul;
                    }
                    else
                    {
                        pTable[0] = (unsigned short)code;
                    }
                    cc++;
                    iLen--;
                }
                cc <<= 1;
            } // for each bit length
        } // if table defined
    }
    return 0;
} /* JPEGMakeHuffTables() */

#ifdef JPEG_PROGRESSIVE
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGFilter(PIL_PAGE *, int, JPEGDATA *)                    *
 *                                                                          *
 *  PURPOSE    : Filter annoying 0 & marker bytes from the data stream.     *
 *                                                                          *
 ****************************************************************************/
int JPEGFilter(PIL_PAGE *inpage, int iOffset, JPEGDATA *pJPEG)
{
    // since we have the entire jpeg buffer in memory already, we can just change it in place
    unsigned char *pBuf;
    int iTotal;
    unsigned char *s, *d;
    unsigned char c;
    int iTemp, iOff;
    signed int iLen = inpage->iDataSize - iOffset;
    unsigned short sLen;
    
    iOff = inpage->iOffset + iOffset;
    s = inpage->pData; // point to source data
    pBuf = d = (unsigned char *)PILIOAlloc(inpage->iDataSize + 1024); // leave some breathing room for bad files
    if (pBuf == NULL)
        return PIL_ERROR_MEMORY;
    iTotal = 0;
    while (iTotal < iLen)
	   {
//           if (iOff > PIL_BUFFER_HIGHWATER && inpage->cState != PIL_PAGE_STATE_LOADED)
//               PILReadBlock(inpage, &iOff); // read another block of data
           c = *d++ = s[iOff++];
           iTotal++;
           if (c == 0xff) // marker or stuffed zeros?
           {
               if (s[iOff] != 0) // it's a marker, skip both
               {
                   d--;
                   if (s[iOff] == 0xc4) // Huffman table (comes before the SOS)
                   {
                       if (pJPEG->iHuffOffset[pJPEG->iScan] == 0) // first huff table
                           pJPEG->iHuffOffset[pJPEG->iScan] = (int)(intptr_t)(d - pBuf);
                       else // combine multiple Huffman tables into one big one for easier decode
                       {
                           iTemp = pJPEG->iHuffOffset[pJPEG->iScan];
                           sLen = MOTOSHORT(&pBuf[iTemp]); // get the original length
                           sLen += MOTOSHORT(&s[iOff+1]); // add the new table length
                           iOff += 2; // don't write the extra length to the output
                           iTotal += 2;
                           pBuf[iTemp] = (sLen >> 8);
                           pBuf[iTemp+1] = (sLen & 0xff); // store back the new length
                       }
                   }
                   else if (s[iOff] == 0xda) // SOS - start of scan
                   {
                       pJPEG->iScanOffset[pJPEG->iScan] = (int)(intptr_t)(d - pBuf);
                       pJPEG->iScan++;
                       pJPEG->iHuffOffset[pJPEG->iScan] = 0; // assume no Huff table for this scan
                   }
               }
               iOff++; // for stuffed 0's, store the FF, skip the 00
               iTotal++;
           }
       }
    
    inpage->iDataSize = (int)(d-pBuf);
    
    inpage->cState = PIL_PAGE_STATE_LOADED; // now we have the data in a freeable buffer
    PILIOFree(s); // free the temp buffer
    inpage->pData = pBuf; // use the new buffer
    
    return 0;
    
} /* JPEGFilter() */
#endif // JPEG_PROGRESSIVE

/***************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGMapMCU(char *, JPEGDATA *, int *)                      *
 *                                                                          *
 *  PURPOSE    : Decode an MCU just to get the DC value.                    *
 *                                                                          *
 ****************************************************************************/
int JPEGMapMCU(BUFFERED_BITS *bb, JPEGDATA *pJPEG, int iDCPredictor)
{
    BIGUINT ulCode, ulTemp, ulBits;
    int iIndex;
    unsigned int iBitOff;
    signed char cCoeff;
    unsigned short *pFast;
    unsigned char ucHuff, *pucFast, *pBuf;
    uint32_t usHuff; // this prevents an unnecessary & 65535 for shorts
    //static int iShort = 0;
    //static int iLong = 0;
    
    //#ifdef _X64
    //if (pJPEG->b11Bit == 0)
    //return X64MAPMCU(bb, pJPEG, iDCPredictor);
    //#endif
    
    iBitOff = (unsigned int)bb->ulBitOff;
    //	ulBits = bb->ulBits;
    pBuf = bb->pBuf;
    
    //   if (iBitOff > (REGISTER_WIDTH-32)) // need to get more data
    {
        pBuf += (iBitOff >> 3);
        iBitOff &= 7;
#ifdef _64BITS
        ulBits = MOTOEXTRALONG(pBuf);
#else
        ulBits = MOTOLONG(pBuf);
#endif
    }
    
    // get the DC component
    pucFast = (unsigned char *)pJPEG->pHuffDCFast;
    ulCode = ulBits << iBitOff;
    ulCode >>= (REGISTER_WIDTH - 12); // get as lower 12 bits
    //   ulCode = (ulBits >> (REGISTER_WIDTH - 12 - iBitOff)) & 0xfff; // get as lower 12 bits
    if (ulCode >= 0xf80) // it's a long code
        ulCode = (ulCode & 0xff); // point to long table and trim to 7-bits + 0x80 offset into long table
    else
        ulCode >>= 6; // it's a short code, use first 6 bits only
    ucHuff = pucFast[ulCode];
    cCoeff = (signed char)pucFast[ulCode+512];
    if (ucHuff == 0) // invalid code
        return PIL_STD_ERROR;
    iBitOff += (ucHuff >> 4); // add the Huffman length
    ucHuff &= 0xf; // get the actual code (SSSS)
    if (ucHuff) // if there is a change to the DC value
    { // get the 'extra' bits
        if (iBitOff > (REGISTER_WIDTH - 32)) // need to get more data
        {
            pBuf += (iBitOff >> 3);
            iBitOff &= 7;
#ifdef _64BITS
            ulBits = MOTOEXTRALONG(pBuf);
#else
            ulBits = MOTOLONG(pBuf);
#endif
        }
        if (cCoeff)
        {
            iDCPredictor += cCoeff;
        }
        else
        {
            ulCode = ulBits << iBitOff;
            ulTemp = ~(BIGUINT) (((BIGINT) ulCode) >> (REGISTER_WIDTH-1)); // slide sign bit across other 63 bits
            ulCode >>= (REGISTER_WIDTH - ucHuff);
            ulCode -= ulTemp>>(REGISTER_WIDTH-ucHuff);
            iBitOff += ucHuff; // add bit length
            iDCPredictor += (int)ulCode;
        }
	   }
    pFast = (unsigned short *)pJPEG->pHuffACFast;
    iIndex = 1;
    if (pJPEG->b11Bit) // 11-bit "slow" tables used
    {
//        if (pJPEG->pHuffACFast == pJPEG->huffacFast[1]) // second table
//            pFast = (unsigned short *)&pJPEG->ucAltHuff[0];
#ifndef _64BITS
        pBuf += (iBitOff >> 3); // may need more bits here
        iBitOff &= 7;
        ulBits = MOTOLONG(pBuf);
#endif // !_64BITS
        while (iIndex < 64)
        {
            if (iBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (iBitOff >> 3);
                iBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            //	  ulCode = (ulBits >> (REGISTER_WIDTH - 16 - iBitOff)) & 0xffff; // get as lower 16 bits
            ulCode = ulBits << iBitOff;
            ulCode >>= (REGISTER_WIDTH - 16);
            if (ulCode >= 0xf000) // first 4 bits = 1, use long table
                ulCode = (ulCode & 0x1fff);
            else
                ulCode >>= 4; // use lower 12 bits (short table)
            usHuff = pFast[ulCode];
            if (usHuff == 0) // invalid code
                return PIL_STD_ERROR;
            iBitOff += (usHuff >> 8); // add length
            usHuff &= 0xff; // get code (RRRR/SSSS)
            if (usHuff == 0) // no more AC components
            {
                goto mcu_done;
            }
            if (iBitOff > (REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (iBitOff >> 3);
                iBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            iIndex += (usHuff >> 4) + 1;  // get the skip amount (RRRR)
            usHuff &= 0xf; // get (SSSS) - extra length
            iBitOff += usHuff; // add (SSSS) extra length
        } // while
    }
    else // 10-bit "fast" tables used
    {
#ifndef _64BITS
        pBuf += (iBitOff >> 3); // may need more bits here
        iBitOff &= 7;
        ulBits = MOTOLONG(pBuf);
#endif // !_64BITS
        while (iIndex < 64)
        {
            ulCode = ulBits << iBitOff;
            ulCode >>= (REGISTER_WIDTH - 16);
            if (ulCode >= 0xfc00) // first 6 bits = 1, use long table
            {
                ulCode = (ulCode & 0x7ff); // (ulCode & 0x3ff) + 0x400;
            }
            else
            {
                ulCode >>= 6; // use lower 10 bits (short table)
            }
            usHuff = pFast[ulCode];
            if (iBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (iBitOff >> 3);
                iBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            if (usHuff == 0) // invalid code
                return PIL_STD_ERROR;
            iBitOff += (usHuff >> 8); // add length
            usHuff &= 0xff; // get code (RRRR/SSSS)
            if (usHuff == 0) // no more AC components
            {
                goto mcu_done;
            }
            iIndex += (usHuff >> 4) + 1;  // get the skip amount (RRRR)
            usHuff &= 0xf; // get (SSSS) - extra length
            iBitOff += usHuff; // add (SSSS) extra length
            if (iBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (iBitOff >> 3);
                iBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
        } // while
    } // 10-bit tables
mcu_done:
    //   bb->ulBits = ulBits;
    bb->ulBitOff = iBitOff;
    bb->pBuf = pBuf;
    return iDCPredictor;
    
} /* JPEGMapMCU() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGFilter(PIL_PAGE *, int)                                *
 *                                                                          *
 *  PURPOSE    : Filter stuffed 0s & marker bytes from the data stream.     *
 *                                                                          *
 ****************************************************************************/
void JPEGFilter(PIL_PAGE *inpage, int iLen)
{
    unsigned char *pBuf;
    unsigned char *s, *d, *pStart, *pEnd;
    unsigned char c;
    
    s = &inpage->ucFileBuf[FILE_BLOCK_SIZE*2]; // point to start of source data
    pEnd = &s[iLen];
    pStart = d = &inpage->ucFileBuf[inpage->iDataSize];

    if (inpage->bIsFF) // the last byte we processed was an FF
    {
      inpage->bIsFF = 0;
      if (s[0] == 0) // stuffed 0, value is really FF
        *d++ = 0xff;
      s++;
    }
    while (s < pEnd)
    {
        c = *s++;
        if (c == 0xff) // marker or stuffed zeros?
        {
            if (s >= pEnd) // need to stop here
            {
              inpage->bIsFF = 1;
              continue;
            }
            while (c == 0xff && s < pEnd)
            {
                c = *s++;
            }
            if (c != 0) // marker, don't store either byte
            {
                continue;
            }
            else
            {
                c = 0xff; // it was a stuffed zero, store the FF
            }
        }
        *d++ = c; // store the FF of a stuffed 0 or the normal data
    }
    inpage->iDataSize += (int)(d - pStart); // save the updated quantity of filtered data available
} /* JPEGFilter() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGFixQuantD(JPEGDATA *)                                  *
 *                                                                          *
 *  PURPOSE    : Fix and reorder the quantization table for faster decoding.*
 *                                                                          *
 ****************************************************************************/
void JPEGFixQuantD(JPEGDATA *pJPEG)
{
    int iTable, iTableOffset;
    signed short sTemp[DCTSIZE2];
    int i;
    unsigned short *p;
    
    for (iTable=0; iTable<pJPEG->ucNumComponents; iTable++)
    {
        iTableOffset = iTable * DCTSIZE2;
        p = &pJPEG->sQuantTable[iTableOffset];
        if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL) // don't need to do the whole table
        {
            p[0] = (unsigned short)((p[0] * iScaleBits[0]) >> 12);
        }
        else
        {
            for (i=0; i<DCTSIZE2; i++)
            {
                sTemp[i] = p[cZigZag[i]];
            }
            memcpy(&pJPEG->sQuantTable[iTableOffset], sTemp, DCTSIZE2*sizeof(short)); // copy back to original spot
            
            // Prescale for DCT multiplication
            p = &pJPEG->sQuantTable[iTableOffset];
            for (i=0; i<DCTSIZE2; i++)
            {
                p[i] = (unsigned short)((p[i] * iScaleBits[i]) >> 12);
            }
        }
    }
} /* JPEGFixQuantD() */

#ifndef JPEG_DECODE_ONLY
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGFixQuantE(JPEGDATA *)                                  *
 *                                                                          *
 *  PURPOSE    : Fix and reorder the quantization table for faster encoding.*
 *                                                                          *
 ****************************************************************************/
void JPEGFixQuantE(JPEGDATA *pJPEG)
{
    int iTable, iTableOffset;
    signed short sTemp[DCTSIZE2];
    int i, iCount;
    signed short *p;
    unsigned short *pus;
    
    if (pJPEG->ucNumComponents == 1)
        iCount = 1;
    else
        iCount = 2;
    
    for (iTable = 0; iTable < iCount; iTable++)
    {
        iTableOffset = iTable * DCTSIZE2;
        p = (signed short *) &pJPEG->sQuantTable[iTableOffset];
        for (i = 0; i < DCTSIZE2; i++)
        {
            sTemp[i] = p[cZigZag[i]];
        }
        memcpy(&pJPEG->sQuantTable[iTableOffset], sTemp, DCTSIZE2*sizeof(short)); // copy back to original spot
        
        // Prescale for DCT multiplication
        p = (signed short *) &pJPEG->sQuantTable[iTableOffset];
        for (i = 0; i < DCTSIZE2; i++)
        {
            p[i] = (short) ((p[i] * iScaleBits[i]) >> 11);
        }
        // Create "inverted" values for quicker multiplication instead of division
        pus = (unsigned short *) &pJPEG->sQuantTable[iTableOffset];
        for (i = 0; i < DCTSIZE2; i++)
        {
            int j;
            if (pus[i] != 0)
                j = 65536 / pus[i];
            else
                j = 0;
            pus[i+256] = (unsigned short)j;
        }
    } // for iTable
} /* JPEGFixQuantE() */
#endif // JPEG_DECODE_ONLY

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGet32Bits(char *, int *)                               *
 *                                                                          *
 *  PURPOSE    : Get 32-bits from the JPEG stream, skipping markers.        *
 *                                                                          *
 ****************************************************************************/
uint32_t JPEGGet32Bits(unsigned char *pBuf, int *iOff)
{
    unsigned char ucByte;
    uint32_t ulBits;
    int iOffset  = *iOff;
    
getabyte:
    ucByte = pBuf[iOffset++]; // byte 0
    if (ucByte == 0xff) // stuffed 0?
    {
        if (pBuf[iOffset] != 0)
        {
            iOffset++; // skip marker
            goto getabyte; // try again
        }
        else
            iOffset++; // skip the stuffed zero
    }
    ulBits  = (uint32_t)(ucByte << 8);
getabyte2:
    ucByte = pBuf[iOffset++]; // byte 1
    ulBits |= ucByte;
    if (ucByte == 0xff) // stuffed 0?
    {
        if (pBuf[iOffset] != 0)
        {
            iOffset++; // skip marker
            goto getabyte2; // try again
        }
        else
            iOffset++; // skip the stuffed zero
    }
    ulBits <<= 8;
getabyte3:
    ucByte = pBuf[iOffset++]; // byte 1
    ulBits |= ucByte;
    if (ucByte == 0xff) // stuffed 0?
    {
        if (pBuf[iOffset] != 0)
        {
            iOffset++; // skip marker
            goto getabyte3; // try again
        }
        else
            iOffset++; // skip the stuffed zero
    }
    ulBits <<= 8;
getabyte4:
    ucByte = pBuf[iOffset++]; // byte 1
    ulBits |= ucByte;
    if (ucByte == 0xff) // stuffed 0?
    {
        if (pBuf[iOffset] != 0)
        {
            iOffset++; // skip marker
            goto getabyte4; // try again
        }
        else
            iOffset++; // skip the stuffed zero
    }
    *iOff = iOffset;
    
    return ulBits;
    
} /* JPEGGet32Bits() */

#ifndef USE_ARM_ASM // use assembly language on ARM devices
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGet16Bits(char *, int *)                               *
 *                                                                          *
 *  PURPOSE    : Get 16-bits from the JPEG stream, skipping markers.        *
 *                                                                          *
 ****************************************************************************/
uint32_t JPEGGet16Bits(unsigned char *pBuf, int *iOff)
{
    uint32_t ucByte1, ucByte2;
    uint32_t ulBits;
    int iOffset  = *iOff;
    
    // Code for most frequent case: both bytes are OK
    
    ucByte1 = pBuf[iOffset]; // need to separate the reads in case of odd address
    ucByte2 = pBuf[iOffset+1];
    if (ucByte1 == 0xff || ucByte2 == 0xff) // one or more markers/stuffed bytes - use slow procedure
    {
    getabyte:
        ucByte1 = pBuf[iOffset++]; // byte 0
        if (ucByte1 == 0xff) // stuffed 0?
        {
            if (pBuf[iOffset] != 0)
            {
                iOffset++; // skip marker
                goto getabyte; // try again
            }
            else
                iOffset++; // skip the stuffed zero
        }
        ulBits = ucByte1 << 8;
    getabyte2:
        ucByte1 = pBuf[iOffset++]; // byte 1
        if (ucByte1 == 0xff) // stuffed 0?
        {
            if (pBuf[iOffset] != 0)
            {
                iOffset++; // skip marker
                goto getabyte2; // try again
            }
            else
                iOffset++; // skip the stuffed zero
        }
        ulBits |= ucByte1;
    }
    else // probable case of 2 good bytes
    {
        iOffset += 2;
        ulBits = (ucByte1 << 8) | ucByte2;
    }
    *iOff = iOffset;
    return ulBits;
    
} /* JPEGGet16Bits() */
#endif

#ifdef BOGUS
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGet24Bits(char *, int *)                               *
 *                                                                          *
 *  PURPOSE    : Get 24-bits from the JPEG stream, skipping markers.        *
 *                                                                          *
 ****************************************************************************/
uint32_t JPEGGet24Bits(unsigned char *pBuf, int *iOff)
{
    unsigned char ucByte;
    uint32_t ulBits;
    int iOffset  = *iOff;
    
getabyte:
    ucByte = pBuf[iOffset++]; // byte 0
    if (ucByte == 0xff) // stuffed 0?
    {
        if (pBuf[iOffset] != 0)
        {
            iOffset++; // skip marker
            goto getabyte; // try again
        }
        else
            iOffset++; // skip the stuffed zero
    }
    ulBits  = (uint32_t)(ucByte << 8);
getabyte2:
    ucByte = pBuf[iOffset++]; // byte 1
    if (ucByte == 0xff) // stuffed 0?
    {
        if (pBuf[iOffset] != 0)
        {
            iOffset++; // skip marker
            goto getabyte2; // try again
        }
        else
            iOffset++; // skip the stuffed zero
    }
    ulBits |= ucByte;
    ulBits <<= 8;
getabyte3:
    ucByte = pBuf[iOffset++]; // byte 1
    if (ucByte == 0xff) // stuffed 0?
    {
        if (pBuf[iOffset] != 0)
        {
            iOffset++; // skip marker
            goto getabyte3; // try again
        }
        else
            iOffset++; // skip the stuffed zero
    }
    
    ulBits |= ucByte;
    *iOff = iOffset;
    return ulBits;
    
} /* JPEGGet24Bits() */

#endif // BOGUS

//
// Read data from a file or memory at a specific offset
// Optionally filter the data for JPEG markers and stuffed 0's
//
int PILReadAtOffset(PIL_PAGE *pp, int iOffset, int iLen, int bFilter)
{
  int iDataRead = 0;
    
  if ((unsigned int)iOffset > (unsigned int)pp->iDataSize || iOffset < 0) // trying to read past the end of the file or into a null pointer
    return 0;
  if (iOffset + iLen > pp->iDataSize)
    iLen = pp->iDataSize - iOffset;
  if (iLen == 0)
     return 0; // can't read anything
     
  if (pp->szFile == NULL) // we have everything in memory
  {
    memcpy(&pp->ucFileBuf[FILE_BLOCK_SIZE*2], &pp->pData[iOffset], iLen); // copy to staging area
    pp->iFilePos = iOffset + iLen;
    iDataRead = iLen;
  }
  else // need to read it from the file
  {
    pp->file.seek(iOffset);
    iDataRead = file.read(&pp->ucFileBuf[FILE_BLOCK_SIZE*2], iLen);
  }
  if (bFilter) // need to remove JPEG markers and stuffed 00's
  {
    // move existing data down to offset 0
    memcpy(pp->ucFileBuf, &pp->ucFileBuf[pp->iDataPos], pp->iDataSize - pp->iDataPos);
    pp->iDataSize -= iDataPos;    
    pp->iDataPos = 0;
    JPEGFilter(pp, iDataRead);
  }
  return iDataRead;
} /* PILReadAtOffset() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGDecodeMCUFast(char *, int *, int *, int *, JPEGDATA *)*
 *                                                                          *
 *  PURPOSE    : Decompress a macro block of JPEG data. Only need DC value  *
 *                                                                          *
 ****************************************************************************/
int JPEGDecodeMCUFast(BUFFERED_BITS *bb, JPEGDATA *pJPEG, int *iDCPredictor)
{
    int iIndex;
    signed char cCoeff;
#ifdef _64BITS
    uint64_t ulTemp, ulCode, ulBits;
#else
    uint32_t ulTemp, ulCode, ulBits;
#endif
    unsigned short *pFast;
    unsigned char *pucFast, ucHuff;
    uint32_t usHuff; // this prevents an unnecessary & 65535 for shorts
    uint32_t ulBitOff;
    unsigned char *pBuf;
    
    //#ifdef USE_ARM_ASM
    //	if (pJPEG->b11Bit == 0)
    //		return ARMDecodeMCUFast(bb, pJPEG, iDCPredictor);
    //#endif
    //#if defined(_X86) && !defined(_X64)
    //	if (pJPEG->b11Bit == 0)
    //		return X86DECODEMCUFAST(bb, pJPEG, iDCPredictor);
    //#endif
    // N.B. The 64-bit compiled code is slightly faster than the hand written ASM code :(
    //#ifdef _X64
    //	if (pJPEG->b11Bit == 0)
    //		return X64DECODEMCUFAST(bb, pJPEG, iDCPredictor);
    //#endif
    
    ulBitOff = (uint32_t)bb->ulBitOff;
    ulBits = bb->ulBits;
    pBuf = bb->pBuf;
    
    if (ulBitOff > (REGISTER_WIDTH-17)) // need to get more data
    {
        pBuf += (ulBitOff >> 3);
        ulBitOff &= 7;
#ifdef _64BITS
        ulBits = MOTOEXTRALONG(pBuf);
#else
        ulBits = MOTOLONG(pBuf);
#endif
    }
    
    // get the DC component
    pucFast = (unsigned char *)pJPEG->pHuffDCFast;
    ulCode = (ulBits >> (REGISTER_WIDTH - 12 - ulBitOff)) & 0xfff; // get as lower 12 bits
    if (ulCode >= 0xf80) // it's a long code
        ulCode = (ulCode & 0xff); // point to long table and trim to 7-bits + 0x80 offset into long table
    else
        ulCode >>= 6; // it's a short code, use first 6 bits only
    ucHuff = pucFast[ulCode]; // get the length+code
    cCoeff = (signed char)pucFast[ulCode+512];
    if (ucHuff == 0) // invalid code
        return PIL_ERROR_DECOMP;
    ulBitOff += (ucHuff >> 4); // add the Huffman length
    ucHuff &= 0xf; // get the actual code (SSSS)
    if (ucHuff) // if there is a change to the DC value
    { // get the 'extra' bits
        if (cCoeff)
        {
            (*iDCPredictor) += cCoeff;
        }
        else
        {
            if (ulBitOff > (REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            ulCode = ulBits << ulBitOff;
#ifdef _64BITS
            ulTemp = ~(((int64_t)ulCode)>>63); // slide sign bit across other 63 bits
#else
            ulTemp = ~(uint32_t)(((int32_t)ulCode)>>31); // slide sign bit across other 31 bits
#endif
            ulCode >>= (REGISTER_WIDTH - ucHuff);
            ulCode -= ulTemp>>(REGISTER_WIDTH-ucHuff);
            ulBitOff += ucHuff; // add bit length
            (*iDCPredictor) += (int)ulCode;
        }
    }
    //   pMCU[iIndex++] = iDCPredictor; // store in MCU[0]
    // Now get the other 63 AC coefficients
    //   p = (unsigned short *)pJPEG->pHuffAC;
    pFast = (unsigned short *)pJPEG->pHuffACFast;
    iIndex = 1;
    if (pJPEG->b11Bit)
    {
//        if (pJPEG->pHuffACFast == pJPEG->huffacFast[1]) // second table
//            pFast = (unsigned short *)&pJPEG->ucAltHuff[0];
        while (iIndex < 64)
        {
            if (ulBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            // most codes are 8 bits or less, so try faster lookup first
            ulCode = (ulBits >> (REGISTER_WIDTH - 16 - ulBitOff)) & 0xffff; // get lower 16 bits
            if (ulCode >= 0xf000) // if first 4 bits are 1, use long table
                ulCode = (ulCode & 0x1fff);
            else
                ulCode >>= 4; // use lower 12 bits for short table
            usHuff = pFast[ulCode]; // faster table can fit entirely on the processor cache
            if (usHuff == 0) // invalid code
                return PIL_ERROR_DECOMP;
            ulBitOff += (usHuff >> 8); // add length (includes extra length)
            usHuff &= 0xff; // get code (RRRR/SSSS)
            if (usHuff == 0) // no more AC components
                goto clean_exit;
            //      if (iBitNum > 15) // need to grab more bytes to nibble on
            //         {
            //         iBitNum -= 16;
            //         ulBits <<= 16;
            //         ulBits |= JPEGGet16Bits(pBuf, iOff);
            //         }
            iIndex += usHuff; // >> 4); // get the skip amount (RRRR)
            //      iBitNum += (usHuff & 0xf); // get (SSSS) extra length
        }
    } // !10-bit Huffman codes
    else // more efficient Huffman decoding with codes that don't exceed 10-bits
    {
        while (iIndex < 64)
        {
            if (ulBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            // most codes are 8 bits or less, so try faster lookup first
            ulCode = (ulBits >> (REGISTER_WIDTH - 16 - ulBitOff)) & 0xffff; // get lower 16 bits
            if (ulCode >= 0xfc00) // if first 6 bits are 1, use long table
                ulCode = (ulCode & 0x7ff); //(ulCode & 0x3ff) + 0x400;
            else
                ulCode >>= 6; // use lower 10 bits for short table
            usHuff = pFast[ulCode]; // faster table can fit entirely on the processor cache
            if (usHuff == 0) // invalid code
                return PIL_ERROR_DECOMP;
            ulBitOff += (usHuff >> 8); // add length (includes extra length)
            usHuff &= 0xff; // get code (RRRR/SSSS)
            if (usHuff == 0) // no more AC components
                goto clean_exit;
            //      if (iBitNum > 15) // need to grab more bytes to nibble on
            //         {
            //         iBitNum -= 16;
            //         ulBits <<= 16;
            //         ulBits |= JPEGGet16Bits(pBuf, iOff);
            //         }
            iIndex += usHuff; // >> 4); // get the skip amount (RRRR)
            //      iBitNum += (usHuff & 0xf); // get (SSSS) extra length
        }
    }
clean_exit:
    bb->pBuf = pBuf;
    bb->ulBitOff = ulBitOff;
    bb->ulBits = ulBits;
    
    return 0;
    
} /* JPEGDecodeMCUFast() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGDecodeMCU(char *, int *, int *, int *, JPEGDATA *)     *
 *                                                                          *
 *  PURPOSE    : Decompress a macro block of JPEG data.                     *
 *                                                                          *
 ****************************************************************************/
int JPEGDecodeMCU(BUFFERED_BITS *bb, signed short *pMCU, JPEGDATA *pJPEG, int *iDCPredictor)
{
#ifdef _64BITS
    uint64_t ulCode, ulTemp;
#else
    uint32_t ulCode, ulTemp;
#endif
    unsigned char *pEnd,*pEnd2,*pZig;
    signed char cCoeff;
    unsigned short *pFast;
    unsigned char ucHuff, *pucFast;
    uint32_t usHuff; // this prevents an unnecessary & 65535 for shorts
    BIGUINT ulBitOff, ulBits; // local copies to allow compiler to use register vars
    unsigned char *pBuf, ucMaxACCol, ucMaxACRow;
    //#ifdef USE_ARM_ASM
    //	if (pJPEG->b11Bit == 0)
    //		return ARMDecodeMCU(bb, pMCU, pJPEG, iDCPredictor);
    //#endif
    //#if defined(_X86) && !defined(_X64)
    //	if (pJPEG->b11Bit == 0)
    //		return X86DECODEMCU(bb, pMCU, pJPEG, iDCPredictor);
    //#endif
    //#ifdef _X64
    //	if (pJPEG->b11Bit == 0)
    //		return X64DECODEMCU(bb, pMCU, pJPEG, iDCPredictor);
    //#endif
    
    ulBitOff = bb->ulBitOff;
    ulBits = bb->ulBits;
    pBuf = bb->pBuf;
    ucMaxACCol = ucMaxACRow = 0;
    
    if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE) // reduced size DCT
    {
        pMCU[1] = pMCU[8] = pMCU[9] = 0;
        pEnd2 = (unsigned char *)&cZigZag2[5]; // we only need to store the 4 elements we care about
    }
    else
    {
#ifdef _64BITS
        uint64_t *p = (uint64_t *)pMCU;
        *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
        *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0; *p++ = 0;
#else
        memset(pMCU, 0, 64*sizeof(short)); // pre-fill with zero since we may skip coefficients
#endif
        pEnd2 = (unsigned char *)&cZigZag2[64];
    }
    pZig = (unsigned char *)&cZigZag2[1];
    pEnd = (unsigned char *)&cZigZag2[64];
    
    if (ulBitOff > (REGISTER_WIDTH-17)) // need to get more data
    {
        pBuf += (ulBitOff >> 3);
        ulBitOff &= 7;
#ifdef _64BITS
        ulBits = MOTOEXTRALONG(pBuf);
#else
        ulBits = MOTOLONG(pBuf);
#endif
    }
    
    // get the DC component
    pucFast = (unsigned char *)pJPEG->pHuffDCFast;
    ulCode = (ulBits >> (REGISTER_WIDTH - 12 - ulBitOff)) & 0xfff; // get as lower 12 bits
    if (ulCode >= 0xf80) // it's a long code
        ulCode = (ulCode & 0xff); // point to long table and trim to 7-bits + 0x80 offset into long table
    else
        ulCode >>= 6; // it's a short code, use first 6 bits only
    ucHuff = pucFast[ulCode];
    cCoeff = (signed char)pucFast[ulCode+512];
    if (ucHuff == 0) // invalid code
        return PIL_ERROR_DECOMP;
    ulBitOff += (ucHuff >> 4); // add the Huffman length
    ucHuff &= 0xf; // get the actual code (SSSS)
    if (ucHuff) // if there is a change to the DC value
    { // get the 'extra' bits
        if (cCoeff)
        {
            (*iDCPredictor) += cCoeff;
        }
        else
        {
            if (ulBitOff > (REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            ulCode = ulBits << ulBitOff;
#ifdef _64BITS
            ulTemp = ~(uint64_t) (((int64_t) ulCode) >> 63); // slide sign bit across other 63 bits
#else
            ulTemp = ~(uint32_t)(((int32_t)ulCode)>>31); // slide sign bit across other 31 bits
#endif
            ulCode >>= (REGISTER_WIDTH - ucHuff);
            ulCode -= ulTemp>>(REGISTER_WIDTH-ucHuff);
            ulBitOff += ucHuff; // add bit length
            (*iDCPredictor) += (int)ulCode;
        }
	   }
    pMCU[0] = (short)*iDCPredictor; // store in MCU[0]
    // Now get the other 63 AC coefficients
    //   p = (unsigned short *)pJPEG->pHuffAC;
    pFast = (unsigned short *)pJPEG->pHuffACFast;
    if (pJPEG->b11Bit) // 11-bit "slow" tables used
    {
//        if (pJPEG->pHuffACFast == pJPEG->huffacFast[1]) // second table
//            pFast = (unsigned short *)&pJPEG->ucAltHuff[0];
        while (pZig < pEnd)
        {
            if (ulBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            ulCode = (ulBits >> (REGISTER_WIDTH - 16 - ulBitOff)) & 0xffff; // get as lower 16 bits
            if (ulCode >= 0xf000) // first 4 bits = 1, use long table
                ulCode = (ulCode & 0x1fff);
            else
                ulCode >>= 4; // use lower 12 bits (short table)
            usHuff = pFast[ulCode];
            if (usHuff == 0) // invalid code
                return PIL_ERROR_DECOMP;
            ulBitOff += (usHuff >> 8); // add length
            usHuff &= 0xff; // get code (RRRR/SSSS)
            if (usHuff == 0) // no more AC components
            {
                goto mcu_done;
            }
            if (ulBitOff > (REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            pZig += (usHuff >> 4);  // get the skip amount (RRRR)
            usHuff &= 0xf; // get (SSSS) - extra length
            if (pZig < pEnd2 && usHuff)
            {
                ulCode = ulBits << ulBitOff;
#ifdef _64BITS
                ulTemp = ~(uint64_t) (((int64_t) ulCode) >> 63); // slide sign bit across other 63 bits
#else
                ulTemp = ~(uint32_t) (((int32_t) ulCode) >> 31); // slide sign bit across other 31 bits
#endif
                ulCode >>= (REGISTER_WIDTH - usHuff);
                ulCode -= ulTemp>>(REGISTER_WIDTH-usHuff);
                ucMaxACCol |= 1<<(*pZig & 7); // keep track of occupied columns
                if (*pZig >= 0x20) // if more than 4 rows used in a col, mark it
                    ucMaxACRow |= 1<<(*pZig & 7); // keep track of the max AC term row
                pMCU[*pZig] = (signed short)ulCode; // store AC coefficient (already reordered)
            }
            ulBitOff += usHuff; // add (SSSS) extra length
            pZig++;
        } // while
    }
    else // 10-bit "fast" tables used
    {
        while (pZig < pEnd)
        {
            if (ulBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            ulCode = (ulBits >> (REGISTER_WIDTH - 16 - ulBitOff)) & 0xffff; // get as lower 16 bits
            if (ulCode >= 0xfc00) // first 6 bits = 1, use long table
                ulCode = (ulCode & 0x7ff); // (ulCode & 0x3ff) + 0x400;
            else
                ulCode >>= 6; // use lower 10 bits (short table)
            usHuff = pFast[ulCode];
            if (usHuff == 0) // invalid code
                return PIL_ERROR_DECOMP;
            ulBitOff += (usHuff >> 8); // add length
            usHuff &= 0xff; // get code (RRRR/SSSS)
            if (usHuff == 0) // no more AC components
            {
                goto mcu_done;
            }
            if (ulBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            pZig += (usHuff >> 4);  // get the skip amount (RRRR)
            usHuff &= 0xf; // get (SSSS) - extra length
            if (pZig < pEnd2 && usHuff)
            {
                ulCode = ulBits << ulBitOff;
                ulTemp = ~(BIGUINT) (((BIGINT) ulCode) >> (REGISTER_WIDTH-1)); // slide sign bit across other 63 bits
                ulCode >>= (REGISTER_WIDTH - usHuff);
                ulCode -= ulTemp >> (REGISTER_WIDTH - usHuff);
                //         ucMaxACCol |= 1<<(*pZig & 7); // keep track of occupied columns
                //         if (*pZig >= 0x20) // if more than 4 rows used in a col, mark it
                //            ucMaxACRow |= 1<<(*pZig & 7); // keep track of the max AC term row
                pMCU[*pZig] = (signed short)ulCode; // store AC coefficient (already reordered)
            }
            ulBitOff += usHuff; // add (SSSS) extra length
            pZig++;
        } // while
    } // 10-bit tables
mcu_done:
    pJPEG->ucMaxACCol = 0xff;// ucMaxACCol; // store updated structure values
    pJPEG->ucMaxACRow = 0xff; // ucMaxACRow;
    bb->pBuf = pBuf;
    bb->ulBitOff = ulBitOff;
    bb->ulBits = ulBits;
    return 0;
    
} /* JPEGDecodeMCU() */

#ifdef JPEG_PROGRESSIVE
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGDecodeMCU_P(char *, int *, int *, int *, JPEGDATA *)   *
 *                                                                          *
 *  PURPOSE    : Decompress a macro block of Progressive JPEG data.         *
 *                                                                          *
 ****************************************************************************/
int JPEGDecodeMCU_P(unsigned char *pBuf, int *iOff, int *iBit, signed short *pMCU, JPEGDATA *pJPEG, int *iDCPredictor, int *iSkip)
{
    int iOffset, iBitNum, iCount;
    int iIndex;
    uint32_t ulCode, ulBits;
    unsigned char ucHuff, *pFastDC;
    unsigned short *pFast;
    uint32_t usHuff; // this prevents an unnecessary & 65535 for shorts
    signed int iPositive, iNegative, iCoeff;
    
    iOffset = *iOff;
    iBitNum = *iBit;
    
    iPositive = (1 << pJPEG->cApproxBitsLow); // positive bit position being coded
    iNegative = ((-1) << pJPEG->cApproxBitsLow); // negative bit position being coded
    
    ulBits = MOTOLONG(&pBuf[iOffset]); // get 32 bits to nibble on
    
    if (pJPEG->iScanStart == 0)
    {
        if (pJPEG->cApproxBitsHigh) // successive approximation - simply encodes the specified bit
        {
            ulCode = (ulBits >> (31-iBitNum)) & 1; // just get 1 bit
            iBitNum += 1;
            if (ulCode)
            {
                //            (*iDCPredictor) |= iPositive;  // in case the scan is run more than once
                //            pMCU[0] = *iDCPredictor; // store in MCU[0]
                pMCU[0] |= iPositive;
            }
            goto mcu_done; // that's it
        }
        // get the DC component
        ulCode = (ulBits >> (32 - 12 - iBitNum)) & 0xfff; // get as lower 12 bits
        if (ulCode >= 0xf80) // long code
            ulCode = (ulCode & 0xff); // point to long table
        else
            ulCode >>= 6; // use first 6 bits of short code
        pFastDC = (unsigned char *)pJPEG->pHuffDCFast;
        ucHuff = pFastDC[ulCode]; // get the length+code
        if (ucHuff == 0) // invalid code
            return PIL_ERROR_DECOMP;
        iBitNum += (ucHuff >> 4); // add the Huffman length
        ucHuff &= 0xf; // get the actual code (SSSS)
        if (ucHuff) // if there is a change to the DC value
        { // get the 'extra' bits
            if (iBitNum > 15) // need to grab more bytes to nibble on
            {
                iOffset += 2; // grab 2 more bytes since that's what we really need
                iBitNum -= 16;
                ulBits <<= 16;
                ulBits |= MOTOSHORT(&pBuf[iOffset+2]);
            }
            ulCode = ulBits << iBitNum;
            ulCode >>= (32 - ucHuff);
            if (!(ulCode & 0x80000000>>(32-ucHuff))) // test for negative
                ulCode -= 0xffffffff>>(32-ucHuff);
            iBitNum += ucHuff; // add bit length
            ulCode <<= pJPEG->cApproxBitsLow; // successive approximation shift value
            (*iDCPredictor) += ulCode;
        }
        pMCU[0] = (short)*iDCPredictor; // store in MCU[0]
    }
    // Now get the other 63 AC coefficients
    pFast = (unsigned short *)pJPEG->pHuffACFast;
    if (pJPEG->iScanStart)
        iIndex = pJPEG->iScanStart; // starting index of this scan (progressive JPEG)
    else
        iIndex = 1; // special case when the DC component is included
    if (pJPEG->cApproxBitsHigh) // successive approximation - different method
    {
        if (*iSkip == 0) // only decode this block if not being skipped in EOB run
        {
            for (; iIndex <= pJPEG->iScanEnd; iIndex++)
            {
                if (iBitNum > 15) // need to grab more bytes to nibble on
                {
                    iOffset += 2; // grab 2 more bytes since that's what we really need
                    iBitNum -= 16;
                    ulBits <<= 16;
                    ulBits |= MOTOSHORT(&pBuf[iOffset+2]);
                }
                ulCode = (ulBits >> (16 - iBitNum)) & 0xffff; // get as lower 16 bits
                if (ulCode >= 0xf000) // first 4 bits = 1, use long table
                    ulCode = (ulCode & 0x1fff);
                else
                    ulCode >>= 4; // use lower 12 bits (short table)
                usHuff = pFast[ulCode];
                if (usHuff == 0) // invalid code
                    return PIL_ERROR_DECOMP;
                iBitNum += (usHuff >> 8); // add length
                usHuff &= 0xff; // get code (RRRR/SSSS)
                iCoeff = 0;
                if (usHuff & 0xf)
                {
                    if ((usHuff & 0xf) != 1)   // size of new coefficient should always be one
                        return PIL_ERROR_DECOMP;
                    ulCode = (ulBits >> (31-iBitNum)) & 1; // just get 1 bit
                    iBitNum += 1;
                    if (ulCode) // 1 means use positive value; 0 = use negative
                        iCoeff = iPositive;
                    else
                        iCoeff = iNegative;
                }
                else // since SSSS = 0, must be a ZRL or EOBn code
                {
                    if (usHuff != 0xf0) // ZRL
                    { // EOBn code
                        usHuff = (usHuff >> 4); // get the number of extra bits needed to code the count
                        ulCode = ulBits >> (32 - usHuff - iBitNum); // shift down by (SSSS) - extra length
                        ulCode &= iBitMasks[usHuff];
                        ulCode += (1 << usHuff); // plus base amount
                        iBitNum += usHuff; // add extra length
                        *iSkip = ulCode; // return this skip amount
                        break;
                    }
                }
                // Advance over already-nonzero coefficients and RRRR still-zero coefficients
                // appending correction bits to the nonzeroes.  A correction bit is 1 if the abs
                // value of the coefficient must be increased.
                iCount = (usHuff >> 4); // get RRRR in lower 4 bits
                do {
                    if (pMCU[iIndex])
                    {
                        if (iBitNum > 15) // need to grab more bytes to nibble on
                        {
                            iOffset += 2; // grab 2 more bytes since that's what we really need
                            iBitNum -= 16;
                            ulBits <<= 16;
                            ulBits |= MOTOSHORT(&pBuf[iOffset+2]);
                        }
                        ulCode = (ulBits >> (31-iBitNum)) & 1; // just get 1 bit
                        iBitNum++;
                        if (ulCode)
                        {
                            if ((pMCU[iIndex] & iPositive) == 0) // only combine if not already done
                            {
                                if (pMCU[iIndex] >= 0)
                                    pMCU[iIndex] += (short)iPositive;
                                else
                                    pMCU[iIndex] += (short)iNegative;
                            }
                        }
                    }
                    else // count the zero coeffs to skip
                    {
                        if (--iCount < 0)
                            break;      // done skipping zeros
                    }
                    iIndex++;
                } while (iIndex <= pJPEG->iScanEnd);
                if (iCoeff && iIndex < 0x40) // store the non-zero coefficient
                    pMCU[iIndex] = (short) iCoeff;
            } // for - AC coeffs
        } // if not skipped
        if (*iSkip) // scan any remaining coefficient positions after the end-of-band
        {
            for (; iIndex <= pJPEG->iScanEnd; iIndex++)
            {
                if (pMCU[iIndex]) // only non-zero ones need correction
                {
                    if (iBitNum > 15) // need to grab more bytes to nibble on
                    {
                        iOffset += 2; // grab 2 more bytes since that's what we really need
                        iBitNum -= 16;
                        ulBits <<= 16;
                        ulBits |= MOTOSHORT(&pBuf[iOffset+2]);
                    }
                    ulCode = ulBits >> (31 - iBitNum); // get 1 bit
                    iBitNum++;
                    if (ulCode & 1)   // correction bit
                    {
                        if ((pMCU[iIndex] & iPositive) == 0) // only combine if not already done
                        {
                            if (pMCU[iIndex] >= 0)
                                pMCU[iIndex] += (short)iPositive;
                            else
                                pMCU[iIndex] += (short)iNegative;
                        }
                    }  // if correction bit
                }  // if coeff is non-zero
            } // for the rest of the AC coefficients
            (*iSkip)--; // count this block as completed
        }  // if this block is being skipped
    } // if successive approx
    else // normal AC decoding
    {
        if (*iSkip == 0) // if this block is not being skipped in a EOB run
        {
            while (iIndex <= pJPEG->iScanEnd)
            {
                if (iBitNum > 15) // need to grab more bytes to nibble on
                {
                    iOffset += 2; // grab 2 more bytes since that's what we really need
                    iBitNum -= 16;
                    ulBits <<= 16;
                    ulBits |= MOTOSHORT(&pBuf[iOffset+2]);
                }
                ulCode = (ulBits >> (16 - iBitNum)) & 0xffff; // get as lower 16 bits
                if (ulCode >= 0xf000) // first 4 bits = 1, use long table
                    ulCode = (ulCode & 0x1fff);
                else
                    ulCode >>= 4; // use lower 12 bits (short table)
                usHuff = pFast[ulCode];
                if (usHuff == 0) // invalid code
                    return PIL_ERROR_DECOMP;
                iBitNum += (usHuff >> 8); // add length
                usHuff &= 0xff; // get code (RRRR/SSSS)
                //            if (usHuff == 0) // no more AC components
                //               {
                //               goto mcu_done;
                //               }
                if (usHuff == 0xf0) // is it ZRL?
                {
                    iIndex += 16; // skip 16 AC coefficients
                }
                else
                {
                    if (iBitNum > 15)
                    {
                        iOffset += 2; // grab 2 more bytes since that's what we really need
                        iBitNum -= 16;
                        ulBits <<= 16;
                        ulBits |= MOTOSHORT(&pBuf[iOffset+2]);
                    }
                    if ((usHuff & 0xf) == 0) // special case for encoding EOB (end-of-band) codes (SSSS=0)
                    {
                        usHuff = (usHuff >> 4); // get the number of extra bits needed to code the count
                        ulCode = ulBits >> (32 - usHuff - iBitNum); // shift down by (SSSS) - extra length
                        ulCode &= iBitMasks[usHuff];
                        ulCode += (1 << usHuff); // plus base amount
                        iBitNum += usHuff; // add extra length
                        *iSkip = ulCode; // return this skip amount
                        break;
                    }
                    else
                    {
                        iIndex += (usHuff >> 4); // skip amount
                        usHuff &= 0xf; // get (SSSS) - extra length
                        ulCode = ulBits << iBitNum;
                        ulCode >>= (32 - usHuff);
                        if (!(ulCode & 0x80000000>>(32-usHuff))) // test for negative
                            ulCode -= 0xffffffff>>(32-usHuff);
                        iBitNum += usHuff; // add (SSSS) extra length
                        ulCode <<= pJPEG->cApproxBitsLow; // successive approximation shift value
                        pMCU[iIndex++] = (signed short)ulCode; // store AC coefficient
                    }
                }
            } // while
        } // if this block not skipped
        if (*iSkip)
            (*iSkip)--; // count this block as being completed (or skipped)
    } // end of non-successive approx code
mcu_done:
    iOffset += iBitNum >> 3;
    iBitNum &= 7;
    *iOff = iOffset;
    *iBit = iBitNum;
    return 0;
    
} /* JPEGDecodeMCU_P() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGFixOrder(int *)                                        *
 *                                                                          *
 *  PURPOSE    : Reorder the zig-zag MCU coefficients into normal order.    *
 *               Only needed for progressive decoding.                      *
 *                                                                          *
 ****************************************************************************/
void JPEGFixOrder(signed short *pMCU, signed short *pDestMCU)
{
#ifdef BOGUS
    int i;
    
    for (i=0; i<DCTSIZE2; i++)
    {
        pDestMCU[i] = pMCU[cZigZag[i]];
    }
#else
    // Faster method uses brute force transfers instead of expensive table lookups and loops
    // On the Dell Axim X30H, this new method makes a 4 Megapixel image load 7% faster
    
    *pDestMCU++ = pMCU[0];    *pDestMCU++ = pMCU[1];
    *pDestMCU++ = pMCU[5];    *pDestMCU++ = pMCU[6];
    *pDestMCU++ = pMCU[14];    *pDestMCU++ = pMCU[15];
    *pDestMCU++ = pMCU[27];    *pDestMCU++ = pMCU[28];
    *pDestMCU++ = pMCU[2];    *pDestMCU++ = pMCU[4];
    *pDestMCU++ = pMCU[7];    *pDestMCU++ = pMCU[13];
    *pDestMCU++ = pMCU[16];    *pDestMCU++ = pMCU[26];
    *pDestMCU++ = pMCU[29];    *pDestMCU++ = pMCU[42];
    *pDestMCU++ = pMCU[3];    *pDestMCU++ = pMCU[8];
    *pDestMCU++ = pMCU[12];    *pDestMCU++ = pMCU[17];
    *pDestMCU++ = pMCU[25];    *pDestMCU++ = pMCU[30];
    *pDestMCU++ = pMCU[41];    *pDestMCU++ = pMCU[43];
    *pDestMCU++ = pMCU[9];    *pDestMCU++ = pMCU[11];
    *pDestMCU++ = pMCU[18];    *pDestMCU++ = pMCU[24];
    *pDestMCU++ = pMCU[31];    *pDestMCU++ = pMCU[40];
    *pDestMCU++ = pMCU[44];    *pDestMCU++ = pMCU[53];
    *pDestMCU++ = pMCU[10];    *pDestMCU++ = pMCU[19];
    *pDestMCU++ = pMCU[23];    *pDestMCU++ = pMCU[32];
    *pDestMCU++ = pMCU[39];    *pDestMCU++ = pMCU[45];
    *pDestMCU++ = pMCU[52];    *pDestMCU++ = pMCU[54];
    *pDestMCU++ = pMCU[20];    *pDestMCU++ = pMCU[22];
    *pDestMCU++ = pMCU[33];    *pDestMCU++ = pMCU[38];
    *pDestMCU++ = pMCU[46];    *pDestMCU++ = pMCU[51];
    *pDestMCU++ = pMCU[55];    *pDestMCU++ = pMCU[60];
    *pDestMCU++ = pMCU[21];    *pDestMCU++ = pMCU[34];
    *pDestMCU++ = pMCU[37];    *pDestMCU++ = pMCU[47];
    *pDestMCU++ = pMCU[50];    *pDestMCU++ = pMCU[56];
    *pDestMCU++ = pMCU[59];    *pDestMCU++ = pMCU[61];
    *pDestMCU++ = pMCU[35];    *pDestMCU++ = pMCU[36];
    *pDestMCU++ = pMCU[48];    *pDestMCU++ = pMCU[49];
    *pDestMCU++ = pMCU[57];    *pDestMCU++ = pMCU[58];
    *pDestMCU++ = pMCU[62];    *pDestMCU++ = pMCU[63];
    
#endif
} /* JPEGFixOrder() */
#endif // JPEG_PROGRESSIVE

#ifndef JPEG_DECODE_ONLY
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGFDCT(signed short *)                                   *
 *                                                                          *
 *  PURPOSE    : Perform forward discrete cosine transform on macro block.  *
 *                                                                          *
 ****************************************************************************/
void JPEGFDCT(signed short *pMCUSrc)
{
    int iCol;
    int iRow;
    signed int tmp0,tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7,tmp10,tmp11,tmp12,tmp13;
    signed int z1,z2,z3,z4,z5,z11,z13;
    
    // do rows first
    for (iRow=0; iRow<64; iRow+=8)
    {
        tmp0 = pMCUSrc[iRow+0] + pMCUSrc[iRow+7];
        tmp7 = pMCUSrc[iRow+0] - pMCUSrc[iRow+7];
        tmp1 = pMCUSrc[iRow+1] + pMCUSrc[iRow+6];
        tmp6 = pMCUSrc[iRow+1] - pMCUSrc[iRow+6];
        tmp2 = pMCUSrc[iRow+2] + pMCUSrc[iRow+5];
        tmp5 = pMCUSrc[iRow+2] - pMCUSrc[iRow+5];
        tmp3 = pMCUSrc[iRow+3] + pMCUSrc[iRow+4];
        tmp4 = pMCUSrc[iRow+3] - pMCUSrc[iRow+4];
        // even part
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
        tmp11 = tmp1 + tmp2;
        tmp12 = tmp1 - tmp2;
        pMCUSrc[iRow+0] = (short)(tmp10 + tmp11);
        pMCUSrc[iRow+4] = (short)(tmp10 - tmp11);
        z1 = (((tmp12 + tmp13) * 181) >> 8);  // 181>>8 = 0.7071
        pMCUSrc[iRow+2] = (short)(tmp13 + z1);
        pMCUSrc[iRow+6] = (short)(tmp13 - z1);
        // odd part
        tmp10 = tmp4 + tmp5;
        tmp11 = tmp5 + tmp6;
        tmp12 = tmp6 + tmp7;
        z5 = (((tmp10 - tmp12) * 98) >> 8); // 98 >>8 = 0.3826
        z2 = z5 + ((tmp10 * 139) >> 8); // 139 >>8 = 0.541196
        z4 = z5 + ((tmp12 * 334) >> 8); // 334 >>8 = 1.3065
        z3 = ((tmp11 * 181) >> 8);
        z11 = tmp7 + z3;
        z13 = tmp7 - z3;
        pMCUSrc[iRow+5] = (short)(z13 + z2);
        pMCUSrc[iRow+3] = (short)(z13 - z2);
        pMCUSrc[iRow+1] = (short)(z11 + z4);
        pMCUSrc[iRow+7] = (short)(z11 - z4);
    } // for each row
    // now do the columns
    for (iCol=0; iCol < 8; iCol++)
    {
        tmp0 = pMCUSrc[iCol+0*8] + pMCUSrc[iCol+7*8];
        tmp7 = pMCUSrc[iCol+0*8] - pMCUSrc[iCol+7*8];
        tmp1 = pMCUSrc[iCol+1*8] + pMCUSrc[iCol+6*8];
        tmp6 = pMCUSrc[iCol+1*8] - pMCUSrc[iCol+6*8];
        tmp2 = pMCUSrc[iCol+2*8] + pMCUSrc[iCol+5*8];
        tmp5 = pMCUSrc[iCol+2*8] - pMCUSrc[iCol+5*8];
        tmp3 = pMCUSrc[iCol+3*8] + pMCUSrc[iCol+4*8];
        tmp4 = pMCUSrc[iCol+3*8] - pMCUSrc[iCol+4*8];
        // even part
        tmp10 = tmp0 + tmp3;
        tmp13 = tmp0 - tmp3;
        tmp11 = tmp1 + tmp2;
        tmp12 = tmp1 - tmp2;
        pMCUSrc[iCol+0] = (short)(tmp10 + tmp11);
        pMCUSrc[iCol+4*8] = (short)(tmp10 - tmp11);
        z1 = (((tmp12 + tmp13) * 181) >> 8);
        pMCUSrc[iCol+2*8] = (short)(tmp13 + z1);
        pMCUSrc[iCol+6*8] = (short)(tmp13 - z1);
        // odd part
        tmp10 = tmp4 + tmp5;
        tmp11 = tmp5 + tmp6;
        tmp12 = tmp6 + tmp7;
        z5 = (((tmp10 - tmp12) * 98) >> 8);
        z2 = z5 + ((tmp10 * 139) >> 8);
        z4 = z5 + ((tmp12 * 334) >> 8);
        z3 = (tmp11 * 181) >> 8;
        z11 = tmp7 + z3;
        z13 = tmp7 - z3;
        pMCUSrc[iCol+5*8] = (short)(z13 + z2);
        pMCUSrc[iCol+3*8] = (short)(z13 - z2);
        pMCUSrc[iCol+1*8] = (short)(z11 + z4);
        pMCUSrc[iCol+7*8] = (short)(z11 - z4);
    } // for each column
} /* JPEGFDCT() */

#endif // JPEG_DECODE_ONLY

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGIDCT(JPEGDATA *, signed short *, int, int)             *
 *                                                                          *
 *  PURPOSE    : Perform inverse discrete cosine transform on macro block.  *
 *                                                                          *
 ****************************************************************************/
void JPEGIDCT(JPEGDATA *pJPEG, signed short *pMCUSrc, int iQuantTable, int iACFlags)
{
    int iRow;
    unsigned char ucColMask;
    int iCol;
    signed int tmp6,tmp7,tmp10,tmp11,tmp12,tmp13;
    signed int z5,z10,z11,z12,z13;
    signed int tmp0,tmp1,tmp2,tmp3,tmp4,tmp5;
    signed short *pQuant;
    unsigned char *pOutput, *pRangeTable;
    unsigned char ucMaxACRow, ucMaxACCol;
    
    ucMaxACRow = (unsigned char)(iACFlags >> 8);
    ucMaxACCol = iACFlags & 0xff;
    
#if defined(HAVE_NEON) || defined(_X86)
    if (!(pJPEG->iOptions & PIL_CONVERT_SIMD)) // if no NEON support, use ARM asm
#ifdef USE_ARM_ASM
    {
        ARMJPEGIDCT(pJPEG, pMCUSrc, iQuantTable);
        return;
    }
#else
    {
    } // fall through
    else // use the SIMD version
    {
        JPEGIDCT_SIMD(pJPEG, pMCUSrc, iQuantTable, iACFlags);
        return;
    }
#endif // USE_ARM_ASM
#endif // NEON/SSE
    
    // my shortcut method appears to violate patent 20020080052
    // but the patent is invalidated by prior art:
    // http://netilium.org/~mad/dtj/DTJ/DTJK04/
    pQuant = (signed short *)&pJPEG->sQuantTable[iQuantTable * DCTSIZE2];
    pRangeTable = pJPEG->cRangeTable;
    if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE) // special case
    {
        /* Column 0 */
        tmp4 = pMCUSrc[0] * pQuant[0];
        tmp5 = pMCUSrc[8] * pQuant[8];
        tmp0 = tmp4 + tmp5;
        tmp2 = tmp4 - tmp5;
        /* Column 1 */
        tmp4 = pMCUSrc[1] * pQuant[1];
        tmp5 = pMCUSrc[9] * pQuant[9];
        tmp1 = tmp4 + tmp5;
        tmp3 = tmp4 - tmp5;
        /* Pass 2: process 2 rows, store into output array. */
        /* Row 0 */
        pOutput = (unsigned char *)pMCUSrc; // store output pixels back into MCU
        pOutput[0] = pRangeTable[(((tmp0 + tmp1)>>5) & 0x3ff)];
        pOutput[1] = pRangeTable[(((tmp0 - tmp1)>>5) & 0x3ff)];
        /* Row 1 */
        pOutput[2] = pRangeTable[(((tmp2 + tmp3)>>5) & 0x3ff)];
        pOutput[3] = pRangeTable[(((tmp2 - tmp3)>>5) & 0x3ff)];
        return;
    }
    // do columns first
    ucColMask = ucMaxACCol | 1; // column 0 must always be calculated
    for (iCol = 0; iCol < 8 && ucColMask; iCol++)
    {
        if (ucColMask & (1<<iCol)) // column has data in it
        {
            ucColMask &= ~(1<<iCol); // unmark this col after use
            if (!(ucMaxACRow & (1<<iCol))) // simpler calculations if only half populated
            {
                // even part
                tmp10 = pMCUSrc[iCol] * pQuant[iCol];
                tmp1 = pMCUSrc[iCol+16] * pQuant[iCol+16]; // get 2nd row
                tmp12 = ((tmp1*106)>>8); // used to be 362 - 1 (256)
                tmp0 = tmp10 + tmp1;
                tmp3 = tmp10 - tmp1;
                tmp1 = tmp10 + tmp12;
                tmp2 = tmp10 - tmp12;
                // odd part
                tmp4 = pMCUSrc[iCol+8] * pQuant[iCol+8]; // get 1st row
                tmp5 = pMCUSrc[iCol+24];
                if (tmp5) // this value is usually 0
                {
                    tmp5 *= pQuant[iCol+24]; // get 3rd row
                    tmp7 = tmp4 + tmp5;
                    tmp11 = (((tmp4 - tmp5) * 362) >> 8);  // 362>>8 = 1.414213562
                    z5 = (((tmp4-tmp5) * 473) >> 8);  // 473>>8 = 1.8477
                    tmp12 = ((-tmp5 * -669)>>8) + z5; // -669>>8 = -2.6131259
                    tmp6 = tmp12 - tmp7;
                    tmp5 = tmp11 - tmp6;
                    tmp10 = ((tmp4 * 277)>>8) - z5; // 277>>8 = 1.08239
                    tmp4 = tmp10 + tmp5;
                }
                else // simpler case when we only have 1 odd row to calculate
                {
                    tmp7 = tmp4;
                    tmp5 = (145*tmp4) >> 8;
                    tmp6 = (217*tmp4) >> 8;
                    tmp4 = (-51*tmp4) >> 8;
                }
                pMCUSrc[iCol] = (short)(tmp0 + tmp7);    // row0
                pMCUSrc[iCol+8] = (short)(tmp1 + tmp6);  // row 1
                pMCUSrc[iCol+16] = (short)(tmp2 + tmp5); // row 2
                pMCUSrc[iCol+24] = (short)(tmp3 - tmp4); // row 3
                pMCUSrc[iCol+32] = (short)(tmp3 + tmp4); // row 4
                pMCUSrc[iCol+40] = (short)(tmp2 - tmp5); // row 5
                pMCUSrc[iCol+48] = (short)(tmp1 - tmp6); // row 6
                pMCUSrc[iCol+56] = (short)(tmp0 - tmp7); // row 7
            }
            else // need to do full column calculation
            {
                // even part
                tmp0 = pMCUSrc[iCol] * pQuant[iCol];
                tmp2 = pMCUSrc[iCol+32]; // get 4th row
                if (tmp2) // 4th row is most likely 0
                {
                    tmp2 = tmp2 * pQuant[iCol+32];
                    tmp10 = tmp0 + tmp2;
                    tmp11 = tmp0 - tmp2;
                }
                else
                {
                    tmp10 = tmp11 = tmp0;
                }
                tmp1 = pMCUSrc[iCol+16] * pQuant[iCol+16]; // get 2nd row
                tmp3 = pMCUSrc[iCol+48]; // get 6th row
                if (tmp3) // 6th row is most likely 0
                {
                    tmp3 = tmp3 * pQuant[iCol+48];
                    tmp13 = tmp1 + tmp3;
                    tmp12 = (((tmp1 - tmp3) * 362) >> 8) - tmp13;  // 362>>8 = 1.414213562
                }
                else
                {
                    tmp13 = tmp1;
                    tmp12 = ((tmp1*362)>>8) - tmp1;
                }
                tmp0 = tmp10 + tmp13;
                tmp3 = tmp10 - tmp13;
                tmp1 = tmp11 + tmp12;
                tmp2 = tmp11 - tmp12;
                // odd part
                tmp5 = pMCUSrc[iCol+24] * pQuant[iCol+24]; // get 3rd row
                tmp6 = pMCUSrc[iCol+40]; // get 5th row
                if (tmp6) // very likely that row 5 = 0
                {
                    tmp6 = tmp6 * pQuant[iCol+40];
                    z13 = tmp6 + tmp5;
                    z10 = tmp6 - tmp5;
                }
                else
                {
                    z13 = tmp5;
                    z10 = -tmp5;
                }
                tmp4 = pMCUSrc[iCol+8] * pQuant[iCol+8]; // get 1st row
                tmp7 = pMCUSrc[iCol+56]; // get 7th row
                if (tmp7) // very likely that row 7 = 0
                {
                    tmp7 = tmp7 * pQuant[iCol+56];
                    z11 = tmp4 + tmp7;
                    z12 = tmp4 - tmp7;
                }
                else
                {
                    z11 = z12 = tmp4;
                }
                tmp7 = z11 + z13;
                tmp11 = (((z11 - z13) * 362) >> 8);  // 362>>8 = 1.414213562
                z5 = (((z10 + z12) * 473) >> 8);  // 473>>8 = 1.8477
                tmp12 = ((z10 * -669)>>8) + z5; // -669>>8 = -2.6131259
                tmp6 = tmp12 - tmp7;
                tmp5 = tmp11 - tmp6;
                tmp10 = ((z12 * 277)>>8) - z5; // 277>>8 = 1.08239
                tmp4 = tmp10 + tmp5;
                pMCUSrc[iCol] = (short)(tmp0 + tmp7);    // row0
                pMCUSrc[iCol+8] = (short)(tmp1 + tmp6);  // row 1
                pMCUSrc[iCol+16] = (short)(tmp2 + tmp5); // row 2
                pMCUSrc[iCol+24] = (short)(tmp3 - tmp4); // row 3
                pMCUSrc[iCol+32] = (short)(tmp3 + tmp4); // row 4
                pMCUSrc[iCol+40] = (short)(tmp2 - tmp5); // row 5
                pMCUSrc[iCol+48] = (short)(tmp1 - tmp6); // row 6
                pMCUSrc[iCol+56] = (short)(tmp0 - tmp7); // row 7
            } // full calculation needed
        } // if column has data in it
    } // for each column
    // now do rows
    pOutput = (unsigned char *)pMCUSrc; // store output pixels back into MCU
    for (iRow=0; iRow<64; iRow+=8) // all rows must be calculated
    {
        // even part
        if (ucMaxACCol < 0x10) // quick and dirty calculation (right 4 columns are all 0's)
        {
            if (ucMaxACCol < 0x04) // very likely case (1 or 2 columns occupied)
            {
                // even part
                tmp0 = tmp1 = tmp2 = tmp3 = pMCUSrc[iRow+0];
                // odd part
                tmp7 = pMCUSrc[iRow+1];
                tmp6 = (tmp7 * 217)>>8; // * 0.8477
                tmp5 = (tmp7 * 145)>>8; // * 0.5663
                tmp4 = -((tmp7 * 51)>>8);  // * -0.199
            }
            else
            {
                tmp10 = pMCUSrc[iRow+0];
                tmp13 = pMCUSrc[iRow+2];
                tmp12 = ((tmp13 * 106)>>8); // 2-6 * 1.414
                tmp0 = tmp10 + tmp13;
                tmp3 = tmp10 - tmp13;
                tmp1 = tmp10 + tmp12;
                tmp2 = tmp10 - tmp12;
                // odd part
                z13 = pMCUSrc[iRow+3];
                z11 = pMCUSrc[iRow+1];
                tmp7 = z11 + z13;
                tmp11 = ((z11 - z13)*362)>>8; // * 1.414
                z5 = ((z11 - z13)*473)>>8; // * 1.8477
                tmp10 = ((z11*277)>>8) - z5; // * 1.08239
                tmp12 = ((z13*669)>>8) + z5; // * 2.61312
                tmp6 = tmp12 - tmp7;
                tmp5 = tmp11 - tmp6;
                tmp4 = tmp10 + tmp5;
            }
        }
        else // need to do the full calculation
        {
            tmp10 = pMCUSrc[iRow+0] + pMCUSrc[iRow+4];
            tmp11 = pMCUSrc[iRow+0] - pMCUSrc[iRow+4];
            tmp13 = pMCUSrc[iRow+2] + pMCUSrc[iRow+6];
            tmp12 = (((pMCUSrc[iRow+2] - pMCUSrc[iRow+6]) * 362)>>8) - tmp13; // 2-6 * 1.414
            tmp0 = tmp10 + tmp13;
            tmp3 = tmp10 - tmp13;
            tmp1 = tmp11 + tmp12;
            tmp2 = tmp11 - tmp12;
            // odd part
            z13 = pMCUSrc[iRow+5] + pMCUSrc[iRow+3];
            z10 = pMCUSrc[iRow+5] - pMCUSrc[iRow+3];
            z11 = pMCUSrc[iRow+1] + pMCUSrc[iRow+7];
            z12 = pMCUSrc[iRow+1] - pMCUSrc[iRow+7];
            tmp7 = z11 + z13;
            tmp11 = ((z11 - z13)*362)>>8; // * 1.414
            z5 = ((z10 + z12)*473)>>8; // * 1.8477
            tmp10 = ((z12*277)>>8) - z5; // * 1.08239
            tmp12 = ((z10*-669)>>8) + z5; // * 2.61312
            tmp6 = tmp12 - tmp7;
            tmp5 = tmp11 - tmp6;
            tmp4 = tmp10 + tmp5;
        }
        // final output stage - scale down and range limit
        pOutput[0] = pRangeTable[(((tmp0 + tmp7)>>5) & 0x3ff)];
        pOutput[1] = pRangeTable[(((tmp1 + tmp6)>>5) & 0x3ff)];
        pOutput[2] = pRangeTable[(((tmp2 + tmp5)>>5) & 0x3ff)];
        pOutput[3] = pRangeTable[(((tmp3 - tmp4)>>5) & 0x3ff)];
        pOutput[4] = pRangeTable[(((tmp3 + tmp4)>>5) & 0x3ff)];
        pOutput[5] = pRangeTable[(((tmp2 - tmp5)>>5) & 0x3ff)];
        pOutput[6] = pRangeTable[(((tmp1 - tmp6)>>5) & 0x3ff)];
        pOutput[7] = pRangeTable[(((tmp0 - tmp7)>>5) & 0x3ff)];
        pOutput += 8;
    } // for each row
} /* JPEGIDCT() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGIDCT12(int *, int*)                                    *
 *                                                                          *
 *  PURPOSE    : Perform inverse DCT on 12-bit samples.                     *
 *                                                                          *
 ****************************************************************************/
void JPEGIDCT12(JPEGDATA *pJPEG, signed short *pMCUSrc, int iQuantTable)
{
    int iCol, iRow;
    unsigned char ucColMask;
    signed short *pQuant, s, *pOutput;
    signed int MCUInt[64]; // partial results need more than 16-bits of precision
    signed int tmp0,tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7,tmp10,tmp11,tmp12,tmp13;
    signed int z5,z10,z11,z12,z13;
    
    pQuant = (signed short *)&pJPEG->sQuantTable[iQuantTable * DCTSIZE2];
    memset(MCUInt, 0, sizeof(MCUInt)); // start with 0 because unpopulated cols/rows won't set the values
    // do columns first
    ucColMask = pJPEG->ucMaxACCol | 1; // column 0 must always be calculated
    for (iCol = 0; iCol < 8 && ucColMask; iCol++)
    {
        if (ucColMask & (1<<iCol)) // column has data in it
        {
            ucColMask &= ~(1<<iCol); // unmark this col after use
            if (!(pJPEG->ucMaxACRow & (1<<iCol))) // simpler calculations if only half populated
            {
                // even part
                tmp10 = pMCUSrc[iCol] * pQuant[iCol];
                tmp1 = pMCUSrc[iCol+16] * pQuant[iCol+16]; // get 2nd row
                tmp12 = ((tmp1*106)>>8); // 0.414213562
                tmp0 = tmp10 + tmp1;
                tmp3 = tmp10 - tmp1;
                tmp1 = tmp10 + tmp12;
                tmp2 = tmp10 - tmp12;
                // odd part
                tmp4 = pMCUSrc[iCol+8] * pQuant[iCol+8]; // get 1st row
                tmp5 = pMCUSrc[iCol+24];
                if (tmp5) // this value is usually 0
                {
                    tmp5 *= pQuant[iCol+24]; // get 3rd row
                    tmp7 = tmp4 + tmp5;
                    tmp11 = (((tmp4 - tmp5) * 362) >> 8);  // 362>>8 = 1.414213562
                    z5 = (((tmp4-tmp5) * 473) >> 8);  // 473>>8 = 1.8477
                    tmp12 = ((-tmp5 * -669)>>8) + z5; // -669>>8 = -2.6131259
                    tmp6 = tmp12 - tmp7;
                    tmp5 = tmp11 - tmp6;
                    tmp10 = ((tmp4 * 277)>>8) - z5; // 277>>8 = 1.08239
                    tmp4 = tmp10 + tmp5;
                }
                else // simpler case when we only have 1 odd row to calculate
                {
                    tmp7 = tmp4;
                    tmp5 = (145*tmp4) >> 8;
                    tmp6 = (217*tmp4) >> 8;
                    tmp4 = (-51*tmp4) >> 8;
                }
                MCUInt[iCol] = (tmp0 + tmp7);    // row0
                MCUInt[iCol+8] = (tmp1 + tmp6);  // row 1
                MCUInt[iCol+16] = (tmp2 + tmp5); // row 2
                MCUInt[iCol+24] = (tmp3 - tmp4); // row 3
                MCUInt[iCol+32] = (tmp3 + tmp4); // row 4
                MCUInt[iCol+40] = (tmp2 - tmp5); // row 5
                MCUInt[iCol+48] = (tmp1 - tmp6); // row 6
                MCUInt[iCol+56] = (tmp0 - tmp7); // row 7
            }
            else // need to do full column calculation
            {
                // even part
                tmp0 = pMCUSrc[iCol] * pQuant[iCol];
                tmp2 = pMCUSrc[iCol+32]; // get 4th row
                if (tmp2) // 4th row is most likely 0
                {
                    tmp2 = tmp2 * pQuant[iCol+32];
                    tmp10 = tmp0 + tmp2;
                    tmp11 = tmp0 - tmp2;
                }
                else
                {
                    tmp10 = tmp11 = tmp0;
                }
                tmp1 = pMCUSrc[iCol+16] * pQuant[iCol+16]; // get 2nd row
                tmp3 = pMCUSrc[iCol+48]; // get 6th row
                if (tmp3) // 6th row is most likely 0
                {
                    tmp3 = tmp3 * pQuant[iCol+48];
                    tmp13 = tmp1 + tmp3;
                    tmp12 = (((tmp1 - tmp3) * 362) >> 8) - tmp13;  // 362>>8 = 1.414213562
                }
                else
                {
                    tmp13 = tmp1;
                    tmp12 = ((tmp1*362)>>8) - tmp1;
                }
                tmp0 = tmp10 + tmp13;
                tmp3 = tmp10 - tmp13;
                tmp1 = tmp11 + tmp12;
                tmp2 = tmp11 - tmp12;
                // odd part
                tmp5 = pMCUSrc[iCol+24] * pQuant[iCol+24]; // get 3rd row
                tmp6 = pMCUSrc[iCol+40]; // get 5th row
                if (tmp6) // very likely that row 5 = 0
                {
                    tmp6 = tmp6 * pQuant[iCol+40];
                    z13 = tmp6 + tmp5;
                    z10 = tmp6 - tmp5;
                }
                else
                {
                    z13 = tmp5;
                    z10 = -tmp5;
                }
                tmp4 = pMCUSrc[iCol+8] * pQuant[iCol+8]; // get 1st row
                tmp7 = pMCUSrc[iCol+56]; // get 7th row
                if (tmp7) // very likely that row 7 = 0
                {
                    tmp7 = tmp7 * pQuant[iCol+56];
                    z11 = tmp4 + tmp7;
                    z12 = tmp4 - tmp7;
                }
                else
                {
                    z11 = z12 = tmp4;
                }
                tmp7 = z11 + z13;
                tmp11 = (((z11 - z13) * 362) >> 8);  // 362>>8 = 1.414213562
                z5 = (((z10 + z12) * 473) >> 8);  // 473>>8 = 1.8477
                tmp12 = ((z10 * -669)>>8) + z5; // -669>>8 = -2.6131259
                tmp6 = tmp12 - tmp7;
                tmp5 = tmp11 - tmp6;
                tmp10 = ((z12 * 277)>>8) - z5; // 277>>8 = 1.08239
                tmp4 = tmp10 + tmp5;
                MCUInt[iCol] = (tmp0 + tmp7);    // row0
                MCUInt[iCol+8] = (tmp1 + tmp6);  // row 1
                MCUInt[iCol+16] = (tmp2 + tmp5); // row 2
                MCUInt[iCol+24] = (tmp3 - tmp4); // row 3
                MCUInt[iCol+32] = (tmp3 + tmp4); // row 4
                MCUInt[iCol+40] = (tmp2 - tmp5); // row 5
                MCUInt[iCol+48] = (tmp1 - tmp6); // row 6
                MCUInt[iCol+56] = (tmp0 - tmp7); // row 7
            } // full calculation needed
        } // if column has data in it
    } // for each column
    // now do rows
    pOutput = pMCUSrc; // store output pixels back into MCU
    for (iRow=0; iRow<64; iRow+=8) // all rows must be calculated
    {
        // even part
        if (pJPEG->ucMaxACCol < 0x10) // quick and dirty calculation (right 4 columns are all 0's)
        {
            if (pJPEG->ucMaxACCol < 0x04) // very likely case (1 or 2 columns occupied)
            {
                tmp0 = tmp1 = tmp2 = tmp3 = MCUInt[iRow+0];
                // odd part
                tmp7 = z11 = MCUInt[iRow+1];
                tmp11 = (z11*362)>>8; // * 1.414
                z5 = (z11*473)>>8; // * 1.8477
                tmp10 = ((z11*277)>>8) - z5; // * 1.08239
                tmp12 = z5; // * 2.61312
                tmp6 = tmp12 - z11;
                tmp5 = tmp11 - tmp6;
                tmp4 = tmp10 + tmp5;
            }
            else
            {
                tmp10 = MCUInt[iRow+0];
                tmp13 = MCUInt[iRow+2];
                tmp12 = ((tmp13 * 106)>>8); // 2-6 * 1.414
                tmp0 = tmp10 + tmp13;
                tmp3 = tmp10 - tmp13;
                tmp1 = tmp10 + tmp12;
                tmp2 = tmp10 - tmp12;
                // odd part
                z13 = MCUInt[iRow+3];
                z11 = MCUInt[iRow+1];
                tmp7 = z11 + z13;
                tmp11 = ((z11 - z13)*362)>>8; // * 1.414
                z5 = ((z11 - z13)*473)>>8; // * 1.8477
                tmp10 = ((z11*277)>>8) - z5; // * 1.08239
                tmp12 = ((z13*669)>>8) + z5; // * 2.61312
                tmp6 = tmp12 - tmp7;
                tmp5 = tmp11 - tmp6;
                tmp4 = tmp10 + tmp5;
            }
        }
        else // need to do the full calculation
        {
            tmp10 = MCUInt[iRow+0] + MCUInt[iRow+4];
            tmp11 = MCUInt[iRow+0] - MCUInt[iRow+4];
            tmp13 = MCUInt[iRow+2] + MCUInt[iRow+6];
            tmp12 = (((MCUInt[iRow+2] - MCUInt[iRow+6]) * 362)>>8) - tmp13; // 2-6 * 1.414
            tmp0 = tmp10 + tmp13;
            tmp3 = tmp10 - tmp13;
            tmp1 = tmp11 + tmp12;
            tmp2 = tmp11 - tmp12;
            // odd part
            z13 = MCUInt[iRow+5] + MCUInt[iRow+3];
            z10 = MCUInt[iRow+5] - MCUInt[iRow+3];
            z11 = MCUInt[iRow+1] + MCUInt[iRow+7];
            z12 = MCUInt[iRow+1] - MCUInt[iRow+7];
            tmp7 = z11 + z13;
            tmp11 = ((z11 - z13)*362)>>8; // * 1.414
            z5 = ((z10 + z12)*473)>>8; // * 1.8477
            tmp10 = ((z12*277)>>8) - z5; // * 1.08239
            tmp12 = ((z10*-669)>>8) + z5; // * 2.61312
            tmp6 = tmp12 - tmp7;
            tmp5 = tmp11 - tmp6;
            tmp4 = tmp10 + tmp5;
        }
        // final output stage - scale down and range limit
        s = (signed short)((tmp0 + tmp7)>>5);
        s += 2048; // adjust for middle value
        if (s < 0) s = 0; // trim to 12 bit unsigned values
        else if (s > 0xfff) s = 0xfff;
        pOutput[0] = s;
        
        s = (signed short)((tmp1 + tmp6)>>5);
        s += 2048; // adjust for middle value
        if (s < 0) s = 0; // trim to 12 bit unsigned values
        else if (s > 0xfff) s = 0xfff;
        pOutput[1] = s;
        
        s = (signed short)((tmp2 + tmp5)>>5);
        s += 2048; // adjust for middle value
        if (s < 0) s = 0; // trim to 12 bit unsigned values
        else if (s > 0xfff) s = 0xfff;
        pOutput[2] = s;
        
        s = (signed short)((tmp3 - tmp4)>>5);
        s += 2048; // adjust for middle value
        if (s < 0) s = 0; // trim to 12 bit unsigned values
        else if (s > 0xfff) s = 0xfff;
        pOutput[3] = s;
        
        s = (signed short)((tmp3 + tmp4)>>5);
        s += 2048; // adjust for middle value
        if (s < 0) s = 0; // trim to 12 bit unsigned values
        else if (s > 0xfff) s = 0xfff;
        pOutput[4] = s;
        
        s = (signed short)((tmp2 - tmp5)>>5);
        s += 2048; // adjust for middle value
        if (s < 0) s = 0; // trim to 12 bit unsigned values
        else if (s > 0xfff) s = 0xfff;
        pOutput[5] = s;
        
        s = (signed short)((tmp1 - tmp6)>>5);
        s += 2048; // adjust for middle value
        if (s < 0) s = 0; // trim to 12 bit unsigned values
        else if (s > 0xfff) s = 0xfff;
        pOutput[6] = s;
        
        s = (signed short)((tmp0 - tmp7)>>5);
        s += 2048; // adjust for middle value
        if (s < 0) s = 0; // trim to 12 bit unsigned values
        else if (s > 0xfff) s = 0xfff;
        pOutput[7] = s;
        
        pOutput += 8;
    } // for each row
    
} /* JPEGIDCT12() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGInitTables(JPEGDATA *)                                 *
 *                                                                          *
 *  PURPOSE    : Initialize the color space conversion tables.              *
 *                                                                          *
 ****************************************************************************/
void JPEGInitTables(JPEGDATA *pJPEG)
{
    signed int i;
    unsigned char uc;
    
    /* Create a range clipping table for YCC to RGB color conversion */
    /* Create range clipping table with conversion for 16bpp pixels */
    for (i=0; i<256; i++)
    {
        pJPEG->usRangeTableB[i] = (unsigned short)(i >> 3) & 0x1f; // lower 5 bits = Blue
        pJPEG->usRangeTableG[i] = (unsigned short)(i & 0xfc) << 3; // middle 6 bits = Green
        pJPEG->usRangeTableR[i] = (unsigned short)(i & 0xf8) << 8; // upper 5 bits = Red
        pJPEG->cRangeTable2[i] = (unsigned char)i;
    }
    memset(&pJPEG->cRangeTable2[256],0xff,256);   // 256-511 clipped to max value
    memset(&pJPEG->cRangeTable2[512],0,512);   // 512-1023 are negative clipped to 0
    uc = 255;
    for (i=256; i<512; i++)
    {
        pJPEG->usRangeTableB[i] = (uc >> 3) & 0x1f; // lower 5 bits = Blue
        pJPEG->usRangeTableG[i] = (uc & 0xfc) << 3; // middle 6 bits = Green
        pJPEG->usRangeTableR[i] = (uc & 0xf8) << 8; // upper 5 bits = Red
    }
} /* JPEGInitTables() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPixel(...)                                             *
 *                                                                          *
 *  PURPOSE    : Output a 32bpp, 16bpp or 24bpp color pixel from YCbCr info.*
 *                                                                          *
 ****************************************************************************/
void JPEGPixel(JPEGDATA *pJPEG, unsigned char *pDest, int x, int iY, int iCb, int iCr)
{
    int iCBB, iCBG, iCRG, iCRR;
    unsigned short usPixel;
    uint32_t ulPixel;
    
    iCBB = 7258  * (iCb-0x80);
    iCBG = -1409 * (iCb-0x80);
    iCRG = -2925 * (iCr-0x80);
    iCRR = 5742  * (iCr-0x80);
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
    {
        usPixel = pJPEG->usRangeTableB[((iCBB + iY) >> 12) & 0x3ff]; // blue pixel
        usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + iY) >> 12) & 0x3ff]; // green pixel
        usPixel |= pJPEG->usRangeTableR[((iCRR + iY) >> 12) & 0x3ff]; // red pixel
        *(short *)&pDest[x<<1] = usPixel;
    }
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP) // RGBA
    {
        ulPixel = 0xff000000;
        ulPixel |= pJPEG->cRangeTable2[((iCBB + iY) >> 12) & 0x3ff] << 16; // blue pixel
        ulPixel |= pJPEG->cRangeTable2[((iCBG + iCRG + iY) >> 12) & 0x3ff] << 8; // green pixel
        ulPixel |= pJPEG->cRangeTable2[((iCRR + iY) >> 12) & 0x3ff]; // red pixel
        *(uint32_t *)&pDest[x<<2] = ulPixel;
    }
    else // BGR
    {
        pDest += x*3;
        *pDest++ = pJPEG->cRangeTable2[((iCBB + iY) >> 12) & 0x3ff]; // blue pixel
        *pDest++ = pJPEG->cRangeTable2[((iCBG + iCRG + iY) >> 12) & 0x3ff]; // green pixel
        *pDest++ = pJPEG->cRangeTable2[((iCRR + iY) >> 12) & 0x3ff]; // red pixel
    }
    
} /* JPEGPixel() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPixelYCCK(...)                                         *
 *                                                                          *
 *  PURPOSE    : Output a 32bpp, 16bpp or 24bpp color pixel from YCbCr info.*
 *                                                                          *
 ****************************************************************************/
void JPEGPixelYCCK(JPEGDATA *pJPEG, unsigned char *pDest, int x, int iY, int iCb, int iCr, int K)
{
    int iCBB, iCBG, iCRG, iCRR;
    unsigned short usPixel;
    uint32_t ulPixel;
    int r, g, b;
    
    iCBB = 7258  * (iCb-0x80);
    iCBG = -1409 * (iCb-0x80);
    iCRG = -2925 * (iCr-0x80);
    iCRR = 5742  * (iCr-0x80);
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
    {
        usPixel = pJPEG->usRangeTableB[((iCBB + iY) >> 12) & 0x3ff]; // blue pixel
        usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + iY) >> 12) & 0x3ff]; // green pixel
        usPixel |= pJPEG->usRangeTableR[((iCRR + iY) >> 12) & 0x3ff]; // red pixel
        *(short *)&pDest[x<<1] = usPixel;
    }
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP) // RGBA
    {
        ulPixel = 0xff000000;
        //           K -= 0x80; if (K < 0) K += 256;
        b = pJPEG->cRangeTable2[((iCBB + iY) >> 12) & 0x3ff];
        g = pJPEG->cRangeTable2[((iCBG + iCRG + iY) >> 12) & 0x3ff];
        r = pJPEG->cRangeTable2[((iCRR + iY) >> 12) & 0x3ff];
        b = ((255-b)*K)/256;
        g = ((255-g)*K)/256;
        r = ((255-r)*K)/256;
        ulPixel |= (b << 16); // blue pixel
        ulPixel |= (g << 8); // green pixel
        ulPixel |= r; // red pixel
        *(uint32_t *)&pDest[x<<2] = ulPixel;
    }
    else // BGR
    {
        pDest += x*3;
        b = pJPEG->cRangeTable2[((iCBB + iY) >> 12) & 0x3ff];
        g = pJPEG->cRangeTable2[((iCBG + iCRG + iY) >> 12) & 0x3ff];
        r = pJPEG->cRangeTable2[((iCRR + iY) >> 12) & 0x3ff];
        b = ((255 - b)*K) / 256;
        g = ((255 - g)*K) / 256;
        r = ((255 - r)*K) / 256;
        *pDest++ = (unsigned char)b; // blue pixel
        *pDest++ = (unsigned char) g; // green pixel
        *pDest++ = (unsigned char) r; // red pixel
    }
    
} /* JPEGPixel() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPixelRGB(...)                                          *
 *                                                                          *
 *  PURPOSE    : Output a 32bpp, 16bpp or 24bpp color pixel from RGB info.  *
 *                                                                          *
 ****************************************************************************/
void JPEGPixelRGB(JPEGDATA *pJPEG, unsigned char *pDest, int x, unsigned char ucR, unsigned char ucG, unsigned char ucB)
{
    unsigned short usPixel;
    uint32_t ulPixel;
    
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
    {
        usPixel = ucB >> 3; // blue pixel
        usPixel |= ((ucG >> 2) << 5); // green pixel
        usPixel |= ((ucR >> 3) << 11); // red pixel
        *(short *)&pDest[x<<1] = usPixel;
    }
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP) // RGBA
    {
        ulPixel = 0xff000000;
        ulPixel |= (ucB << 16); // blue pixel
        ulPixel |= (ucG << 8); // green pixel
        ulPixel |= ucR; // red pixel
        *(uint32_t *)&pDest[x<<2] = ulPixel;
    }
    else // BGR
    {
        pDest += x*3;
        *pDest++ = ucB; // blue pixel
        *pDest++ = ucG; // green pixel
        *pDest++ = ucR; // red pixel
    }
    
} /* JPEGPixelRGB() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPixelCMYK(...)                                         *
 *                                                                          *
 *  PURPOSE    : Output a 32bpp, 16bpp or 24bpp color pixel from CMYK info. *
 *                                                                          *
 ****************************************************************************/
void JPEGPixelCMYK(JPEGDATA *pJPEG, unsigned char *pDest, int x, int ucCyan, int ucMagenta, int ucYellow, int ucBlack)
{
    unsigned short usPixel;
    uint32_t ulPixel;
    int r, g, b;
    
    //    ucCyan = ucCyan - 0x80;
    //    ucMagenta = ucMagenta - 0x80;
    //    ucYellow = ucYellow - 0x80;
    //    ucBlack = ucBlack - 0x80;
    g = (((ucMagenta)*(ucBlack))>>8);
    b = (((ucYellow)*(ucBlack))>>8);
    r = (((ucCyan)*(ucBlack))>>8);
    
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
    {
        usPixel =  (unsigned short)(b>>3); // blue pixel
        usPixel |= ((g >> 2) << 5); // green pixel
        usPixel |= ((r >> 3) << 11); // red pixel
        *(short *)&pDest[x<<1] = usPixel;
    }
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP) // RGBA
    {
        ulPixel = 0xff000000;
        ulPixel |= (b << 16); // blue pixel
        ulPixel |= (g << 8); // green pixel
        ulPixel |= r; // red pixel
        *(uint32_t *)&pDest[x<<2] = ulPixel;
    }
    else // 24BPP = BGR
    {
        pDest += x*3;
        *pDest++ = (unsigned char) b; // blue pixel
        *pDest++ = (unsigned char) g; // green pixel
        *pDest++ = (unsigned char) r; // red pixel
    }
    
} /* JPEGPixelCMYK() */

/*****************************************************************************
 *                                                                           *
 *  FUNCTION   : JPEGPixel2(...)                                             *
 *                                                                           *
 *  PURPOSE    : Output a pair of 16bpp or 24bpp color pixel from YCbCr info.*
 *                                                                           *
 *****************************************************************************/
void JPEGPixel2(JPEGDATA *pJPEG, unsigned char *pDest, int x, int iY1, int iY2, int iCb, int iCr)
{
    int iCBB, iCBG, iCRG, iCRR;
    uint32_t ulPixel1, ulPixel2, *pul;
    
    iCBB = 7258  * (iCb-0x80);
    iCBG = -1409 * (iCb-0x80);
    iCRG = -2925 * (iCr-0x80);
    iCRR = 5742  * (iCr-0x80);
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
    {
        ulPixel1 = pJPEG->usRangeTableB[((iCBB + iY1) >> 12) & 0x3ff]; // blue pixel
        ulPixel1 |= pJPEG->usRangeTableG[((iCBG + iCRG + iY1) >> 12) & 0x3ff]; // green pixel
        ulPixel1 |= pJPEG->usRangeTableR[((iCRR + iY1) >> 12) & 0x3ff]; // red pixel
        
        ulPixel2 = pJPEG->usRangeTableB[((iCBB + iY2) >> 12) & 0x3ff]; // blue pixel
        ulPixel2 |= pJPEG->usRangeTableG[((iCBG + iCRG + iY2) >> 12) & 0x3ff]; // green pixel
        ulPixel2 |= pJPEG->usRangeTableR[((iCRR + iY2) >> 12) & 0x3ff]; // red pixel
        *(uint32_t *)&pDest[x<<1] = ulPixel1 | (ulPixel2<<16);
    }
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP) // RGBA
    {
        pul = (uint32_t *)&pDest[x<<2];
        ulPixel1 = 0xff000000;
        ulPixel1 |= pJPEG->cRangeTable2[((iCBB + iY1) >> 12) & 0x3ff] << 16; // blue pixel
        ulPixel1 |= pJPEG->cRangeTable2[((iCBG + iCRG + iY1) >> 12) & 0x3ff]<<8; // green pixel
        ulPixel1 |= pJPEG->cRangeTable2[((iCRR + iY1) >> 12) & 0x3ff]; // red pixel
        *pul++ = ulPixel1;
        
        ulPixel2 = 0xff000000;
        ulPixel2 |= pJPEG->cRangeTable2[((iCBB + iY2) >> 12) & 0x3ff] << 16; // blue pixel
        ulPixel2 |= pJPEG->cRangeTable2[((iCBG + iCRG + iY2) >> 12) & 0x3ff] << 8; // green pixel
        ulPixel2 |= pJPEG->cRangeTable2[((iCRR + iY2) >> 12) & 0x3ff]; // red pixel
        *pul++ = ulPixel2;
    }
    else // 24bpp (BGR)
    {
        pDest += x*3;
        *pDest++ = pJPEG->cRangeTable2[((iCBB + iY1) >> 12) & 0x3ff]; // blue pixel
        *pDest++ = pJPEG->cRangeTable2[((iCBG + iCRG + iY1) >> 12) & 0x3ff]; // green pixel
        *pDest++ = pJPEG->cRangeTable2[((iCRR + iY1) >> 12) & 0x3ff]; // red pixel
        
        *pDest++ = pJPEG->cRangeTable2[((iCBB + iY2) >> 12) & 0x3ff]; // blue pixel
        *pDest++ = pJPEG->cRangeTable2[((iCBG + iCRG + iY2) >> 12) & 0x3ff]; // green pixel
        *pDest++ = pJPEG->cRangeTable2[((iCRR + iY2) >> 12) & 0x3ff]; // red pixel
    }
    
} /* JPEGPixel2() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPixel_A(...)                                           *
 *                                                                          *
 *  PURPOSE    : Output a 32bpp, 16bpp or 24bpp color pixel from YCbCr info.*
 *                                                                          *
 ****************************************************************************/
void JPEGPixel_A(JPEGDATA *pJPEG, unsigned char *pDest, int x, int iY, int iCb, int iCr)
{
    int iCBB, iCBG, iCRG, iCRR;
    unsigned short usPixel;
    
    iCBB = 7258  * iCb;
    iCBG = -1409 * iCb;
    iCRG = -2925 * iCr;
    iCRR = 5742  * iCr;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
    {
        usPixel = pJPEG->usRangeTableB[((iCBB + iY) >> 12) & 0x3ff]; // blue pixel
        usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + iY) >> 12) & 0x3ff]; // green pixel
        usPixel |= pJPEG->usRangeTableR[((iCRR + iY) >> 12) & 0x3ff]; // red pixel
        *(short *)&pDest[x<<1] = usPixel;
    }
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP) // RGBA
    {
        uint32_t ulPixel = 0xff000000;
        ulPixel |= pJPEG->cRangeTable2[((iCBB + iY) >> 12) & 0x3ff] << 16; // blue pixel
        ulPixel |= pJPEG->cRangeTable2[((iCBG + iCRG + iY) >> 12) & 0x3ff] << 8; // green pixel
        ulPixel |= pJPEG->cRangeTable2[((iCRR + iY) >> 12) & 0x3ff]; // red pixel
        *(uint32_t *)&pDest[x<<2] = ulPixel;
    }
    else // BGR
    {
        pDest += x*3;
        *pDest++ = pJPEG->cRangeTable2[((iCBB + iY) >> 12) & 0x3ff]; // blue pixel
        *pDest++ = pJPEG->cRangeTable2[((iCBG + iCRG + iY) >> 12) & 0x3ff]; // green pixel
        *pDest++ = pJPEG->cRangeTable2[((iCRR + iY) >> 12) & 0x3ff]; // red pixel
    }
    
} /* JPEGPixel_A() */

/*****************************************************************************
 *                                                                           *
 *  FUNCTION   : JPEGPixel2_A(...)                                           *
 *                                                                           *
 *  PURPOSE    : Output a pair of 32bpp, 16bpp or 24bpp color pixel from YCbCr info.*
 *                                                                           *
 *****************************************************************************/
void JPEGPixel2_A(JPEGDATA *pJPEG, unsigned char *pDest, int x, int iY1, int iY2, int iCb, int iCr)
{
    int iCBB, iCBG, iCRG, iCRR;
    uint32_t ulPixel1, ulPixel2;
    
    iCBB = 7258  * iCb;
    iCBG = -1409 * iCb;
    iCRG = -2925 * iCr;
    iCRR = 5742  * iCr;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
    {
        ulPixel1 = pJPEG->usRangeTableB[((iCBB + iY1) >> 12) & 0x3ff]; // blue pixel
        ulPixel1 |= pJPEG->usRangeTableG[((iCBG + iCRG + iY1) >> 12) & 0x3ff]; // green pixel
        ulPixel1 |= pJPEG->usRangeTableR[((iCRR + iY1) >> 12) & 0x3ff]; // red pixel
        
        ulPixel2 = pJPEG->usRangeTableB[((iCBB + iY2) >> 12) & 0x3ff]; // blue pixel
        ulPixel2 |= pJPEG->usRangeTableG[((iCBG + iCRG + iY2) >> 12) & 0x3ff]; // green pixel
        ulPixel2 |= pJPEG->usRangeTableR[((iCRR + iY2) >> 12) & 0x3ff]; // red pixel
        *(uint32_t *)&pDest[x<<1] = ulPixel1 | (ulPixel2<<16);
    }
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
    {
        uint32_t *pul = (uint32_t *)(&pDest[x<<2]);
        uint32_t ul;
        ul = 0xff000000;
        ul |= pJPEG->cRangeTable2[((iCBB + iY1) >> 12) & 0x3ff] << 16; // blue pixel
        ul |= pJPEG->cRangeTable2[((iCBG + iCRG + iY1) >> 12) & 0x3ff] << 8; // green pixel
        ul |= pJPEG->cRangeTable2[((iCRR + iY1) >> 12) & 0x3ff]; // red pixel
        *pul++ = ul;
        
        ul = 0xff000000;
        ul |= pJPEG->cRangeTable2[((iCBB + iY2) >> 12) & 0x3ff] << 16; // blue pixel
        ul |= pJPEG->cRangeTable2[((iCBG + iCRG + iY2) >> 12) & 0x3ff] << 8; // green pixel
        ul |= pJPEG->cRangeTable2[((iCRR + iY2) >> 12) & 0x3ff]; // red pixel
        *pul++ = ul;
    }
    else // 24bpp BGR
    {
        pDest += x*3;
        *pDest++ = pJPEG->cRangeTable2[((iCBB + iY1) >> 12) & 0x3ff]; // blue pixel
        *pDest++ = pJPEG->cRangeTable2[((iCBG + iCRG + iY1) >> 12) & 0x3ff]; // green pixel
        *pDest++ = pJPEG->cRangeTable2[((iCRR + iY1) >> 12) & 0x3ff]; // red pixel
        
        *pDest++ = pJPEG->cRangeTable2[((iCBB + iY2) >> 12) & 0x3ff]; // blue pixel
        *pDest++ = pJPEG->cRangeTable2[((iCBG + iCRG + iY2) >> 12) & 0x3ff]; // green pixel
        *pDest++ = pJPEG->cRangeTable2[((iCRR + iY2) >> 12) & 0x3ff]; // red pixel
    }
    
} /* JPEGPixel2_A() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU22(int, int, int, int*, char *)                  *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU22(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1, Y2, Y3, Y4;
    int iRow, iCol, iXCount1, iXCount2, iYCount;
    unsigned char *pY, *pCr, *pCb;
    int bUseOdd1, bUseOdd2; // special case where 24bpp odd sized image can clobber first column
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU4];
    pCr = (unsigned char *)&pMCU[MCU5];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*16*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<5;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<6;
    else
        cOutput += x*48;
    
    //   if (y*16+15 >= inpage->iHeight)  // if last block overflows bottom of image
    //      iYCount = (inpage->iHeight & 15)>>2;
    //   else
    iYCount = 4;
    bUseOdd1 = bUseOdd2 = TRUE; // assume odd column can be used
    if ((x*16+15) >= inpage->iWidth)
    {
        iCol = (((inpage->iWidth & 15)+1) >> 1);
        if (iCol >= 4)
        {
            iXCount1 = 4;
            iXCount2 = iCol-4;
            if (inpage->iWidth & 1 && (iXCount2 * 2) + 8 + (x * 16) > inpage->iWidth)
                bUseOdd2 = FALSE;
        }
        else
        {
            iXCount1 = iCol;
            iXCount2 = 0;
            if (inpage->iWidth & 1 && (iXCount1 * 2) + (x * 16) > inpage->iWidth)
                bUseOdd1 = FALSE;
        }
    }
    else
        iXCount1 = iXCount2 = 4;
#ifdef USE_ARM_ASM
    if (!(pJPEG->iOptions & PIL_CONVERT_SIMD) && (pJPEG->iOptions & PIL_CONVERT_16BPP) && iYCount == 4 && iXCount1 == 4 && iXCount2 == 4) // draw the full sized 16bpp block with ASM
    {
        ARMDrawMCU22(pMCU, cOutput, lsize);
        return;
    }
#endif // USE_ARM_ASM
    
    for (iRow=0; iRow<iYCount; iRow++) // up to 4 rows to do
    {
        for (iCol=0; iCol<iXCount1; iCol++) // up to 4 cols to do
        {
            // for top left block
            Y1 = pY[iCol*2];
            Y2 = pY[iCol*2+1];
            Y3 = pY[iCol*2+8];
            Y4 = pY[iCol*2+9];
            Y1 <<= 12;  // scale to level of conversion table
            Y2 <<= 12;
            Y3 <<= 12;
            Y4 <<= 12;
            Cb = pCb[iCol];
            Cr = pCr[iCol];
            if (bUseOdd1 || iCol != (iXCount1-1)) // only render if it won't go off the right edge
            {
                JPEGPixel2(pJPEG, cOutput, (iCol<<1), Y1, Y2, Cb, Cr);
                JPEGPixel2(pJPEG, cOutput+lsize, (iCol<<1), Y3, Y4, Cb, Cr);
            }
            else
            {
                JPEGPixel(pJPEG, cOutput, (iCol<<1), Y1, Cb, Cr);
                JPEGPixel(pJPEG, cOutput+lsize, (iCol<<1), Y3, Cb, Cr);
            }
            // for top right block
            if (iCol < iXCount2)
            {
                Y1 = pY[iCol*2+DCTSIZE2*2];
                Y2 = pY[iCol*2+1+DCTSIZE2*2];
                Y3 = pY[iCol*2+8+DCTSIZE2*2];
                Y4 = pY[iCol*2+9+DCTSIZE2*2];
                Y1 <<= 12;  // scale to level of conversion table
                Y2 <<= 12;
                Y3 <<= 12;
                Y4 <<= 12;
                Cb = pCb[iCol+4];
                Cr = pCr[iCol+4];
                if (bUseOdd2 || iCol != (iXCount2-1)) // only render if it won't go off the right edge
                {
                    JPEGPixel2(pJPEG, cOutput, 8+(iCol<<1), Y1, Y2, Cb, Cr);
                    JPEGPixel2(pJPEG, cOutput+lsize, 8+(iCol<<1), Y3, Y4, Cb, Cr);
                }
                else
                {
                    JPEGPixel(pJPEG, cOutput, 8+(iCol<<1), Y1, Cb, Cr);
                    JPEGPixel(pJPEG, cOutput+lsize, 8+(iCol<<1), Y3, Cb, Cr);
                }
            }
            // for bottom left block
            Y1 = pY[iCol*2+DCTSIZE2*4];
            Y2 = pY[iCol*2+1+DCTSIZE2*4];
            Y3 = pY[iCol*2+8+DCTSIZE2*4];
            Y4 = pY[iCol*2+9+DCTSIZE2*4];
            Y1 <<= 12;  // scale to level of conversion table
            Y2 <<= 12;
            Y3 <<= 12;
            Y4 <<= 12;
            Cb = pCb[iCol+32];
            Cr = pCr[iCol+32];
            if (bUseOdd1 || iCol != (iXCount1-1)) // only render if it won't go off the right edge
            {
                JPEGPixel2(pJPEG, cOutput+lsize*8, (iCol<<1), Y1, Y2, Cb, Cr);
                JPEGPixel2(pJPEG, cOutput+lsize*9, (iCol<<1), Y3, Y4, Cb, Cr);
            }
            else
            {
                JPEGPixel(pJPEG, cOutput+lsize*8, (iCol<<1), Y1, Cb, Cr);
                JPEGPixel(pJPEG, cOutput+lsize*9, (iCol<<1), Y3, Cb, Cr);
            }
            // for bottom right block
            if (iCol < iXCount2)
            {
                Y1 = pY[iCol*2+DCTSIZE2*6];
                Y2 = pY[iCol*2+1+DCTSIZE2*6];
                Y3 = pY[iCol*2+8+DCTSIZE2*6];
                Y4 = pY[iCol*2+9+DCTSIZE2*6];
                Y1 <<= 12;  // scale to level of conversion table
                Y2 <<= 12;
                Y3 <<= 12;
                Y4 <<= 12;
                Cb = pCb[iCol+36];
                Cr = pCr[iCol+36];
                if (bUseOdd2 || iCol != (iXCount2-1)) // only render if it won't go off the right edge
                {
                    JPEGPixel2(pJPEG, cOutput+lsize*8, 8+(iCol<<1), Y1, Y2, Cb, Cr);
                    JPEGPixel2(pJPEG, cOutput+lsize*9, 8+(iCol<<1), Y3, Y4, Cb, Cr);
                }
                else
                {
                    JPEGPixel(pJPEG, cOutput+lsize*8, 8+(iCol<<1), Y1, Cb, Cr);
                    JPEGPixel(pJPEG, cOutput+lsize*9, 8+(iCol<<1), Y3, Cb, Cr);
                }
            }
        } // for each column
        pY += 16; // skip to next line of source pixels
        pCb += 8;
        pCr += 8;
        cOutput += lsize*2;
    }
} /* JPEGPutMCU22() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU22HALF(int, int, int, int*, char *)              *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU22HALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1;
    int iRow, iCol, iXCount1, iXCount2, iYCount;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU4];
    pCr = (unsigned char *)&pMCU[MCU5];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*8*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<4;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<5;
    else
        cOutput += x*24;
    iYCount = 4;
    if (x*8+7 > (inpage->iWidth/2))
    {
        iXCount1 = ((inpage->iWidth/2) & 7);
        if (iXCount1 >= 4)
        {
            iXCount2 = iXCount1 - 4;
            iXCount1 = 4;
        }
        else
        {
            iXCount2 = 0;
        }
    }
    else
        iXCount1 = iXCount2 = 4;
    for (iRow=0; iRow<iYCount; iRow++) // up to 4 rows to do
    {
        for (iCol=0; iCol<iXCount1; iCol++) // up to 4 cols to do
        {
            // for top left block
            // Average the 4 pixels together
            Y1 =  pY[iCol*2];
            Y1 += pY[iCol*2+1];
            Y1 += pY[iCol*2+8];
            Y1 += pY[iCol*2+9];
            //         Y1 <<= 12;  // scale to level of conversion table
            Y1 <<= 10;
            Cb = pCb[iCol];
            Cr = pCr[iCol];
            JPEGPixel(pJPEG, cOutput, iCol, Y1, Cb, Cr);
            // for top right block
            // average the 4 pixels together
            if (iCol < iXCount2)
            {
                Y1 =  pY[iCol*2+DCTSIZE2*2];
                Y1 += pY[iCol*2+1+DCTSIZE2*2];
                Y1 += pY[iCol*2+8+DCTSIZE2*2];
                Y1 += pY[iCol*2+9+DCTSIZE2*2];
                //         Y1 <<= 12;  // scale to level of conversion table
                Y1 <<= 10;
                Cb = pCb[iCol+4];
                Cr = pCr[iCol+4];
                JPEGPixel(pJPEG, cOutput, 4+iCol, Y1, Cb, Cr);
            }
            // for bottom left block
            Y1 =  pY[iCol*2+DCTSIZE2*4];
            Y1 += pY[iCol*2+1+DCTSIZE2*4];
            Y1 += pY[iCol*2+8+DCTSIZE2*4];
            Y1 += pY[iCol*2+9+DCTSIZE2*4];
            //         Y1 <<= 12;  // scale to level of conversion table
            Y1 <<= 10;
            Cb = pCb[iCol+32];
            Cr = pCr[iCol+32];
            JPEGPixel(pJPEG, cOutput+lsize*4, iCol, Y1, Cb, Cr);
            // for bottom right block
            if (iCol < iXCount2)
            {
                Y1 =  pY[iCol*2+DCTSIZE2*6];
                Y1 += pY[iCol*2+1+DCTSIZE2*6];
                Y1 += pY[iCol*2+8+DCTSIZE2*6];
                Y1 += pY[iCol*2+9+DCTSIZE2*6];
                //         Y1 <<= 12;  // scale to level of conversion table
                Y1 <<= 10;
                Cb = pCb[iCol+36];
                Cr = pCr[iCol+36];
                JPEGPixel(pJPEG, cOutput+lsize*4, 4+iCol, Y1, Cb, Cr);
            }
        } // for each column
        pY += 16; // skip to next line of source pixels
        pCb += 8;
        pCr += 8;
        cOutput += lsize;
    }
    
} /* JPEGPutMCU22HALF() */
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU22QUARTER(int, int, int, int*, char *)           *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU22QUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1;
    unsigned char *pY, *pCr, *pCb;
    int iCol, iRow;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU4];
    pCr = (unsigned char *)&pMCU[MCU5];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*4*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<3;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<4;
    else
        cOutput += x*12;
    for (iRow=0; iRow<2; iRow++)
    {
        for (iCol=0; iCol<2; iCol++)
        {
            // top left block
            Y1 =  pY[iCol] << 12; // scale to level of conversion table
            Cb  = pCb[0];
            Cr  = pCr[0];
            JPEGPixel(pJPEG, cOutput, iCol, Y1, Cb, Cr);
            // top right block
            Y1 =  pY[iCol+(DCTSIZE2*2)] << 12; // scale to level of conversion table
            Cb = pCb[1];
            Cr = pCr[1];
            JPEGPixel(pJPEG, cOutput, 2+iCol, Y1, Cb, Cr);
            // bottom left block
            Y1 =  pY[iCol+DCTSIZE2*4] << 12;  // scale to level of conversion table
            Cb = pCb[2];
            Cr = pCr[2];
            JPEGPixel(pJPEG, cOutput+lsize*2, iCol, Y1, Cb, Cr);
            // bottom right block
            Y1 =  pY[iCol+DCTSIZE2*6] << 12; // scale to level of conversion table
            Cb  = pCb[3];
            Cr  = pCr[3];
            JPEGPixel(pJPEG, cOutput+lsize*2, 2+iCol, Y1, Cb, Cr);
        } // for each column
        pY += 2; // skip 2 lines of source pixels
        cOutput += lsize;
    }
    
} /* JPEGPutMCU22QUARTER() */

#ifdef JPEG_PROGRESSIVE
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DrawJPEG22(...)                                            *
 *                                                                          *
 *  PURPOSE    : Convert the progressive scanned MCUs into an image.        *
 *                                                                          *
 ****************************************************************************/
int DrawJPEG22(PIL_PAGE *inpage, signed short *pMCU, JPEGDATA *pJPEG, unsigned char *cOutput)
{
    int cx, cy, x, y, lsize;
    int iMCUBlock;
    signed short iMCUTemp[DCTSIZE2*6];
    uint32_t Cb,Cr;
    signed int Y1,Y2,Y3,Y4;
    signed int iQuant1, iQuant2;
    unsigned short *usOutput;
    uint32_t *ulOutput;
    uint32_t usPixel; // define as long to get around compiler innefficiency
    int iCBB, iCBG, iCRR, iCRG;
    
    usOutput = (unsigned short *)cOutput;
    ulOutput = (uint32_t *)cOutput;
    lsize = inpage->iPitch;
    // faster access with reg vars
    iQuant1 = pJPEG->sQuantTable[0];
    iQuant2 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[1].quant_tbl_no];
    
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = (inpage->iWidth + 1)>>1;  // number of MCU blocks
        cy = (inpage->iHeight + 1)>>1;
        if (pJPEG->iOptions & PIL_CONVERT_16BPP)
            lsize >>= 1; // divide again since we draw it in this function
        else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
            lsize >>= 2; // divide again since we draw it in this function
    }
    else
    {
        cx = (inpage->iWidth + 15)>>4;  // number of MCU blocks
        cy = (inpage->iHeight + 15)>>4;
    }
    iMCUBlock = 0;
    pJPEG->ucMaxACRow = pJPEG->ucMaxACCol = 0xff; // we don't check the max column in progressive JPEGs, so do the whole matrix
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL) // thumbnail view is special
            {
                Cb = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU4] * iQuant2)>>5) & 0x3ff];
                Cr = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU5] * iQuant2)>>5) & 0x3ff];
                // These remain constant for the 4 pixels
                iCBB = 7258  * (Cb - 0x80);
                iCBG = -1409 * (Cb - 0x80);
                iCRG = -2925 * (Cr - 0x80);
                iCRR = 5742  * (Cr - 0x80);
                Y1 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU0] * iQuant1)>>5) & 0x3ff];
                Y1 <<= 12;
                Y2 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU1] * iQuant1)>>5) & 0x3ff];
                Y2 <<= 12;
                Y3 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU2] * iQuant1)>>5) & 0x3ff];
                Y3 <<= 12;
                Y4 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU3] * iQuant1)>>5) & 0x3ff];
                Y4 <<= 12;
                iMCUBlock += 6 * DCTSIZE2;
                if (pJPEG->iOptions & PIL_CONVERT_16BPP)
                {
                    // upper left
                    usPixel = pJPEG->usRangeTableB[((iCBB + Y1) >> 12) & 0x3ff]; // blue pixel
                    usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y1) >> 12) & 0x3ff]; // green pixel
                    usPixel |= pJPEG->usRangeTableR[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    usOutput[x*2] = (unsigned short)usPixel;
                    // upper right
                    usPixel = pJPEG->usRangeTableB[((iCBB + Y2) >> 12) & 0x3ff]; // blue pixel
                    usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y2) >> 12) & 0x3ff]; // green pixel
                    usPixel |= pJPEG->usRangeTableR[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                    usOutput[x*2+1] = (unsigned short)usPixel;
                    // lower left
                    usPixel = pJPEG->usRangeTableB[((iCBB + Y3) >> 12) & 0x3ff]; // blue pixel
                    usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y3) >> 12) & 0x3ff]; // green pixel
                    usPixel |= pJPEG->usRangeTableR[((iCRR + Y3) >> 12) & 0x3ff]; // red pixel
                    usOutput[x*2+lsize] = (unsigned short)usPixel;
                    // lower right
                    usPixel = pJPEG->usRangeTableB[((iCBB + Y4) >> 12) & 0x3ff]; // blue pixel
                    usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y4) >> 12) & 0x3ff]; // green pixel
                    usPixel |= pJPEG->usRangeTableR[((iCRR + Y4) >> 12) & 0x3ff]; // red pixel
                    usOutput[x*2+1+lsize] = (unsigned short)usPixel;
                }
                else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
                {
                    // upper left
                    usPixel = 0xff000000;
                    usPixel |= (pJPEG->cRangeTable2[((iCBB + Y1) >> 12) & 0x3ff] << 16); // blue pixel
                    usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y1) >> 12) & 0x3ff] << 8); // green pixel
                    usPixel |= pJPEG->cRangeTable2[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    ulOutput[x*2] = usPixel;
                    // upper right
                    usPixel = 0xff000000;
                    usPixel |= (pJPEG->cRangeTable2[((iCBB + Y2) >> 12) & 0x3ff] << 16); // blue pixel
                    usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y2) >> 12) & 0x3ff] << 8); // green pixel
                    usPixel |= pJPEG->cRangeTable2[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                    ulOutput[x*2+1] = usPixel;
                    // lower left
                    usPixel = 0xff000000;
                    usPixel |= (pJPEG->cRangeTable2[((iCBB + Y3) >> 12) & 0x3ff]<<16); // blue pixel
                    usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y3) >> 12) & 0x3ff]<<8); // green pixel
                    usPixel |= pJPEG->cRangeTable2[((iCRR + Y3) >> 12) & 0x3ff]; // red pixel
                    ulOutput[x*2+lsize] = usPixel;
                    // lower right
                    usPixel = 0xff000000;
                    usPixel |= (pJPEG->cRangeTable2[((iCBB + Y4) >> 12) & 0x3ff]<<16); // blue pixel
                    usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y4) >> 12) & 0x3ff]<<8); // green pixel
                    usPixel |= pJPEG->cRangeTable2[((iCRR + Y4) >> 12) & 0x3ff]; // red pixel
                    ulOutput[x*2+1+lsize] = usPixel;
                }
                else // 24bpp
                {
                    // upper left
                    cOutput[x*6+0] = pJPEG->cRangeTable2[((iCBB + Y1) >> 12) & 0x3ff]; // blue pixel
                    cOutput[x*6+1] = pJPEG->cRangeTable2[((iCBG + iCRG + Y1) >> 12) & 0x3ff]; // green pixel
                    cOutput[x*6+2] = pJPEG->cRangeTable2[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    // upper right
                    cOutput[x*6+3] = pJPEG->cRangeTable2[((iCBB + Y2) >> 12) & 0x3ff]; // blue pixel
                    cOutput[x*6+4] = pJPEG->cRangeTable2[((iCBG + iCRG + Y2) >> 12) & 0x3ff]; // green pixel
                    cOutput[x*6+5] = pJPEG->cRangeTable2[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                    // lower left
                    cOutput[x*6+0+lsize] = pJPEG->cRangeTable2[((iCBB + Y3) >> 12) & 0x3ff]; // blue pixel
                    cOutput[x*6+1+lsize] = pJPEG->cRangeTable2[((iCBG + iCRG + Y3) >> 12) & 0x3ff]; // green pixel
                    cOutput[x*6+2+lsize] = pJPEG->cRangeTable2[((iCRR + Y3) >> 12) & 0x3ff]; // red pixel
                    // lower right
                    cOutput[x*6+3+lsize] = pJPEG->cRangeTable2[((iCBB + Y4) >> 12) & 0x3ff]; // blue pixel
                    cOutput[x*6+4+lsize] = pJPEG->cRangeTable2[((iCBG + iCRG + Y4) >> 12) & 0x3ff]; // green pixel
                    cOutput[x*6+5+lsize] = pJPEG->cRangeTable2[((iCRR + Y4) >> 12) & 0x3ff]; // red pixel
                }
            }
            else // full or half sized view
            {
                // do the first 4 luminance components
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU0]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU0], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU1]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU1], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU2]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU2], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU3]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU3], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                // first chroma
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU4]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU4], 1, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // Second quantization table
                iMCUBlock += DCTSIZE2;
                
                // second chroma
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU5]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU5], 1, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // Second quantization table
                iMCUBlock += DCTSIZE2;
                
                if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                    JPEGPutMCU22QUARTER(x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                else if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                    JPEGPutMCU22HALF(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                else
                {
//                    if (pJPEG->iOptions & PIL_CONVERT_SIMD)
//                        JPEGPutMCU22_SIMD(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
//                    else
                        JPEGPutMCU22(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                }
            }
        } // for x
        if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
        {
            if (pJPEG->iOptions & PIL_CONVERT_16BPP)
                usOutput += lsize*2;
            else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
                ulOutput += lsize*2;
            else
                cOutput += lsize*2; // skip 2 lines
        }
    } // for y
    return 0;
} /* DrawJPEG22() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DrawJPEG21(...)                                            *
 *                                                                          *
 *  PURPOSE    : Convert the progressive scanned MCUs into an image.        *
 *                                                                          *
 ****************************************************************************/
int DrawJPEG21(PIL_PAGE *inpage, signed short *pMCU, JPEGDATA *pJPEG, unsigned char *cOutput)
{
    int cx, cy, x, y, lsize;
    int iMCUBlock;
    signed short iMCUTemp[DCTSIZE2*4];
    uint32_t Cb,Cr;
    signed int Y1,Y2;
    signed int iQuant1, iQuant2;
    unsigned short *usOutput;
    uint32_t *ulOutput;
    uint32_t usPixel; // define as long to get around compiler innefficiency
    int iCBB, iCBG, iCRR, iCRG;
    
    usOutput = (unsigned short *)cOutput;
    ulOutput = (uint32_t *)cOutput;
    lsize = inpage->iPitch;
    // faster access with reg vars
    iQuant1 = pJPEG->sQuantTable[0];
    iQuant2 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[1].quant_tbl_no];
    
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = (inpage->iWidth + 1)>>1;  // number of MCU blocks
        cy = inpage->iHeight;
        if (pJPEG->iOptions & PIL_CONVERT_16BPP)
            lsize >>= 1; // divide again since we draw it in this function
        else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
            lsize >>= 2; // divide again since we draw it in this function
    }
    else
    {
        cx = (inpage->iWidth + 15)>>4;  // number of MCU blocks
        cy = (inpage->iHeight + 7)>>3;
    }
    iMCUBlock = 0;
    pJPEG->ucMaxACRow = pJPEG->ucMaxACCol = 0xff; // we don't check the max column in progressive JPEGs, so do the whole matrix
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL) // thumbnail view is special
            {
                Cb = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU2] * iQuant2)>>5) & 0x3ff];
                Cr = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU3] * iQuant2)>>5) & 0x3ff];
                // These remain constant for the 4 pixels
                iCBB = 7258  * (Cb - 0x80);
                iCBG = -1409 * (Cb - 0x80);
                iCRG = -2925 * (Cr - 0x80);
                iCRR = 5742  * (Cr - 0x80);
                Y1 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU0] * iQuant1)>>5) & 0x3ff];
                Y1 <<= 12;
                Y2 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU1] * iQuant1)>>5) & 0x3ff];
                Y2 <<= 12;
                iMCUBlock += 4 * DCTSIZE2;
                if (pJPEG->iOptions & PIL_CONVERT_16BPP)
                {
                    // left
                    usPixel = pJPEG->usRangeTableB[((iCBB + Y1) >> 12) & 0x3ff]; // blue pixel
                    usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y1) >> 12) & 0x3ff]; // green pixel
                    usPixel |= pJPEG->usRangeTableR[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    usOutput[x*2] = (unsigned short)usPixel;
                    // right
                    usPixel = pJPEG->usRangeTableB[((iCBB + Y2) >> 12) & 0x3ff]; // blue pixel
                    usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y2) >> 12) & 0x3ff]; // green pixel
                    usPixel |= pJPEG->usRangeTableR[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                    usOutput[x*2+1] = (unsigned short)usPixel;
                }
                else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
                {
                    // left
                    usPixel = 0xff000000;
                    usPixel |= (pJPEG->cRangeTable2[((iCBB + Y1) >> 12) & 0x3ff]<<16); // blue pixel
                    usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y1) >> 12) & 0x3ff]<<8); // green pixel
                    usPixel |= pJPEG->cRangeTable2[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    ulOutput[x*2] = usPixel;
                    // right
                    usPixel = 0xff000000;
                    usPixel |= (pJPEG->cRangeTable2[((iCBB + Y2) >> 12) & 0x3ff]<<16); // blue pixel
                    usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y2) >> 12) & 0x3ff]<<8); // green pixel
                    usPixel |= pJPEG->cRangeTable2[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                    ulOutput[x*2+1] = usPixel;
                }
                else // rgb24
                {
                    // left
                    cOutput[x*6+0] = pJPEG->cRangeTable2[((iCBB + Y1) >> 12) & 0x3ff]; // blue pixel
                    cOutput[x*6+1] = pJPEG->cRangeTable2[((iCBG + iCRG + Y1) >> 12) & 0x3ff]; // green pixel
                    cOutput[x*6+2] = pJPEG->cRangeTable2[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    // right
                    cOutput[x*6+3] = pJPEG->cRangeTable2[((iCBB + Y2) >> 12) & 0x3ff]; // blue pixel
                    cOutput[x*6+4] = pJPEG->cRangeTable2[((iCBG + iCRG + Y2) >> 12) & 0x3ff]; // green pixel
                    cOutput[x*6+5] = pJPEG->cRangeTable2[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                }
            }
            else // full or half sized view
            {
                // do the first 2 luminance components
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU0]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU0], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU1]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU1], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                // first chroma
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU2]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU2], 1, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // Second quantization table
                iMCUBlock += DCTSIZE2;
                
                // second chroma
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU3]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU3], 1, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // Second quantization table
                iMCUBlock += DCTSIZE2;
                
                if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                    JPEGPutMCU21QUARTER(x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                else if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                    JPEGPutMCU21HALF(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                else
                {
 //                   if (pJPEG->iOptions & PIL_CONVERT_SIMD)
 //                       JPEGPutMCU21_SIMD(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
 //                   else
                        JPEGPutMCU21(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                }
            }
        } // for x
        if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
        {
            if (pJPEG->iOptions & PIL_CONVERT_16BPP)
                usOutput += lsize;
            else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
                ulOutput += lsize;
            else
                cOutput += lsize;
        }
    } // for y
    return 0;
} /* DrawJPEG21() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DrawJPEG12(...)                                            *
 *                                                                          *
 *  PURPOSE    : Convert the progressive scanned MCUs into an image.        *
 *                                                                          *
 ****************************************************************************/
int DrawJPEG12(PIL_PAGE *inpage, signed short *pMCU, JPEGDATA *pJPEG, unsigned char *cOutput)
{
    int cx, cy, x, y, lsize;
    int iMCUBlock;
    signed short iMCUTemp[DCTSIZE2*4];
    uint32_t Cb,Cr;
    signed int Y1,Y2;
    signed int iQuant1, iQuant2;
    unsigned short *usOutput;
    uint32_t *ulOutput;
    uint32_t usPixel; // define as long to get around compiler innefficiency
    int iCBB, iCBG, iCRR, iCRG;
    
    usOutput = (unsigned short *)cOutput;
    ulOutput = (uint32_t *)cOutput;
    lsize = inpage->iPitch;
    
    // faster access with reg vars
    iQuant1 = pJPEG->sQuantTable[0];
    iQuant2 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[1].quant_tbl_no];
    
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = inpage->iWidth;  // number of MCU blocks
        cy = (inpage->iHeight + 1)>>1;
        if (pJPEG->iOptions & PIL_CONVERT_16BPP)
            lsize >>= 1; // divide again since we draw it in this function
        else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
            lsize >>= 2; // divide again since we draw it in this function
    }
    else
    {
        cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
        cy = (inpage->iHeight + 15)>>4;
    }
    iMCUBlock = 0;
    pJPEG->ucMaxACRow = pJPEG->ucMaxACCol = 0xff; // we don't check the max column in progressive JPEGs, so do the whole matrix
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL) // thumbnail view is special
            {
                Cb = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU2] * iQuant2)>>5) & 0x3ff];
                Cr = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU3] * iQuant2)>>5) & 0x3ff];
                // These remain constant for the 4 pixels
                iCBB = 7258  * (Cb - 0x80);
                iCBG = -1409 * (Cb - 0x80);
                iCRG = -2925 * (Cr - 0x80);
                iCRR = 5742  * (Cr - 0x80);
                Y1 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU0] * iQuant1)>>5) & 0x3ff];
                Y1 <<= 12;
                Y2 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU1] * iQuant1)>>5) & 0x3ff];
                Y2 <<= 12;
                iMCUBlock += 4 * DCTSIZE2;
                if (pJPEG->iOptions & PIL_CONVERT_16BPP)
                {
                    // upper
                    usPixel = pJPEG->usRangeTableB[((iCBB + Y1) >> 12) & 0x3ff]; // blue pixel
                    usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y1) >> 12) & 0x3ff]; // green pixel
                    usPixel |= pJPEG->usRangeTableR[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    usOutput[x] = (unsigned short)usPixel;
                    // lower
                    usPixel = pJPEG->usRangeTableB[((iCBB + Y2) >> 12) & 0x3ff]; // blue pixel
                    usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y2) >> 12) & 0x3ff]; // green pixel
                    usPixel |= pJPEG->usRangeTableR[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                    usOutput[x+lsize] = (unsigned short)usPixel;
                }
                else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
                {
                    // upper
                    usPixel = 0xff000000;
                    usPixel |= (pJPEG->cRangeTable2[((iCBB + Y1) >> 12) & 0x3ff]<<16); // blue pixel
                    usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y1) >> 12) & 0x3ff]<<8); // green pixel
                    usPixel |= pJPEG->cRangeTable2[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    ulOutput[x] = usPixel;
                    // lower
                    usPixel = 0xff000000;
                    usPixel |= (pJPEG->cRangeTable2[((iCBB + Y2) >> 12) & 0x3ff]<<16); // blue pixel
                    usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y2) >> 12) & 0x3ff]<<8); // green pixel
                    usPixel |= pJPEG->cRangeTable2[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                    ulOutput[x+lsize] = usPixel;
                }
                else // 24bpp
                {
                    // upper
                    cOutput[x*3+0] = pJPEG->cRangeTable2[((iCBB + Y1) >> 12) & 0x3ff]; // blue pixel
                    cOutput[x*3+1] = pJPEG->cRangeTable2[((iCBG + iCRG + Y1) >> 12) & 0x3ff]; // green pixel
                    cOutput[x*3+2] = pJPEG->cRangeTable2[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    // lower
                    cOutput[x*3+0+lsize] = pJPEG->cRangeTable2[((iCBB + Y2) >> 12) & 0x3ff]; // blue pixel
                    cOutput[x*3+1+lsize] = pJPEG->cRangeTable2[((iCBG + iCRG + Y2) >> 12) & 0x3ff]; // green pixel
                    cOutput[x*3+2+lsize] = pJPEG->cRangeTable2[((iCRR + Y2) >> 12) & 0x3ff]; // red pixel
                }
            }
            else // full or half sized view
            {
                // do the first 2 luminance components
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU0]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU0], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU1]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU1], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                // first chroma
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU2]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU2], 1, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // Second quantization table
                iMCUBlock += DCTSIZE2;
                
                // second chroma
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU3]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU3], 1, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // Second quantization table
                iMCUBlock += DCTSIZE2;
                
                if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                    JPEGPutMCU12QUARTER(x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                else if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                    JPEGPutMCU12HALF(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                else
                    JPEGPutMCU12(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
            }
        } // for x
        if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
        {
            if (pJPEG->iOptions & PIL_CONVERT_16BPP)
                usOutput += lsize*2;
            else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
                ulOutput += lsize*2;
            else
                cOutput += lsize * 2; // skip 2 lines
        }
    } // for y
    return 0;
} /* DrawJPEG12() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DrawJPEG11(...)                                            *
 *                                                                          *
 *  PURPOSE    : Convert the progressive scanned MCUs into an image.        *
 *                                                                          *
 ****************************************************************************/
int DrawJPEG11(PIL_PAGE *inpage, signed short *pMCU, JPEGDATA *pJPEG, unsigned char *cOutput)
{
    int cx, cy, x, y, lsize;
    int iMCUBlock;
    signed short iMCUTemp[DCTSIZE2*4];
    uint32_t Cb,Cr, K;
    signed int Y1;
    signed int iQuant1, iQuant2, iQuant3, iQuant4;
    unsigned short *usOutput;
    uint32_t *ulOutput;
    uint32_t usPixel; // define as long to get around compiler innefficiency
    int iCBB, iCBG, iCRR, iCRG;
    
    usOutput = (unsigned short *)cOutput;
    ulOutput = (uint32_t *)cOutput;
    lsize = inpage->iPitch;
    
    // faster access with reg vars
    iQuant1 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[0].quant_tbl_no];
    iQuant2 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[1].quant_tbl_no];
    iQuant3 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[2].quant_tbl_no];
    iQuant4 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[3].quant_tbl_no];
    
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = inpage->iWidth;  // number of MCU blocks
        cy = inpage->iHeight;
        // already adjusted pitch before entering here
        //       if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        //          lsize >>= 1; // divide again since we draw it in this function
        //       else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        //          lsize >>= 2; // divide again since we draw it in this function
    }
    else
    {
        cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
        cy = (inpage->iHeight + 7)>>3;
    }
    iMCUBlock = 0;
    pJPEG->ucMaxACRow = pJPEG->ucMaxACCol = 0xff; // we don't check the max column in progressive JPEGs, so do the whole matrix
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL) // thumbnail view is special
            {
                if (pJPEG->iOptions & PIL_CONVERT_JPEG_RGB)
                {
                    //                Y1 = ((pMCU[iMCUBlock+MCU0] * iQuant1)>>5);
                    //                Cb = ((pMCU[iMCUBlock+MCU1] * iQuant2)>>5);
                    //                Cr = ((pMCU[iMCUBlock+MCU2] * iQuant2)>>5);
                    Y1 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU0] * iQuant1)>>5) & 0x3ff];
                    Cb = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU1] * iQuant2)>>5) & 0x3ff];
                    Cr = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU2] * iQuant3)>>5) & 0x3ff];
                    iMCUBlock += 3 * DCTSIZE2;
                    JPEGPixelRGB(pJPEG, cOutput, x, (unsigned char)Y1, (unsigned char)Cb, (unsigned char)Cr);
                }
                else if (pJPEG->iOptions & PIL_CONVERT_JPEG_YCCK)
                {
                    Y1 = pJPEG->cRangeTable[((pMCU[iMCUBlock + MCU0] * iQuant1) >> 5) & 0x3ff];
                    Cb = pJPEG->cRangeTable[((pMCU[iMCUBlock + MCU1] * iQuant2) >> 5) & 0x3ff];
                    Cr = pJPEG->cRangeTable[((pMCU[iMCUBlock + MCU2] * iQuant3) >> 5) & 0x3ff];
                    K = pJPEG->cRangeTable[((pMCU[iMCUBlock + MCU3] * iQuant4) >> 5) & 0x3ff];
                    iMCUBlock += 4 * DCTSIZE2;
                    JPEGPixelYCCK(pJPEG, cOutput, x, (unsigned char) Y1, (unsigned char) Cb, (unsigned char) Cr, (unsigned char)K);
                }
                else // YCrCb
                {
                    Cb = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU1] * iQuant2)>>5) & 0x3ff];
                    Cr = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU2] * iQuant2)>>5) & 0x3ff];
                    // These remain constant for the 4 pixels
                    iCBB = 7258  * (Cb - 0x80);
                    iCBG = -1409 * (Cb - 0x80);
                    iCRG = -2925 * (Cr - 0x80);
                    iCRR = 5742  * (Cr - 0x80);
                    Y1 = pJPEG->cRangeTable[((pMCU[iMCUBlock+MCU0] * iQuant1)>>5) & 0x3ff];
                    Y1 <<= 12;
                    iMCUBlock += 3 * DCTSIZE2;
                    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
                    {
                        usPixel = pJPEG->usRangeTableB[((iCBB + Y1) >> 12) & 0x3ff]; // blue pixel
                        usPixel |= pJPEG->usRangeTableG[((iCBG + iCRG + Y1) >> 12) & 0x3ff]; // green pixel
                        usPixel |= pJPEG->usRangeTableR[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                        usOutput[x] = (unsigned short)usPixel;
                    }
                    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
                    {
                        usPixel = 0xff000000;
                        usPixel |= (pJPEG->cRangeTable2[((iCBB + Y1) >> 12) & 0x3ff]<<16); // blue pixel
                        usPixel |= (pJPEG->cRangeTable2[((iCBG + iCRG + Y1) >> 12) & 0x3ff]<<8); // green pixel
                        usPixel |= pJPEG->cRangeTable2[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                        ulOutput[x] = usPixel;
                    }
                    else // 24bpp
                    {
                        cOutput[x*3+0] = pJPEG->cRangeTable2[((iCBB + Y1) >> 12) & 0x3ff]; // blue pixel
                        cOutput[x*3+1] = pJPEG->cRangeTable2[((iCBG + iCRG + Y1) >> 12) & 0x3ff]; // green pixel
                        cOutput[x*3+2] = pJPEG->cRangeTable2[((iCRR + Y1) >> 12) & 0x3ff]; // red pixel
                    }
                }
            }
            else // full or half sized view
            {
                // do the luminance component
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU0]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU0], pJPEG->JPCI[0].quant_tbl_no, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                
                // first chroma
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU1]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU1], pJPEG->JPCI[1].quant_tbl_no, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // Second quantization table
                iMCUBlock += DCTSIZE2;
                
                // second chroma
                JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU2]);
                JPEGIDCT(pJPEG, &iMCUTemp[MCU2], pJPEG->JPCI[2].quant_tbl_no, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // Second quantization table
                iMCUBlock += DCTSIZE2;
                
                if (pJPEG->ucNumComponents == 4) // CMYK
                {
                    JPEGFixOrder(&pMCU[iMCUBlock], &iMCUTemp[MCU3]);
                    JPEGIDCT(pJPEG, &iMCUTemp[MCU3], pJPEG->JPCI[3].quant_tbl_no, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8)));
                    iMCUBlock += DCTSIZE2;
                }
                if (pJPEG->iOptions & PIL_CONVERT_JPEG_RGB) // special case for RGB colorspace
                {
                    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                        JPEGPutMCURGBHALF(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                    else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                        JPEGPutMCURGBQUARTER(x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                    else
                        JPEGPutMCURGB(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG);
                }
                else if (pJPEG->ucNumComponents == 4) // YCCK or CMYK
                {
                    if (pJPEG->iOptions & PIL_CONVERT_JPEG_YCCK)
                        JPEGPutMCUYCCK(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG);
                    else
                        JPEGPutMCUCMYK(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG);
                }
                else // normal YCbCr colorspace
                {
                    if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                        JPEGPutMCU11QUARTER(x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                    else if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                        JPEGPutMCU11HALF(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                    else
                    {
//                        if (pJPEG->iOptions & PIL_CONVERT_SIMD)
//                            JPEGPutMCU11_SIMD(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
//                        else
                            JPEGPutMCU11(inpage, x, y, lsize, iMCUTemp, cOutput, pJPEG); // lay down MCU in output image
                    }
                }
            }
        } // for x
        if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
        {
            usOutput += lsize/2;
            ulOutput += lsize/4;
            cOutput += lsize;
        }
    } // for y
    return 0;
} /* DrawJPEG11() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : DrawJPEGGrayP(...)                                         *
 *                                                                          *
 *  PURPOSE    : Convert the progressive scanned MCUs into an image.        *
 *                                                                          *
 ****************************************************************************/
int DrawJPEGGrayP(PIL_PAGE *inpage, signed short *pMCU, JPEGDATA *pJPEG, unsigned char *cOutput)
{
    int cx, cy, x, y, lsize;
    int iMCUBlock;
    signed short pMCUTemp[DCTSIZE2];
    signed int Y1;
    signed int iQuant1;
    unsigned char *pDest;
    
    pDest = cOutput;
//    lsize = inpage->iPitch;
    
    // faster access with reg vars
    iQuant1 = pJPEG->sQuantTable[0];
    
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = inpage->iWidth;  // number of MCU blocks
        cy = inpage->iHeight;
    }
    else
    {
        cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
        cy = (inpage->iHeight + 7)>>3;
    }
    iMCUBlock = 0;
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL) // thumbnail view is special
            {
                Y1 = pJPEG->cRangeTable[((pMCU[iMCUBlock] * iQuant1)>>5) & 0x3ff];
                iMCUBlock += DCTSIZE2;
                pDest[x] = (unsigned char)Y1;
            }
            else // full or half sized view
            {
                JPEGFixOrder(&pMCU[iMCUBlock], pMCUTemp);
                JPEGIDCT(pJPEG, pMCUTemp, 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                iMCUBlock += DCTSIZE2;
                // copy macroblock to dest image
                JPEGPutMCUGray(inpage, (unsigned char *)pMCUTemp, cOutput, pJPEG, x, y, lsize);
            }
        } // for x
        if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
        {
            pDest += lsize;
        }
    } // for y
    return 0;
} /* DrawJPEGGrayP() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetJPEG22P(...)                                            *
 *                                                                          *
 *  PURPOSE    : Decode loop for color image subsampled in both directions. *
 *               2:2 subsampling for both chrominance components which will *
 *               be 4Y's, 1Cr, 1Cb.  Special procedure for Progressive mode.*
 *                                                                          *
 ****************************************************************************/
int GetJPEG22P(PIL_PAGE *inpage, int *iOff, int *iBit, signed short *pMCU, JPEGDATA *pJPEG)
{
    int cx, cy, x, y;
    signed int iDCPred0, iDCPred1, iDCPred2;
    int iSkip; // number of blocks to skip when we get an EOB (end of band) code
    int iErr;
    unsigned char  cACTable0, cDCTable0, cACTable1, cDCTable1, cACTable2, cDCTable2;
    int iMCUPosition; // MCU position in the total set for the image
    
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    
    //    lsize = PILCalcSize(inpage->iWidth, inpage->cBitsperpixel);
    //    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
    //       lsize = PILCalcSize((inpage->iWidth+1)/2, inpage->cBitsperpixel);
    iDCPred0 = iDCPred1 = iDCPred2 = 0;
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = (inpage->iWidth +1) >> 1;
        if (pJPEG->ucComponentsInScan == 1 && pJPEG->JPCI[0].component_needed) // special case for encoding of only Luma blocks
            cy = inpage->iHeight;
        else
            cy = (inpage->iHeight + 1)>>1;
    }
    else
    {
        cx = (inpage->iWidth + 15)>>4;  // number of MCU blocks
        if (pJPEG->ucComponentsInScan == 1 && pJPEG->JPCI[0].component_needed) // special case for encoding of only Luma blocks
            cy = (inpage->iHeight + 7) >> 3;
        else
            cy = (inpage->iHeight + 15)>>4;
    }
    //    iQuant1 = pJPEG->sQuantTable[0];
    //    iQuant2 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[1].quant_tbl_no];
    iMCUPosition = 0;
    iSkip = 0; // start with no EOB RUN skipped blocks
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (*iOff > pJPEG->iDataSize+4)  // went past end of data
                return PIL_ERROR_DECOMP;
            if (pJPEG->JPCI[0].component_needed) // if this is included in the scan
            {
                pJPEG->pHuffAC = pJPEG->huffac[cACTable0];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable0]; // use the first huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
                // do the first 4 luminance components
                if (pJPEG->ucComponentsInScan == 3) // normal interleaved scan
                {
                    iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU0], pJPEG, &iDCPred0, &iSkip);
                    iErr |= JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU1], pJPEG, &iDCPred0, &iSkip);
                    iErr |= JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2) + MCU2], pJPEG, &iDCPred0, &iSkip);
                    iErr |= JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2) + MCU3], pJPEG, &iDCPred0, &iSkip);
                }
                else // when only one component in scan it is not interleaved (1 block per MCU)
                {
                    if (y & 1) // odd lines do bottom 2 lumas
                    {
                        iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU2], pJPEG, &iDCPred0, &iSkip);
                        if ((x * 16 + 8) < inpage->iWidth) // don't go beyond right edge in 1-block-per-mcu-mode
                            iErr |= JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU3], pJPEG, &iDCPred0, &iSkip);
                    }
                    else // even lines do top 2 lumas
                    {
                        iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU0], pJPEG, &iDCPred0, &iSkip);
                        if ((x * 16 + 8) < inpage->iWidth) // don't go beyond right edge in 1-block-per-mcu-mode
                            iErr |= JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU1], pJPEG, &iDCPred0, &iSkip);
                    }
                }
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 4; // 4 Luma blocks
            if (pJPEG->JPCI[1].component_needed) // if this is included in the scan
            {
                // first chroma
                pJPEG->pHuffAC = pJPEG->huffac[cACTable1];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable1]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred1, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // 1 chroma
            if (pJPEG->JPCI[2].component_needed) // if this is included in the scan
            {
                // second chroma
                pJPEG->pHuffAC = pJPEG->huffac[cACTable2];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable2]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred2, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // 1 chroma
            
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    iSkip = 0; // reset EOB run
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                    if (*iBit & 7)
                    {
                        //                   *iBit += (8 - (*iBit & 7));
                        *iBit = 0;  // new restart interval starts on byte boundary
                        (*iOff)++;
                    }
                }
            }
        } // for X
        // when only luma components, it progresses like a luma-only scan (no subsampling MCU groups)
        if (pJPEG->ucComponentsInScan == 1 && pJPEG->JPCI[0].component_needed)
        {
            if (!(y & 1)) // even lines skip back 1 line
                iMCUPosition -= 6 * cx;
        }
    }
    return 0;
} /* GetJPEG22P() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetJPEG12P(...)                                            *
 *                                                                          *
 *  PURPOSE    : Decode loop for color image subsampled vertically.         *
 *                                                                          *
 ****************************************************************************/
int GetJPEG12P(PIL_PAGE *inpage, int *iOff, int *iBit, signed short *pMCU, JPEGDATA *pJPEG)
{
    int cx, cy, x, y;
    signed int iDCPred0, iDCPred1, iDCPred2;
    int iSkip; // number of blocks to skip when we get an EOB (end of band) code
    int iErr;
    unsigned char  cACTable0, cDCTable0, cACTable1, cDCTable1, cACTable2, cDCTable2;
    int iMCUPosition; // MCU position in the total set for the image
    
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    
    //    lsize = PILCalcSize(inpage->iWidth, inpage->cBitsperpixel);
    //    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
    //       lsize = PILCalcSize((inpage->iWidth+1)/2, inpage->cBitsperpixel);
    iDCPred0 = iDCPred1 = iDCPred2 = 0;
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = inpage->iWidth;
        if (pJPEG->ucComponentsInScan == 1 && pJPEG->JPCI[0].component_needed) // special case for encoding of only Luma blocks
            cy = inpage->iHeight;
        else
            cy = (inpage->iHeight + 1)>>1;
    }
    else
    {
        cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
        if (pJPEG->ucComponentsInScan == 1 && pJPEG->JPCI[0].component_needed) // special case for encoding of only Luma blocks
            cy = (inpage->iHeight + 7) >> 3;
        else
            cy = (inpage->iHeight + 15)>>4;
    }
    //    iQuant1 = pJPEG->sQuantTable[0];
    //    iQuant2 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[1].quant_tbl_no];
    iMCUPosition = 0;
    iSkip = 0; // start with no EOB RUN skipped blocks
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (*iOff > pJPEG->iDataSize)  // went past end of data
                return PIL_ERROR_DECOMP;
            if (pJPEG->JPCI[0].component_needed) // if this is included in the scan
            {
                pJPEG->pHuffAC = pJPEG->huffac[cACTable0];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable0]; // use the first huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
                // do the first 2 luminance components
                if (pJPEG->ucComponentsInScan == 3) // normal interleaved scan
                {
                    iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU0], pJPEG, &iDCPred0, &iSkip);
                    iErr |= JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU1], pJPEG, &iDCPred0, &iSkip);
                }
                else // when only one component in scan it is not interleaved (1 block per MCU)
                {
                    if (y & 1) // odd lines do bottom luma
                    {
                        iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU1], pJPEG, &iDCPred0, &iSkip);
                    }
                    else // even lines do top luma
                    {
                        iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU0], pJPEG, &iDCPred0, &iSkip);
                    }
                }
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 2; // 2 Luma blocks
            if (pJPEG->JPCI[1].component_needed) // if this is included in the scan
            {
                // first chroma
                pJPEG->pHuffAC = pJPEG->huffac[cACTable1];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable1]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred1, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // 1 chroma
            if (pJPEG->JPCI[2].component_needed) // if this is included in the scan
            {
                // second chroma
                pJPEG->pHuffAC = pJPEG->huffac[cACTable2];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable2]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred2, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // 1 chroma
            
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    iSkip = 0; // reset EOB run
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                    if (*iBit & 7)
                    {
                        //                   *iBit += (8 - (*iBit & 7));
                        *iBit = 0;  // new restart interval starts on byte boundary
                        (*iOff)++;
                    }
                }
            }
        } // for X
        // when only luma components, it progresses like a luma-only scan (no subsampling MCU groups)
        if (pJPEG->ucComponentsInScan == 1 && pJPEG->JPCI[0].component_needed)
        {
            if (!(y & 1)) // even lines skip back 1 line
                iMCUPosition -= 4 * cx;
        }
    }
    return 0;
} /* GetJPEG12P() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetJPEG21P(...)                                            *
 *                                                                          *
 *  PURPOSE    : Decode loop for color image subsampled horizontally.       *
 *                                                                          *
 ****************************************************************************/
int GetJPEG21P(PIL_PAGE *inpage, int *iOff, int *iBit, signed short *pMCU, JPEGDATA *pJPEG)
{
    int cx, cy, x, y;
    signed int iDCPred0, iDCPred1, iDCPred2;
    int iSkip; // number of blocks to skip when we get an EOB (end of band) code
    int iErr;
    unsigned char  cACTable0, cDCTable0, cACTable1, cDCTable1, cACTable2, cDCTable2;
    int iMCUPosition; // MCU position in the total set for the image
    int bSpecialCase;
    
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    
    //    lsize = PILCalcSize(inpage->iWidth, inpage->cBitsperpixel);
    //    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
    //       lsize = PILCalcSize((inpage->iWidth+1)/2, inpage->cBitsperpixel);
    // when only luma components, it progresses like a luma-only scan (no subsampling MCU groups)
    // we only need to worry when the image is an odd number of 8 pixel blocks because it will be off by 1 compared to 16-pixel blocks
    bSpecialCase = (pJPEG->JPCI[0].component_needed && pJPEG->ucComponentsInScan == 1 && (inpage->iWidth & 15) <= 8);
    iDCPred0 = iDCPred1 = iDCPred2 = 0;
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = (inpage->iWidth +1) >> 1;
        cy = inpage->iHeight;
    }
    else
    {
        cx = (inpage->iWidth + 15) >> 4;  // number of MCU blocks
        cy = (inpage->iHeight + 7) >> 3;
    }
    //    iQuant1 = pJPEG->sQuantTable[0];
    //    iQuant2 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[1].quant_tbl_no];
    iMCUPosition = 0;
    iSkip = 0; // start with no EOB RUN skipped blocks
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (*iOff > pJPEG->iDataSize)  // went past end of data
                return PIL_ERROR_DECOMP;
            if (pJPEG->JPCI[0].component_needed) // if this is included in the scan
            {
                pJPEG->pHuffAC = pJPEG->huffac[cACTable0];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable0]; // use the first huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
                // do the first 2 luminance components
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU0], pJPEG, &iDCPred0, &iSkip);
                if (x != cx - 1 || !bSpecialCase)
                    iErr |= JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2) + MCU1], pJPEG, &iDCPred0, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 2; // 2 Luma blocks
            if (pJPEG->JPCI[1].component_needed) // if this is included in the scan
            {
                // first chroma
                pJPEG->pHuffAC = pJPEG->huffac[cACTable1];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable1]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred1, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // 1 chroma
            if (pJPEG->JPCI[2].component_needed) // if this is included in the scan
            {
                // second chroma
                pJPEG->pHuffAC = pJPEG->huffac[cACTable2];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable2]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred2, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // 1 chroma
            
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    iSkip = 0; // reset EOB run
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                    if (*iBit & 7)
                    {
                        //                   *iBit += (8 - (*iBit & 7));
                        *iBit = 0;  // new restart interval starts on byte boundary
                        (*iOff)++;
                    }
                }
            }
        } // for X
        //	   if (pJPEG->JPCI[0].component_needed && !pJPEG->JPCI[1].component_needed)
        //		   iMCUPosition += 2;
    } // for Y
    return 0;
} /* GetJPEG21P() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetJPEGGrayP(...)                                          *
 *                                                                          *
 *  PURPOSE    : Decode loop for grayscale progressive images.              *
 *                                                                          *
 ****************************************************************************/
int GetJPEGGrayP(PIL_PAGE *inpage, int *iOff, int *iBit, signed short *pMCU, JPEGDATA *pJPEG)
{
    int cx, cy, x, y;
    signed int iDCPred0;
    int iSkip; // number of blocks to skip when we get an EOB (end of band) code
    int iErr;
    int iMCUPosition; // MCU position in the total set for the image
    
    //    lsize = PILCalcSize(inpage->iWidth, inpage->cBitsperpixel);
    //    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
    //       lsize = PILCalcSize((inpage->iWidth+1)/2, inpage->cBitsperpixel);
    iDCPred0 = 0;
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = inpage->iWidth;
        cy = inpage->iHeight;
    }
    else
    {
        cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
        cy = (inpage->iHeight + 7) >> 3;
    }
    //    iQuant1 = pJPEG->sQuantTable[0];
    iMCUPosition = 0;
    iSkip = 0; // start with no EOB RUN skipped blocks
    pJPEG->pHuffAC = pJPEG->huffac[0];
    pJPEG->pHuffDC = pJPEG->huffdc[0]; // use the first huff table
    pJPEG->pHuffACFast = pJPEG->huffacFast[0];
    pJPEG->pHuffDCFast = pJPEG->huffdcFast[0];
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (*iOff > pJPEG->iDataSize)  // went past end of data
                return PIL_ERROR_DECOMP;
            iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred0, &iSkip);
            iMCUPosition += 1;
            if (iErr)
                return iErr; // decoding error, stop
            
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    iSkip = 0; // reset EOB run
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = 0; // reset DC predictors
                    if (*iBit & 7)
                    {
                        //                   *iBit += (8 - (*iBit & 7));
                        *iBit = 0;  // new restart interval starts on byte boundary
                        (*iOff)++;
                    }
                }
            }
        } // for X
    }
    return 0;
} /* GetJPEGGrayP() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetJPEG11P(...)                                            *
 *                                                                          *
 *  PURPOSE    : Decode loop for color image with no subsampling.           *
 *                                                                          *
 ****************************************************************************/
int GetJPEG11P(PIL_PAGE *inpage, int *iOff, int *iBit, signed short *pMCU, JPEGDATA *pJPEG)
{
    int cx, cy, x, y;
    signed int iDCPred0, iDCPred1, iDCPred2, iDCPred3;
    int iSkip; // number of blocks to skip when we get an EOB (end of band) code
    int iErr;
    unsigned char  cACTable0, cDCTable0, cACTable1, cDCTable1, cACTable2, cDCTable2, cACTable3, cDCTable3;
    int iMCUPosition; // MCU position in the total set for the image
    
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    cDCTable3 = pJPEG->JPCI[3].dc_tbl_no;
    cACTable3 = pJPEG->JPCI[3].ac_tbl_no;
    
    //    lsize = PILCalcSize(inpage->iWidth, inpage->cBitsperpixel);
    //    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
    //       lsize = PILCalcSize((inpage->iWidth+1)/2, inpage->cBitsperpixel);
    iDCPred0 = iDCPred1 = iDCPred2 = iDCPred3 = 0;
    if (pJPEG->iOptions & PIL_CONVERT_THUMBNAIL)
    {
        cx = inpage->iWidth;
        cy = inpage->iHeight;
    }
    else
    {
        cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
        cy = (inpage->iHeight + 7) >> 3;
    }
    //    iQuant1 = pJPEG->sQuantTable[0];
    //    iQuant2 = pJPEG->sQuantTable[DCTSIZE2*pJPEG->JPCI[1].quant_tbl_no];
    iMCUPosition = 0;
    iSkip = 0; // start with no EOB RUN skipped blocks
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (*iOff > pJPEG->iDataSize)  // went past end of data
                return PIL_ERROR_DECOMP;
            if (pJPEG->JPCI[0].component_needed) // if this is included in the scan
            {
                pJPEG->pHuffAC = pJPEG->huffac[cACTable0];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable0]; // use the first huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
                // do luminance component
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)+MCU0], pJPEG, &iDCPred0, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // 1 Luma blocks
            if (pJPEG->JPCI[1].component_needed) // if this is included in the scan
            {
                // first chroma
                pJPEG->pHuffAC = pJPEG->huffac[cACTable1];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable1]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred1, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // 1 chroma
            if (pJPEG->JPCI[2].component_needed) // if this is included in the scan
            {
                // second chroma
                pJPEG->pHuffAC = pJPEG->huffac[cACTable2];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable2]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred2, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            iMCUPosition += 1; // second chroma
            if (pJPEG->JPCI[3].component_needed) // if this is included in the scan
            {
                // K
                pJPEG->pHuffAC = pJPEG->huffac[cACTable3];
                pJPEG->pHuffDC = pJPEG->huffdc[cDCTable3]; // use the second huff table
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable3];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable3];
                iErr = JPEGDecodeMCU_P(inpage->pData, iOff, iBit, &pMCU[(iMCUPosition*DCTSIZE2)], pJPEG, &iDCPred3, &iSkip);
                if (iErr)
                    return iErr; // decoding error, stop
            }
            if (4 == pJPEG->ucNumComponents)
            {
                iMCUPosition += 1; // 1 K
            }
            
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    iSkip = 0; // reset EOB run
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = iDCPred3 = 0; // reset DC predictors
                    if (*iBit & 7)
                    {
                        //                   *iBit += (8 - (*iBit & 7));
                        *iBit = 0;  // new restart interval starts on byte boundary
                        (*iOff)++;
                    }
                }
            }
        } // for X
    }
    return 0;
} /* GetJPEG11P() */
#endif // JPEG_PROGRESSIVE

/***************************************************************************
 *                                                                          *
 *  FUNCTION   : PILLosslessDecode(...)                                     *
 *                                                                          *
 *  PURPOSE    : Decode one line of Huffman compressed (DC-only) image      *
 *                                                                          *
 ****************************************************************************/
int PILLosslessDecode(unsigned short *pOut, BUFFERED_BITS *bb, int iWidth, unsigned char *pFast)
{
#ifdef _64BITS
    uint64_t ulCode;
    uint64_t ulBits;
#else
    uint32_t ulCode;
    uint32_t ulBits;
#endif
    int x, ulBitOff;
    unsigned char *pBuf, *pEnd, ucHuff;
    signed char cCoeff;
    int iErr = 0;
    
    // keep BUFFERED_BITS structure in local vars so compiler can optimize register usage
    ulBits = bb->ulBits;
    ulBitOff = (int)bb->ulBitOff;
    pBuf = bb->pBuf;
    pEnd = &pBuf[bb->ulDataSize];
    for (x = 0; x<iWidth; x++)
    {
        if (ulBitOff >(REGISTER_WIDTH - 15)) // need to get more data
        {
            if (pBuf >= pEnd) // past end of buffer, stop
                break;
            pBuf += (ulBitOff >> 3);
            ulBitOff &= 7;
#ifdef _64BITS
            ulBits = MOTOEXTRALONG(pBuf);
#else // 32bits
            ulBits = MOTOLONG(pBuf);
#endif // _64BITS
        }
        //          ulCode = (bb->ulBits >> (REGISTER_WIDTH - 13 - bb->ulBitOff)) & 0x1fff; // get as lower 13 bits
        ulCode = ulBits << ulBitOff; // shift everything up to the "top" of the register
        ulCode >>= (REGISTER_WIDTH - 13); // keep the lower 13 bits
        if (ulCode >= 0x1f00) // it's a long code
            ulCode = (ulCode & 0xff) + 0x80; // point to long table and trim to 8-bits
        else
            ulCode >>= 7; // it's a short code, use first 6 bits only
        ucHuff = pFast[ulCode]; // get the length+code
        cCoeff = pFast[ulCode + 512]; // get pre-calculated coeff (if available)
        if (ucHuff == 0) // invalid code
        {
            iErr = PIL_ERROR_DECOMP;
            goto lossless_exit;
        }
        else if (ucHuff == 255) // special case for length 16
        {
            //			ucHuff = 16;
            ulBitOff += pFast[384];
            ulCode = 32768; // special value
            ucHuff = 0; // no extra bits
        }
        else
        {
            ulBitOff += (ucHuff >> 4); // add the Huffman length
            ucHuff &= 0xf; // get the actual code (SSSS)
        }
        if (ucHuff) // if there is a change to the DC value
        { // get the 'extra' bits
            if (cCoeff)
            {
                ulCode = (uint32_t) (int32_t) cCoeff;
            }
            else
            {
                if (ulBitOff > (REGISTER_WIDTH - 17)) // need to grab more bytes to nibble on
                {
                    pBuf += (ulBitOff >> 3);
                    ulBitOff &= 7;
#ifdef _64BITS
                    ulBits = MOTOEXTRALONG(pBuf);
#else // 32bits
                    ulBits = MOTOLONG(pBuf);
#endif // _64BITS
                }
                //				if (ucHuff == 16)
                //				{
                //					ulCode = 32768; // special value
                //					ucHuff = 0; // no extra bits
                //				}
                //				else
                {
                    ulCode = ulBits << ulBitOff;
                    if (!(ulCode & TOP_BIT)) // test for negative (top bit == 0)
                    {
                        ulCode >>= (REGISTER_WIDTH - ucHuff);
                        ulCode -= MAX_VALUE >> (REGISTER_WIDTH - ucHuff);
                    }
                    else // positive result
                    {
                        ulCode >>= (REGISTER_WIDTH - ucHuff);
                    }
                }
                ulBitOff += ucHuff; // add bit length
            }
        }
        else
        {
            ulCode = 0; // zero value (no extra bits)
        }
        *pOut++ = (unsigned short) ulCode; // store the delta value
    } // for x
lossless_exit:
    bb->ulBits = ulBits;
    bb->ulBitOff = ulBitOff;
    bb->pBuf = pBuf;
    bb->ulDataSize = (uint32_t)(pEnd - pBuf);
    return iErr;
} /* PILLosslessDecode() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILLosslessFilter(...)                                     *
 *                                                                          *
 *  PURPOSE    : Defilter 16-bit JPEG lossless pixel data                   *
 *                                                                          *
 *      ---------   Predicted pixel X is derived from neighboring           *
 *      | C | B |   pixels A, B, C                                          *
 *      +---+---+                                                           *
 *      | A | X |                                                           *
 *      +---+---+                                                           *
 ****************************************************************************/
void PILLosslessFilter(unsigned short *pCurrent, unsigned short *pPrevious, int iWidth, unsigned short usPredictor, unsigned char ucPredictor)
{
    unsigned short *pC, *pP, Ra;
    int x;
    
    pC = pCurrent;
    pP = pPrevious;
    Ra = usPredictor;
    
    switch (ucPredictor)
    {
        case 0: // no prediction
            break;
        case 1: // Ra
            x = 0;
#ifdef BOGUS
        {
            __m128i xmmIn, xmmOut;
            __m128i xmmIn_new;
            xmmOut = _mm_set1_epi16(Ra);
            // pre-load input data to unroll the loop 1x
            xmmIn = _mm_loadu_si128((__m128i*)&pC[0]);
            while (x + 7 < outpage->iWidth)
            { // pre-load for next time through the loop
                xmmIn_new = _mm_loadu_si128((__m128i*)&pC[8]);
                xmmIn = _mm_add_epi16(_mm_slli_si128(xmmIn, 8), xmmIn);
                xmmOut = _mm_unpacklo_epi16(xmmOut, xmmOut); // replicate the data to all cells
                xmmIn = _mm_add_epi16(_mm_slli_si128(xmmIn, 4), xmmIn);
                xmmOut = _mm_shuffle_epi32(xmmOut, 0);
                xmmIn = _mm_add_epi16(_mm_slli_si128(xmmIn, 2), xmmIn);
                xmmOut = _mm_add_epi16(xmmOut, xmmIn); // done
                _mm_storeu_si128((__m128i*)&pC[0], xmmOut);
                xmmOut = _mm_srli_si128(xmmOut, 14); // re-use the last word written for the next iteration
                xmmIn = xmmIn_new;
                pC += 8;
                x += 8;
            }
        }
#endif
            // handle any remaining pixels
            for (; x<iWidth; x++)
            {
                Ra += *pC;
                *pC++ = Ra;
            }
            break;
        case 2: // Rb
            for (x = 0; x<iWidth; x++)
            {
                Ra = *pC + *pP;
                *pC++ = Ra;
                pP++;
            }
            break;
        case 3: // Rc
            pC++;
            pP++;
            for (x = 1; x<iWidth; x++)
            {
                Ra = *pC + pP[-1];
                *pC++ = Ra;
                pP++;
            }
            break;
        case 4: // Ra+Rb-Rc
            Ra = *pC + Ra + *pP++;
            *pC++ = Ra;
            for (x = 1; x<iWidth; x++)
            {
                Ra = *pC + Ra - pP[-1];
                *pC++ = Ra;
                pP++;
            }
            break;
        case 5: // Ra+((Rb-Rc)/2)
            Ra = *pC + Ra - (*pP) / 2;
            *pC++ = Ra;
            pP++;
            for (x = 1; x<iWidth; x++)
            {
                Ra = *pC + Ra + (pP[0] - pP[-1]) / 2;
                *pC++ = Ra;
                pP++;
            }
            break;
        case 6: // Rb+((Ra-Rc)/2)
            Ra = *pC + *pP + Ra / 2;
            *pC++ = Ra;
            pP++;
            for (x = 1; x<iWidth; x++)
            {
                Ra = *pC + pP[0] + (Ra - pP[-1]) / 2;
                *pC++ = Ra;
                pP++;
            }
            break;
        case 7: // (Ra+Rb)/2
            for (x = 0; x<iWidth; x++)
            {
                Ra = *pC + ((Ra + *pP) >> 1);
                *pC++ = Ra;
                pP++;
            }
            break;
    } // switch on ucPredictor
} /* PILLosslessFilter() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetJPEGLossless(...)                                       *
 *                                                                          *
 *  PURPOSE    : Decode loop for JPEG images with lossless Huffman encoding *
 *                                                                          *
 *      ---------   Predicted pixel X is derived from neighboring           *
 *      | C | B |   pixels A, B, C                                          *
 *      +---+---+                                                           *
 *      | A | X |                                                           *
 *      +---+---+                                                           *
 ****************************************************************************/
int GetJPEGLossless(PIL_PAGE *outpage, BUFFERED_BITS *bb, JPEGDATA *pJPEG)
{
    int iErr = 0;
    int y;
    unsigned char ucPredictor;
    unsigned char *pFast;
    unsigned short Ra;
    unsigned short *pTempLine, *pCurrent, *pPrevious;
    
    pFast = (unsigned char *)pJPEG->huffdcFast[pJPEG->JPCI[0].dc_tbl_no];
    pTempLine = (unsigned short *)outpage->pData; // we already allocated a buffer for 16-bit output
    ucPredictor = 1; // first line must use this predictor
    Ra = 1 << (pJPEG->ucBitsPerSample - 1); // starting prediction value
    pPrevious = pCurrent = pTempLine;
    for (y = 0; y<outpage->iHeight && iErr == 0; y++) // loop through all scanlines
    {
        iErr = PILLosslessDecode(pCurrent, bb, outpage->iWidth, pFast); // decode the samples
        //	   iErr = X64LOSSLESSDECODE(pCurrent, bb, outpage->iWidth, pFast); // decode the samples
        PILLosslessFilter(pCurrent, pPrevious, outpage->iWidth, Ra, ucPredictor);
        Ra = pCurrent[0]; // column 0 uses the pixel above it as the starting predictor
        ucPredictor = (unsigned char)pJPEG->iScanStart;
        pPrevious = pCurrent;
        pCurrent = &pTempLine[(y+1) * outpage->iWidth];
	   } // for y
    
    if (y < outpage->iHeight) // ran out of data early
    {
        iErr = PIL_ERROR_DECOMP;
    }
    // Do default window/level adjustment
    if (iErr == 0)
    {
//        outpage->lUser = (void *) outpage->pData; // keep the raw pixel data
        outpage->cBitsperpixel = 8; // always gets converted to 8-bpp grayscale
//        outpage->iPitch = PILCalcSize(outpage->iWidth, 8);
//        outpage->cBppStored = 16;
//        outpage->pData = (unsigned char *) PILIOAlloc(outpage->iPitch * outpage->iHeight);
//        if (outpage->pData == NULL)
//            return PIL_ERROR_MEMORY;
//        if (outpage->iWindowWidth == 0) // figure out the window/level from the pixel values
//            PILCalcDICOMRange(outpage);
//        PILRenderDICOM(outpage, outpage->iWindowWidth, outpage->iWindowCenter);
    }
    return iErr;
} /* GetJPEGLossless() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILDecodeJPEGThumbSlice(...)                               *
 *                                                                          *
 *  PURPOSE    : Decode loop for JPEG images to be loaded as a thumbnail.   *
 *               The DC values from each MCU are used to make pixels.       *
 *                                                                          *
 ****************************************************************************/
void PILDecodeJPEGThumbSlice(void *pInStruct)
{
    int cx, cy, x, y, lsize = 0;
    uint32_t Cb,Cr, K;
    JPEG_SLICE *pSlice;
    JPEGDATA *pJPEG, *pMiniJPEG;
    int *iDummy[32]; // need to create a dummy JPEGDATA structure to swap Huffman table pointers for each thread
    BUFFERED_BITS *bb, bbstruct;
    PIL_PAGE inpage;
    unsigned char *cOutput;
    signed int Y1, Y2, Y3, Y4;
    signed int iDCPred0, iDCPred1, iDCPred2, iDCPred3;
    signed int iQuant1, iQuant2, iQuant3, iQuant4;
    int iErr;
    unsigned char cACTable0, cDCTable0, cACTable1, cDCTable1, cACTable2, cDCTable2, cDCTable3, cACTable3;
    
    // Prepare data from slice structure
    pSlice = (JPEG_SLICE *) pInStruct;
    pJPEG = pSlice->pJPEG;
    pSlice->uiResCount = pSlice->uiResInterval;
    inpage.iWidth = pSlice->uiWidth;
    inpage.iHeight = pSlice->uiHeight;
//    inpage.iPitch = pSlice->uiPitch;
    pMiniJPEG = (JPEGDATA *) &iDummy[0];
    pMiniJPEG->b11Bit = pJPEG->b11Bit;
    pMiniJPEG->iOptions = pJPEG->iOptions;
    bb = &bbstruct;
    bbstruct.pBuf = pSlice->pData;
    bbstruct.ulBitOff = pSlice->uiBitOffset;
    cOutput = pSlice->pBitmap;
#ifdef _64BITS
    bbstruct.ulBits = MOTOEXTRALONG(pSlice->pData); // preload first 8 bytes
#else
    bbstruct.ulBits = MOTOLONG(pSlice->pData); // preload first 4 bytes
#endif
    
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    cDCTable3 = pJPEG->JPCI[3].dc_tbl_no;
    cACTable3 = pJPEG->JPCI[3].ac_tbl_no;
    
    if (pJPEG->ucNumComponents == 4) // DEBUG - hacked value for YCCK & CMYK
    {
        pJPEG->jpegsample = 0x01;
    }
    
//    lsize = inpage.iPitch;
    iDCPred0 = pSlice->iDCPred0;
    iDCPred1 = pSlice->iDCPred1;
    iDCPred2 = pSlice->iDCPred2;
    iDCPred3 = pSlice->iDCPred3;
    // set up the parameters for the different subsampling options
    if (pJPEG->jpegsample == 0 || pJPEG->jpegsample == 0x01 || pJPEG->jpegsample == 0x11 || pJPEG->jpegsample == 0x12)
        cx = pSlice->uiWidth;
    else
        cx = (pSlice->uiWidth+1) >> 1;
    if (pJPEG->jpegsample == 0 || pJPEG->jpegsample == 0x01 || pJPEG->jpegsample == 0x11 || pJPEG->jpegsample == 0x21)
        cy = pSlice->uiHeight;
    else
        cy = pSlice->uiHeight >> 1;
    // faster access with reg vars
    iQuant1 = pJPEG->sQuantTable[pJPEG->JPCI[0].quant_tbl_no*DCTSIZE2];
    iQuant2 = pJPEG->sQuantTable[pJPEG->JPCI[1].quant_tbl_no*DCTSIZE2];
    iQuant3 = pJPEG->sQuantTable[pJPEG->JPCI[2].quant_tbl_no*DCTSIZE2];
    iQuant4 = pJPEG->sQuantTable[pJPEG->JPCI[3].quant_tbl_no*DCTSIZE2];
    Y1 = Y2 = Y3 = Y4 = 0; // suppress compiler warning
    iErr = 0;
    for (y=0; y<cy; y++)
    {
        //       if (!(y & 15) && pfnProgress) // call progress function to display current progress
        //          {
        //          if ((*pfnProgress)(y, cy) == PIL_PROGRESS_CANCEL)
        //             return PIL_ERROR_CANCELED;
        //          }
        
        for (x=0; x<cx; x++)
        {
            if (bb->pBuf > &pSlice->pData[pSlice->uiLen + 4])
            {
                pSlice->uiFlag = PIL_THREAD_COMPLETE; // completed
                pSlice->iError = PIL_ERROR_DECOMP; // problem
                return;
            }
            //          if (inpage->cState == PIL_PAGE_STATE_OPEN && *iOff > inpage->iHighWater) // need to read more data
            //             {
            //             if (inpage->iFilePos >= inpage->iDataSize) // no more data to read
            //                return PIL_ERROR_DECOMP; // fatal error
            //             else
            //                PILReadBlock(inpage, iOff); // read the next chunk of data
            //             }
            pMiniJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
            pMiniJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
            // do the luminance components
            iErr = JPEGDecodeMCUFast(bb, pMiniJPEG, &iDCPred0);
            Y1 = iDCPred0;
            if (pJPEG->jpegsample > 0x11) // color subsampled image
            {
                iErr |= JPEGDecodeMCUFast(bb, pMiniJPEG, &iDCPred0);
                Y2 = iDCPred0;
                if (pJPEG->jpegsample == 0x22) // 2:2 has 4 Lums
                {
                    iErr |= JPEGDecodeMCUFast(bb, pMiniJPEG, &iDCPred0);
                    Y3 = iDCPred0;
                    iErr |= JPEGDecodeMCUFast(bb, pMiniJPEG, &iDCPred0);
                    Y4 = iDCPred0;
                }
            }
            if (pJPEG->jpegsample > 0) // if color image
            {
                // first chroma
                pMiniJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                pMiniJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                iErr |= JPEGDecodeMCUFast(bb, pMiniJPEG, &iDCPred1);
                // second chroma
                pMiniJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                pMiniJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                iErr |= JPEGDecodeMCUFast(bb, pMiniJPEG, &iDCPred2);
            }
            if (pJPEG->jpegsample == 0x01) // YCCK/CMYK
            {
                // K
                pMiniJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable3];
                pMiniJPEG->pHuffACFast = pJPEG->huffacFast[cACTable3];
                iErr |= JPEGDecodeMCUFast(bb, pMiniJPEG, &iDCPred3);
            }
            if (iErr)
            {
                goto thumb_exit;  // decoding error, stop
            }
            switch (pJPEG->jpegsample) // custom pixel routines for each type of image
            {
                case 0x00: // grayscale
                    if (pJPEG->iOptions & PIL_CONVERT_16BPP) // want 16bpp grayscale output
                    {
                        unsigned char c;
                        unsigned short us;
                        c = pJPEG->cRangeTable[((iDCPred0 * iQuant1)>>5) & 0x3ff];
                        us = (c >> 3) | ((c>>2)<<5) | ((c>>3)<<11);
                        *(unsigned short *)&cOutput[(x<<1)] = us;
                    }
                    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
                    {
                        unsigned char c;
                        uint32_t ul;
                        c = pJPEG->cRangeTable[((iDCPred0 * iQuant1)>>5) & 0x3ff];
                        ul = 0xff000000 | (c) | (c<<8) | (c<<16);
                        *(uint32_t *)&cOutput[(x<<2)] = ul;
                    }
                    else
                        cOutput[x] = pJPEG->cRangeTable[((iDCPred0 * iQuant1)>>5) & 0x3ff];
                    break;
                case 0x01: // CMYK/YCCK
                    Y1 = pJPEG->cRangeTable[((iDCPred0 * iQuant1) >> 5) & 0x3ff];
                    Cb = pJPEG->cRangeTable[((iDCPred1 * iQuant2) >> 5) & 0x3ff];
                    Cr = pJPEG->cRangeTable[((iDCPred2 * iQuant3) >> 5) & 0x3ff];
                    K = pJPEG->cRangeTable[((iDCPred3 * iQuant4) >> 5) & 0x3ff];
                    if (pJPEG->iOptions & PIL_CONVERT_JPEG_YCCK) // YCCK
                    {
                        JPEGPixelYCCK(pJPEG, cOutput, x, (unsigned char) Y1, (unsigned char) Cb, (unsigned char) Cr, (unsigned char) K);
                    }
                    else // must by CMYK
                    {
                        JPEGPixelCMYK(pJPEG, cOutput, x, (unsigned char) Y1, (unsigned char) Cb, (unsigned char) Cr, (unsigned char) K);
                    }
                    break;
                case 0x11: // 1:1 color
                    if (pJPEG->iOptions & PIL_CONVERT_JPEG_RGB) // Adobe RGB colorspace
                    {
                        Y1 = pJPEG->cRangeTable[((iDCPred0 * iQuant1)>>5) & 0x3ff];
                        Cb = pJPEG->cRangeTable[((iDCPred1 * iQuant2)>>5) & 0x3ff];
                        Cr = pJPEG->cRangeTable[((iDCPred2 * iQuant3)>>5) & 0x3ff];
                        JPEGPixelRGB(pJPEG, cOutput, x, (unsigned char)Y1, (unsigned char)Cb, (unsigned char)Cr);
                    }
                    else
                    {
                        Y1 = (((Y1 * iQuant1)>>5)+0x80) << 12;
                        Cb = ((iDCPred1 * iQuant2)>>5);
                        Cr = ((iDCPred2 * iQuant3)>>5);
                        JPEGPixel_A(pJPEG, cOutput, x, Y1, Cb, Cr);
                    }
                    break;
                case 0x12: // 1:2 color
                    Y1 = (((Y1 * iQuant1)>>5)+0x80) << 12;
                    Y2 = (((Y2 * iQuant1)>>5)+0x80) << 12;
                    Cb = ((iDCPred1 * iQuant2)>>5);
                    Cr = ((iDCPred2 * iQuant3)>>5);
                    JPEGPixel_A(pJPEG, cOutput, x, Y1, Cb, Cr);
                    JPEGPixel_A(pJPEG, &cOutput[lsize], x, Y2, Cb, Cr);
                    break;
                case 0x21: // 2:1 color
                    Y1 = (((Y1 * iQuant1)>>5)+0x80) << 12;
                    Y2 = (((Y2 * iQuant1)>>5)+0x80) << 12;
                    Cb = ((iDCPred1 * iQuant2)>>5);
                    Cr = ((iDCPred2 * iQuant3)>>5);
                    JPEGPixel2_A(pJPEG, cOutput, x<<1, Y1, Y2, Cb, Cr);
                    break;
                case 0x22: // 2:2 color
                    Y1 = (((Y1 * iQuant1)>>5)+0x80)<<12;
                    Y2 = (((Y2 * iQuant1)>>5)+0x80)<<12;
                    Y3 = (((Y3 * iQuant1)>>5)+0x80)<<12;
                    Y4 = (((Y4 * iQuant1)>>5)+0x80)<<12;
                    Cb = ((iDCPred1 * iQuant2)>>5);
                    Cr = ((iDCPred2 * iQuant3)>>5);
                    JPEGPixel2_A(pJPEG, cOutput, x<<1, Y1, Y2, Cb, Cr);
                    JPEGPixel2_A(pJPEG, &cOutput[lsize], x<<1, Y3, Y4, Cb, Cr);
                    break;
            } // pixel generation
            if (pSlice->uiResInterval)
            {
                if (--pSlice->uiResCount == 0)
                {
                    pSlice->uiResCount = pSlice->uiResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = iDCPred3 = 0; // reset DC predictors
                    if (bb->ulBitOff & 7)
                    {
                        bb->ulBitOff += (8 - (bb->ulBitOff & 7));
                        //                   *iBit = 0;  // new restart interval starts on byte boundary
                        //                   (*iOff)++;
                    }
                }
            }
        } // for x
        if (pJPEG->jpegsample == 0x12 || pJPEG->jpegsample == 0x22)
            cOutput += lsize * 2; // skip 2 lines for subsampled color
        else
            cOutput += lsize; // next line
    } // for y
thumb_exit:
    pSlice->uiFlag = PIL_THREAD_COMPLETE; // completed
    pSlice->iError = iErr;
    return;
} /* PILDecodeJPEGThumbSlice() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCUGray(...)                                        *
 *                                                                          *
 *  PURPOSE    : Draw a gray macro block into destination image.            *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCUGray(PIL_PAGE *inpage, unsigned char *pSrc, unsigned char *cOutput, JPEGDATA *pJPEG, int x, int y, int lsize)
{
    int i, j, xcount, ycount;
    uint32_t lPixel;
    unsigned char *pDest;
    
    if (pJPEG->iOptions & PIL_CONVERT_16BPP) // convert 8-bit grayscale to 16bpp grayscale
    {
        unsigned short *usDest;
        if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
        {
            usDest = (unsigned short *)&cOutput[x*8 + y*4*lsize];
            ycount = 4;
            xcount = 4;
            if ((y*4 + ycount) > inpage->iHeight)
                ycount = inpage->iHeight & 3;
            if ((x*4 + xcount) > inpage->iWidth)
                xcount = inpage->iWidth & 3;
            for (i=0; i<ycount; i++) // do up to 8 rows
            {
                for (j=0; j<xcount; j++)
                {
                    lPixel = pSrc[j*2];
                    lPixel += pSrc[j*2+1];
                    lPixel += pSrc[j*2+8];
                    lPixel += pSrc[j*2+9];
                    lPixel >>= 2;
                    usDest[j] = (unsigned short)((lPixel >> 3) | ((lPixel>>2)<<5) | ((lPixel>>3)<<11));
                }
                usDest += (lsize>>1);
                pSrc += 16; // skip 2 source rows
            }
        }
        else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
        {
            usDest = (unsigned short *)&cOutput[x*4 + y*2*lsize];
            usDest[0] = (pSrc[0]>>3) | ((pSrc[0]>>2)<<5) | ((pSrc[0]>>3)<<11);
            usDest[1] = (pSrc[1]>>3) | ((pSrc[1]>>2)<<5) | ((pSrc[1]>>3)<<11);
            usDest += (lsize>>1);
            usDest[0] = (pSrc[2]>>3) | ((pSrc[2]>>2)<<5) | ((pSrc[2]>>3)<<11);
            usDest[1] = (pSrc[3]>>3) | ((pSrc[3]>>2)<<5) | ((pSrc[3]>>3)<<11);
        }
        else // fullsize
        {
            usDest = (unsigned short *)&cOutput[x*16 + y*8*lsize];
            ycount = 8;
            xcount = 8;
            if ((y*8 + ycount) > inpage->iHeight)
                ycount = inpage->iHeight & 7;
            if ((x*8 + xcount) > inpage->iWidth)
                xcount = inpage->iWidth & 7;
            for (i=0; i<ycount; i++) // do up to 8 rows
            {
                for (j=0; j<xcount; j++)
                {
                    usDest[j] = (pSrc[j] >> 3) | ((pSrc[j]>>2)<<5) | ((pSrc[j]>>3)<<11);
                }
                usDest += (lsize>>1);
                pSrc += 8;
            }
        }
    }
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP) // convert 8-bit grayscale to 32bpp grayscale
    {
        uint32_t *ulDest;
        if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
        {
            ulDest = (uint32_t *)&cOutput[x*16 + y*4*lsize];
            ycount = 4;
            xcount = 4;
            if ((y*4 + ycount) > inpage->iHeight)
                ycount = inpage->iHeight & 3;
            if ((x*4 + xcount) > inpage->iWidth)
                xcount = inpage->iWidth & 3;
            for (i=0; i<ycount; i++) // do up to 8 rows
            {
                for (j=0; j<xcount; j++)
                {
                    lPixel = pSrc[j*2];
                    lPixel += pSrc[j*2+1];
                    lPixel += pSrc[j*2+8];
                    lPixel += pSrc[j*2+9];
                    lPixel >>= 2;
                    ulDest[j] = 0xff000000 | lPixel | (lPixel<<8) | (lPixel<<16);
                }
                ulDest += (lsize>>2);
                pSrc += 16; // skip 2 source rows
            }
        }
        else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
        {
            ulDest = (uint32_t *)&cOutput[x*8 + y*2*lsize];
            ulDest[0] = 0xff000000 | pSrc[0] | (pSrc[0]<<8) | (pSrc[0]<<16);
            ulDest[1] = 0xff000000 | pSrc[1] | (pSrc[1]<<8) | (pSrc[1]<<16);
            ulDest += (lsize>>2);
            ulDest[0] = 0xff000000 | pSrc[2] | (pSrc[2]<<8) | (pSrc[2]<<16);
            ulDest[1] = 0xff000000 | pSrc[3] | (pSrc[3]<<8) | (pSrc[3]<<16);
        }
        else // fullsize
        {
            ulDest = (uint32_t *)&cOutput[x*32 + y*8*lsize];
            ycount = 8;
            xcount = 8;
            if ((y*8 + ycount) > inpage->iHeight)
                ycount = inpage->iHeight & 7;
            if ((x*8 + xcount) > inpage->iWidth)
                xcount = inpage->iWidth & 7;
            for (i=0; i<ycount; i++) // do up to 8 rows
            {
                for (j=0; j<xcount; j++)
                {
                    ulDest[j] = 0xff000000 | pSrc[j]| (pSrc[j]<<8) | (pSrc[j]<<16);
                }
                ulDest += (lsize>>2);
                pSrc += 8;
            }
        }
    }
    else // 8-bit output
    {
        if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
        {
            pDest = x*4 + y*4*lsize + cOutput;
            ycount = 4;
            xcount = 4;
            if ((y*4 + ycount) > inpage->iHeight)
                ycount = inpage->iHeight & 3;
            if ((x*4 + xcount) > inpage->iWidth)
                xcount = inpage->iWidth & 3;
            // average 4 pixels together to create a 4x4 block instead of 8x8
            for (i=0; i<ycount; i++) // do up to 4 rows
            {
                for (j=0; j<xcount; j++)
                {
                    lPixel = pSrc[j*2];
                    lPixel += pSrc[j*2+1];
                    lPixel += pSrc[j*2+8];
                    lPixel += pSrc[j*2+9];
                    pDest[j] = (unsigned char)(lPixel >> 2); // Average the 4 pixels
                }
                pDest += lsize;
                pSrc += 16; // skip 2 source rows
            }
        }
        else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
        {
            pDest = x*2 + y*2*lsize + cOutput;
            pDest[0] = pSrc[0];
            pDest[1] = pSrc[1];
            pDest += lsize;
            pDest[0] = pSrc[2];
            pDest[1] = pSrc[3];
        }
        else // full size
        {
            pDest = x*8 + y*8*lsize + cOutput;
            ycount = 8;
            xcount = 8;
            if ((y*8 + ycount) > inpage->iHeight)
                ycount = inpage->iHeight & 7;
            if ((x*8 + xcount) > inpage->iWidth)
                xcount = inpage->iWidth & 7;
            for (i=0; i<ycount; i++) // do up to 8 rows
            {
                if (xcount >= 5) // if not up against right edge
                { // copy 8 pixels in one shot
                    *(uint32_t *)&pDest[0] = *(uint32_t *)&pSrc[0];
                    *(uint32_t *)&pDest[4] = *(uint32_t *)&pSrc[4];
                }
                else
                {
                    for (j=0; j<xcount; j++)
                    {
                        pDest[j] = pSrc[j]; // copy a partial row
                    }
                }
                pDest += lsize;
                pSrc += 8;
            }
        }
    } // 8-bit output
} /* JPEGPutMCUGray() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCUGray12(...)                                      *
 *                                                                          *
 *  PURPOSE    : Draw a gray macro block into destination image.            *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCUGray12(PIL_PAGE *inpage, signed short *pSrc, unsigned char *cOutput, int x, int y, int lsize)
{
    int i, xcount, ycount;
    unsigned char *pDest;
    
    pDest = x*16 + y*8*lsize + cOutput;
    ycount = 8;
    xcount = 8;
    if ((y*8 + ycount) > inpage->iHeight)
        ycount = inpage->iHeight & 7;
    if ((x*8 + xcount) > inpage->iWidth)
        xcount = inpage->iWidth & 7;
    for (i=0; i<ycount; i++) // do up to 8 rows
    {
        memcpy(pDest, pSrc, xcount*2);
        pDest += lsize;
        pSrc += 8;
    }
} /* JPEGPutMCUGray12() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU11(int, int, int, int*, char *)                  *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU11(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y;
    int iCol;
    int iRow, iXCount, iYCount;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU1];
    pCr = (unsigned char *)&pMCU[MCU2];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*8*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<4;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<5;
    else
        cOutput += x*24;
    if (y*8+7 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 7;
    else
        iYCount = 8;
    if (x*8+7 >= inpage->iWidth)
        iXCount = inpage->iWidth & 7;
    else
        iXCount = 8;
#ifdef USE_ARM_ASM
    if (!(pJPEG->iOptions & PIL_CONVERT_SIMD) && (pJPEG->iOptions & PIL_CONVERT_16BPP) && iYCount == 8 && iXCount == 8) // draw the full sized 16bpp block with ASM
    {
        ARMDrawMCU11(pMCU, cOutput, lsize);
        return;
    }
#endif // USE_ARM_ASM
    
    if (pJPEG->pTables && pJPEG->iOptions & PIL_CONVERT_16BPP) // we can do fast RGB565 conversion
    {
        uint32_t usPixel;
        unsigned short *pus;
        for (iRow=0; iRow<8; iRow++) // up to 8 rows to do
        {
            pus = (unsigned short *)cOutput;
            for (iCol=0; iCol<8; iCol++) // up to 4x2 cols to do
            {
                usPixel = ((*pCr++ >> 3) << 11);
                usPixel |= (((*pCb++ >> 3) & 0x1f) << 6);
                usPixel |= ((*pY++ >> 2) & 0x3f);
                *pus++ =  pJPEG->pTables->pYUV16[usPixel];
            } // for col
            cOutput += lsize;
        } // for row
    } // if fast table
    else // 24bpp and 32bpp
    {
        for (iRow=0; iRow<iYCount; iRow++) // up to 8 rows to do
        {
            for (iCol=0; iCol<iXCount; iCol++) // up to 8 cols to do
            {
                Y = pY[iCol];
                Y <<= 12;  // scale to level of conversion table
                Cb = pCb[iCol];
                Cr = pCr[iCol];
                JPEGPixel(pJPEG, cOutput, iCol, Y, Cb, Cr);
            }
            pY += 8; // skip to next line of source pixels
            pCb += 8;
            pCr += 8;
            cOutput += lsize;
        }
    }
} /* JPEGPutMCU11() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCUYCCK(int, int, int, int*, char *)                *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCUYCCK(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb, K;
    signed int Y;
    int iCol;
    int iRow, iXCount, iYCount;
    unsigned char *pY, *pCr, *pCb, *pK;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU1];
    pCr = (unsigned char *)&pMCU[MCU2];
    pK = (unsigned char *)&pMCU[MCU3];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*8*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<4;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<5;
    else
        cOutput += x*24;
    if (y*8+7 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 7;
    else
        iYCount = 8;
    if (x*8+7 >= inpage->iWidth)
        iXCount = inpage->iWidth & 7;
    else
        iXCount = 8;
    if (pJPEG->pTables && pJPEG->iOptions & PIL_CONVERT_16BPP) // we can do fast RGB565 conversion
    {
        uint32_t usPixel;
        unsigned short *pus;
        for (iRow=0; iRow<8; iRow++) // up to 8 rows to do
        {
            pus = (unsigned short *)cOutput;
            for (iCol=0; iCol<8; iCol++) // up to 4x2 cols to do
            {
                usPixel = ((*pCr++ >> 3) << 11);
                usPixel |= (((*pCb++ >> 3) & 0x1f) << 6);
                usPixel |= ((*pY++ >> 2) & 0x3f);
                *pus++ =  pJPEG->pTables->pYUV16[usPixel];
            } // for col
            cOutput += lsize;
        } // for row
    } // if fast table
    else // 24bpp and 32bpp
    {
        for (iRow=0; iRow<iYCount; iRow++) // up to 8 rows to do
        {
            for (iCol=0; iCol<iXCount; iCol++) // up to 8 cols to do
            {
                Y = pY[iCol];
                Y <<= 12;  // scale to level of conversion table
                Cb = pCb[iCol];
                Cr = pCr[iCol];
                K = pK[iCol];
                JPEGPixelYCCK(pJPEG, cOutput, iCol, Y, Cb, Cr, K);
            }
            pY += 8; // skip to next line of source pixels
            pCb += 8;
            pCr += 8;
            pK += 8;
            cOutput += lsize;
        }
    }
} /* JPEGPutMCU11() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCURGB(int, int, int, int*, char *)                 *
 *                                                                          *
 *  PURPOSE    : Combine and output an RGB color macro block.               *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCURGB(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    int iRow, iCol, iXCount, iYCount;
    unsigned char *pR, *pG, *pB;
    
    pR = (unsigned char *)&pMCU[MCU0];
    pG = (unsigned char *)&pMCU[MCU1];
    pB = (unsigned char *)&pMCU[MCU2];
    
    cOutput += y*8*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<4;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<5;
    else
        cOutput += x*24;
    if (y*8+7 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 7;
    else
        iYCount = 8;
    if (x*8+7 >= inpage->iWidth)
        iXCount = inpage->iWidth & 7;
    else
        iXCount = 8;
    for (iRow=0; iRow<iYCount; iRow++) // up to 8 rows to do
    {
        for (iCol=0; iCol<iXCount; iCol++) // up to 8 cols to do
        {
            JPEGPixelRGB(pJPEG, cOutput, iCol, pR[iCol], pG[iCol], pB[iCol]);
        } // for iCol
        pR += 8; // skip to next line of source pixels
        pG += 8;
        pB += 8;
        cOutput += lsize;
    } // for iRow
} /* JPEGPutMCURGB() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCUCMYK(int, int, int, int*, char *)                *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCUCMYK(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    int iRow, iCol, iXCount, iYCount;
    unsigned char *pCyan, *pMagenta, *pYellow, *pBlack;
    
    pCyan  = (unsigned char *)&pMCU[MCU0];
    pMagenta = (unsigned char *)&pMCU[MCU1];
    pYellow = (unsigned char *)&pMCU[MCU2];
    pBlack = (unsigned char *)&pMCU[MCU3];
    
    /* Convert CMYK pixels into RGB pixels and store in output image */
    cOutput += y*8*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<4;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<5;
    else
        cOutput += x*24;
    if (y*8+7 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 7;
    else
        iYCount = 8;
    if (x*8+7 >= inpage->iWidth)
        iXCount = inpage->iWidth & 7;
    else
        iXCount = 8;
    for (iRow=0; iRow<iYCount; iRow++) // up to 8 rows to do
    {
        for (iCol=0; iCol<iXCount; iCol++) // up to 8 cols to do
        {
            //         JPEGPixel(pJPEG, cOutput, iCol, pCyan[iCol]<<12, pMagenta[iCol], pYellow[iCol]);
            JPEGPixelCMYK(pJPEG, cOutput, iCol, pCyan[iCol], pMagenta[iCol], pYellow[iCol], pBlack[iCol]);
        }
        pCyan += 8; // skip to next line of source pixels
        pMagenta += 8;
        pYellow += 8;
        pBlack += 8;
        cOutput += lsize;
    } // for iRow
} /* JPEGPutMCUCMYK() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU11HALF(int, int, int, int*, char *)              *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU11HALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y;
    int iRow, iCol, iXCount, iYCount;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU1];
    pCr = (unsigned char *)&pMCU[MCU2];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*4*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<3;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<4;
    else
        cOutput += x*12;
    if (y*4+3 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 3;
    else
        iYCount = 4;
    if (x*4+3 >= inpage->iWidth)
        iXCount = inpage->iWidth & 3;
    else
        iXCount = 4;
    for (iRow=0; iRow<iYCount; iRow++) // up to 4 rows to do
    {
        for (iCol=0; iCol<iXCount; iCol++) // up to 4 cols to do
        {
            Y = pY[iCol*2];      // average 4 pixels together
            Y += pY[iCol*2+1];
            Y += pY[iCol*2+8];
            Y += pY[iCol*2+9];
            Y <<= 10;  // scale to level of conversion table
            Cb = pCb[iCol*2];
            Cb += pCb[iCol*2+1];
            Cb += pCb[iCol*2+8];
            Cb += pCb[iCol*2+9];
            Cb >>= 2;
            Cr = pCr[iCol*2];
            Cr += pCr[iCol*2+1];
            Cr += pCr[iCol*2+8];
            Cr += pCr[iCol*2+9];
            Cr >>= 2;
            JPEGPixel(pJPEG, cOutput, iCol, Y, Cb, Cr);
        }
        pY += 16; // skip to next line of source pixels
        pCb += 16;
        pCr += 16;
        cOutput += lsize;
    }
    
} /* JPEGPutMCU11HALF() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCURGBHALF(int, int, int, int*, char *)             *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCURGBHALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t R, G, B;
    int iRow, iCol, iXCount, iYCount;
    unsigned char *pR, *pG, *pB;
    
    pR  = (unsigned char *)&pMCU[MCU0];
    pG = (unsigned char *)&pMCU[MCU1];
    pB = (unsigned char *)&pMCU[MCU2];
    
    /* Store RGB pixels in output image */
    cOutput += y*4*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<3;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<4;
    else
        cOutput += x*12;
    if (y*4+3 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 3;
    else
        iYCount = 4;
    if (x*4+3 >= inpage->iWidth)
        iXCount = inpage->iWidth & 3;
    else
        iXCount = 4;
    for (iRow=0; iRow<iYCount; iRow++) // up to 4 rows to do
    {
        for (iCol=0; iCol<iXCount; iCol++) // up to 4 cols to do
        {
            R = pR[iCol*2];      // average 4 pixels together
            R += pR[iCol*2+1];
            R += pR[iCol*2+8];
            R += pR[iCol*2+9];
            R >>= 2;
            G = pG[iCol*2];
            G += pG[iCol*2+1];
            G += pG[iCol*2+8];
            G += pG[iCol*2+9];
            G >>= 2;
            B = pB[iCol*2];
            B += pB[iCol*2+1];
            B += pB[iCol*2+8];
            B += pB[iCol*2+9];
            B >>= 2;
            JPEGPixelRGB(pJPEG, cOutput, iCol, (unsigned char)R, (unsigned char)G, (unsigned char)B);
        }
        pR += 16; // skip to next line of source pixels
        pG += 16;
        pB += 16;
        cOutput += lsize;
    }
    
} /* JPEGPutMCURGBHALF() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCUCMYKHALF(int, int, int, int*, char *)            *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCUCMYKHALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t R, G, B, K;
    int iRow, iCol, iXCount, iYCount;
    unsigned char *pR, *pG, *pB, *pK;
    
    pR = (unsigned char *) &pMCU[MCU0];
    pG = (unsigned char *) &pMCU[MCU1];
    pB = (unsigned char *) &pMCU[MCU2];
    pK = (unsigned char *) &pMCU[MCU3];
    
    /* Store RGB pixels in output image */
    cOutput += y * 4 * lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x << 3;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x << 4;
    else
        cOutput += x * 12;
    if (y * 4 + 3 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 3;
    else
        iYCount = 4;
    if (x * 4 + 3 >= inpage->iWidth)
        iXCount = inpage->iWidth & 3;
    else
        iXCount = 4;
    for (iRow = 0; iRow<iYCount; iRow++) // up to 4 rows to do
    {
        for (iCol = 0; iCol<iXCount; iCol++) // up to 4 cols to do
        {
            R = pR[iCol * 2];      // average 4 pixels together
            R += pR[iCol * 2 + 1];
            R += pR[iCol * 2 + 8];
            R += pR[iCol * 2 + 9];
            R >>= 2;
            G = pG[iCol * 2];
            G += pG[iCol * 2 + 1];
            G += pG[iCol * 2 + 8];
            G += pG[iCol * 2 + 9];
            G >>= 2;
            B = pB[iCol * 2];
            B += pB[iCol * 2 + 1];
            B += pB[iCol * 2 + 8];
            B += pB[iCol * 2 + 9];
            B >>= 2;
            K = pK[iCol * 2];
            K += pK[iCol * 2 + 1];
            K += pK[iCol * 2 + 8];
            K += pK[iCol * 2 + 9];
            K >>= 2;
            JPEGPixelCMYK(pJPEG, cOutput, iCol, (unsigned char) R, (unsigned char) G, (unsigned char) B, (unsigned char) K);
        }
        pR += 16; // skip to next line of source pixels
        pG += 16;
        pB += 16;
        pK += 16;
        cOutput += lsize;
    }
    
} /* JPEGPutMCURGBHALF() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU11QUARTER(int, int, int, int*, char *)           *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU11QUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU1];
    pCr = (unsigned char *)&pMCU[MCU2];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*2*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<2;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<3;
    else
        cOutput += x*6;
    Y = pY[0] << 12; // scale to level of conversion table
    Cb = pCb[0];
    Cr = pCr[0];
    JPEGPixel(pJPEG, cOutput, 0, Y, Cb, Cr);
    Y = pY[1] << 12; // scale to level of conversion table
    Cb = pCb[1];
    Cr = pCr[1];
    JPEGPixel(pJPEG, cOutput, 1, Y, Cb, Cr);
    cOutput += lsize;
    Y = pY[2] << 12; // scale to level of conversion table
    Cb = pCb[2];
    Cr = pCr[2];
    JPEGPixel(pJPEG, cOutput, 0, Y, Cb, Cr);
    Y = pY[3] << 12; // scale to level of conversion table
    Cb = pCb[3];
    Cr = pCr[3];
    JPEGPixel(pJPEG, cOutput, 1, Y, Cb, Cr);
    
} /* JPEGPutMCU11QUARTER() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCURGBQUARTER(int, int, int, int*, char *)          *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCURGBQUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    unsigned char *pR, *pG, *pB;
    
    pR  = (unsigned char *)&pMCU[MCU0];
    pG = (unsigned char *)&pMCU[MCU1];
    pB = (unsigned char *)&pMCU[MCU2];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*2*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<2;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<3;
    else
        cOutput += x*6;
    JPEGPixelRGB(pJPEG, cOutput, 0, pR[0], pG[0], pB[0]);
    JPEGPixelRGB(pJPEG, cOutput, 1, pR[1], pG[1], pB[1]);
    cOutput += lsize;
    JPEGPixelRGB(pJPEG, cOutput, 0, pR[2], pG[2], pB[2]);
    JPEGPixelRGB(pJPEG, cOutput, 1, pR[3], pG[3], pB[3]);
    
} /* JPEGPutMCURGBQUARTER() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCUCMYKQUARTER(int, int, int, int*, char *)         *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCUCMYKQUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    unsigned char *pR, *pG, *pB, *pK;
    
    pR = (unsigned char *) &pMCU[MCU0];
    pG = (unsigned char *) &pMCU[MCU1];
    pB = (unsigned char *) &pMCU[MCU2];
    pK = (unsigned char *) &pMCU[MCU3];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y * 2 * lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x << 2;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x << 3;
    else
        cOutput += x * 6;
    JPEGPixelCMYK(pJPEG, cOutput, 0, pR[0], pG[0], pB[0], pK[0]);
    JPEGPixelCMYK(pJPEG, cOutput, 1, pR[1], pG[1], pB[1], pK[1]);
    cOutput += lsize;
    JPEGPixelCMYK(pJPEG, cOutput, 0, pR[2], pG[2], pB[2], pK[2]);
    JPEGPixelCMYK(pJPEG, cOutput, 1, pR[3], pG[3], pB[3], pK[3]);
    
} /* JPEGPutMCUCMYKQUARTER() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU21(int, int, int, int*, char *)                  *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU21(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1, Y2;
    int iCol;
    int iRow, iXCount1, iXCount2, iYCount;
    unsigned char *pY, *pCr, *pCb;
    int bUseOdd1, bUseOdd2; // special case where 24bpp odd sized image can clobber first column
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU2];
    pCr = (unsigned char *)&pMCU[MCU3];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*8*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<5;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<6;
    else
        cOutput += x*48;
    if (y*8+7 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 7;
    else
        iYCount = 8;
    bUseOdd1 = bUseOdd2 = TRUE; // assume odd column can be used
    if (x*16+15 >= inpage->iWidth)
    {
        iXCount1 = (((inpage->iWidth & 15)+1)>>1);
        if (iXCount1 >= 4)
        {
            iXCount2 = iXCount1 - 4;
            iXCount1 = 4;
            if (inpage->iWidth & 1 && (iXCount2 * 2) + 8 + (x * 16) > inpage->iWidth)
                bUseOdd2 = FALSE;
        }
        else
        {
            iXCount2 = 0;
            if (inpage->iWidth & 1 && (iXCount1 * 2) + (x * 16) > inpage->iWidth)
                bUseOdd1 = FALSE;
        }
    }
    else
        iXCount1 = iXCount2 = 4;
#ifdef  USE_ARM_ASM
    if (!(pJPEG->iOptions & PIL_CONVERT_SIMD) && (pJPEG->iOptions & PIL_CONVERT_16BPP) && iYCount == 8 && iXCount1 == 4 && iXCount2 == 4) // draw the full sized 16bpp block with ASM
    {
        ARMDrawMCU21(pMCU, cOutput, lsize);
        return;
    }
#endif // ARM ASM
    
    if (pJPEG->pTables && pJPEG->iOptions & PIL_CONVERT_16BPP) // we can do fast RGB565 conversion
    {
        uint32_t usPixel1, usPixel2;
        uint32_t *pul;
        for (iRow=0; iRow<iYCount; iRow++) // up to 8 rows to do
        {
            pul = (uint32_t *)cOutput;
            //         _m_prefetch(cOutput + lsize);
            for (iCol=0; iCol<4/*iXCount1*/; iCol++) // up to 4x2 cols to do
            { // left block
                usPixel1 = ((*pCr++ >> 3) << 11);
                usPixel1 |= (((*pCb++ >> 3) & 0x1f) << 6);
                usPixel1 |= ((*pY++ >> 2) & 0x3f);
                usPixel2 = usPixel1 & ~0x3f; // mask off Y1
                usPixel2 |= ((*pY++ >> 2) & 0x3f);
                usPixel1 =  pJPEG->pTables->pYUV16[usPixel1];
                usPixel2 =  pJPEG->pTables->pYUV16[usPixel2];
                *pul++ = usPixel1 | (usPixel2 << 16);
                // right block
                usPixel1 = ((pCr[3] >> 3) << 11);
                usPixel1 |= (((pCb[3] >> 3) & 0x1f) << 6);
                usPixel1 |= ((pY[126] >> 2) & 0x3f);
                usPixel2 = usPixel1 & ~0x3f; // mask off Y1
                usPixel2 |= ((pY[127] >> 2) & 0x3f);
                usPixel1 =  pJPEG->pTables->pYUV16[usPixel1];
                usPixel2 =  pJPEG->pTables->pYUV16[usPixel2];
                pul[3] = usPixel1 | (usPixel2 << 16);
            } // for col
            //         pY += 8; // skip to next line of source pixels
            pCb += 4;
            pCr += 4;
            cOutput += lsize;
        } // for row
    }
    else // 24bpp and 32bpp
    {
        for (iRow=0; iRow<iYCount; iRow++) // up to 8 rows to do
        {
            for (iCol=0; iCol<iXCount1; iCol++) // up to 8 cols to do
            {
                // for left block
                Y1 = pY[iCol*2];
                Y2 = pY[iCol*2+1];
                Y1 <<= 12;  // scale to level of conversion table
                Y2 <<= 12;
                Cb = pCb[iCol];
                Cr = pCr[iCol];
                // left block
                if (bUseOdd1 || iCol != (iXCount1-1)) // only render if it won't go off the right edge
                    JPEGPixel2(pJPEG, cOutput, iCol*2, Y1, Y2, Cb, Cr);
                else // can only draw 1 pixel
                    JPEGPixel(pJPEG, cOutput, iCol*2, Y1, Cb, Cr);
                // right block
                if (iCol < iXCount2)
                {
                    Y1 = pY[iCol*2+DCTSIZE2*2];
                    Y2 = pY[iCol*2+1+DCTSIZE2*2];
                    Y1 <<= 12;  // scale to level of conversion table
                    Y2 <<= 12;
                    Cb = pCb[iCol+4];
                    Cr = pCr[iCol+4];
                    if (bUseOdd2 || iCol != (iXCount2-1))
                        JPEGPixel2(pJPEG, cOutput, iCol*2+8, Y1, Y2, Cb, Cr);
                    else // can only draw 1 pixel
                        JPEGPixel(pJPEG, cOutput, iCol*2+8, Y1, Cb, Cr);
                }
            }
            pY += 8; // skip to next line of source pixels
            pCb += 8;
            pCr += 8;
            cOutput += lsize;
        }
    }
} /* JPEGPutMCU21() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutLuma(int, int, int, int*, char *)                   *
 *                                                                          *
 *  PURPOSE    : Take luma-only output of color jpeg MCU.                   *
 *                                                                          *
 ****************************************************************************/
void JPEGPutLuma(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    int iRow;
    unsigned char *pY;
    uint32_t *s, *d;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    if (pJPEG->jpegsample == 0x21)
    {
        cOutput += y*8*lsize;
    }
    else
    {
        cOutput += y*16*lsize;
    }
    if (pJPEG->jpegsample == 0x12)
        cOutput += x<<3;
    else
        cOutput += x<<4;
    for (iRow=0; iRow<8; iRow++)
    {
        d = (uint32_t *)cOutput;
        s = (uint32_t *)&pY[iRow*8];
        d[0] = s[0]; // copy 8 pixels
        d[1] = s[1];
        if (pJPEG->jpegsample & 0x20) // horizontal subsampling
        {
            d[2] = s[32];
            d[3] = s[33];
        }
        if (pJPEG->jpegsample & 0x02) // vertical subsampling
        {
            d[lsize*2] = s[64];
            d[(lsize*2)+1] = s[65];
            if (pJPEG->jpegsample & 0x20) // vertical and horiz subsampling
            {
                d[(lsize*2)+2] = s[96];
                d[(lsize*2)+3] = s[97];
            }
        }
        cOutput += lsize;
    }
} /* JPEGPutLuma() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU21HALF(int, int, int, int*, char *)              *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU21HALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1;
    int iRow, iCol, iXCount1, iXCount2, iYCount;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU2];
    pCr = (unsigned char *)&pMCU[MCU3];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*4*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<4;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<5;
    else
        cOutput += x*24;
    //   if (y*8+7 >= inpage->iHeight)  // if last block overflows bottom of image
    //      iYCount = inpage->iHeight & 7;
    //   else
    iYCount = 4;
    if (x*8+7 > (inpage->iWidth/2))
    {
        iXCount1 = ((inpage->iWidth/2) & 7);
        if (iXCount1 >= 4)
        {
            iXCount2 = iXCount1 - 4;
            iXCount1 = 4;
        }
        else
        {
            iXCount2 = 0;
        }
    }
    else
        iXCount1 = iXCount2 = 4;
#if defined(USE_ARM_ASM) && !defined(_64BITS)
    if (iXCount1 == 4 && iXCount2 == 4 && (pJPEG->iOptions & PIL_CONVERT_16BPP)) // can do it faster in ASM
        ARMDrawMCU21Half(pMCU, cOutput, lsize);
    else
#endif // USE_ARM_ASM
    {
        for (iRow=0; iRow<iYCount; iRow++) // up to 8 rows to do
        {
            for (iCol=0; iCol<iXCount1; iCol++) // up to 8 cols to do
            {
                // for left block
                Y1 = pY[iCol*2];
                Y1 += pY[iCol*2+1];
                Y1 += pY[iCol*2+8];
                Y1 += pY[iCol*2+9];
                Y1 <<= 10;  // scale to level of conversion table
                Cb = pCb[iCol];
                Cb += pCb[iCol+8];
                Cb >>= 1;
                Cr = pCr[iCol];
                Cr += pCr[iCol+8];
                Cr >>= 1;
                JPEGPixel(pJPEG, cOutput, iCol, Y1, Cb, Cr);
                // for right block
                if (iCol < iXCount2)
                {
                    Y1 = pY[iCol*2+DCTSIZE2*2];
                    Y1 += pY[iCol*2+1+DCTSIZE2*2];
                    Y1 += pY[iCol*2+8+DCTSIZE2*2];
                    Y1 += pY[iCol*2+9+DCTSIZE2*2];
                    Y1 <<= 10;  // scale to level of conversion table
                    Cb = pCb[iCol+4];
                    Cb += pCb[iCol+12];
                    Cb >>= 1;
                    Cr = pCr[iCol+4];
                    Cr += pCr[iCol+12];
                    Cr >>= 1;
                    JPEGPixel(pJPEG, cOutput, iCol+4, Y1, Cb, Cr);
                }
            }
            pY += 16; // skip to next line of source pixels
            pCb += 16;
            pCr += 16;
            cOutput += lsize;
        }
    }
    
} /* JPEGPutMCU21HALF() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU21QUARTER(int, int, int, int*, char *)           *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU21QUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1, Y2;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU2];
    pCr = (unsigned char *)&pMCU[MCU3];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*2*lsize;
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<3;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<4;
    else
        cOutput += x*12;
    //#ifndef MIPS
    //#ifdef _WIN32_WCE
    //#ifdef USE_ARM_ASM
    //   if (iXCount1 == 4 && iXCount2 == 4 && (pJPEG->iOptions & PIL_CONVERT_16BPP)) // can do it faster in ASM
    //      ARMDrawMCU21Half(pMCU, cOutput, lsize);
    //   else
    //#endif // USE_ARM_ASM
    //#endif
    //#endif // MIPS
    {
        // top left block
        Y1 = pY[0] << 12;  // scale to level of conversion table
        Y2 = pY[1] << 12;
        Cb = pCb[0];
        Cr = pCr[0];
        JPEGPixel2(pJPEG, cOutput, 0, Y1, Y2, Cb, Cr);
        // top right block
        Y1 = pY[(DCTSIZE2<<1)] << 12;  // scale to level of conversion table
        Y2 = pY[1+(DCTSIZE2<<1)] << 12;
        Cb = pCb[1];
        Cr = pCr[1];
        JPEGPixel2(pJPEG, cOutput, 2, Y1, Y2, Cb, Cr);
        // second row
        cOutput += lsize;
        // bottom left block
        Y1 = pY[2] << 12;  // scale to level of conversion table
        Y2 = pY[3] << 12;
        Cb = pCb[2];
        Cr = pCr[2];
        JPEGPixel2(pJPEG, cOutput, 0, Y1, Y2, Cb, Cr);
        // bottom right block
        Y1 = pY[2+(DCTSIZE2<<1)] << 12;  // scale to level of conversion table
        Y2 = pY[3+(DCTSIZE2<<1)] << 12;
        Cb = pCb[3];
        Cr = pCr[3];
        JPEGPixel2(pJPEG, cOutput, 2, Y1, Y2, Cb, Cr);
    }
    
} /* JPEGPutMCU21QUARTER() */

#ifdef BOGUS // future work
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILReadThread(PIL_PAGE *, int *)                           *
 *                                                                          *
 *  PURPOSE    : Background thread which reads the JPEG file data.          *
 *                                                                          *
 ****************************************************************************/
DWORD WINAPI PILReadThread(LPVOID pInPage)
{
    PIL_PAGE *pPage = (PIL_PAGE *)pInPage;
    int i, iSize;
    
    pPage->hEvent = (int)CreateEvent(NULL, FALSE, FALSE, NULL);
    
    // Loop through the file, reading blocks
    while (pPage->iFilePos < pPage->iDataSize)
    {
        // don't let it try to read past the end or the read will fail
        iSize = PIL_BUFFER_SIZE;
        if ((pPage->iFilePos + iSize) > pPage->iDataSize)
            iSize = pPage->iDataSize - pPage->iFilePos;
        i = PILIORead(pPage->file, &pPage->pData[pPage->iFilePos], iSize);
        if (i < 0) break;
        pPage->iFilePos += i;
        pPage->iHighWater += i;
        SetEvent((HANDLE)pPage->hEvent);
        Sleep(0); // yield to other threads
    }
    pPage->iHighWater = pPage->iDataSize;
    CloseHandle((HANDLE)pPage->hEvent);
    return 0;
} /* PILReadThread() */
#endif // BOGUS

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetJPEGExtended(...)                                       *
 *                                                                          *
 *  PURPOSE    : Decode loop for DCT extended (12-bit) mode.                *
 *                                                                          *
 ****************************************************************************/
int GetJPEGExtended(PIL_PAGE *inpage, BUFFERED_BITS *bb, signed short *pMCU, JPEGDATA *pJPEG, unsigned char *cOutput)
{
    int iErr = 0;
    int cx, cy, x, y, lsize;
    int iLum0;
    signed int iDCPred0;
    signed short s;
    int i, iQuant1;
    uint32_t *pl, l;
    unsigned char cDCTable0, cACTable0;
    
    // for now, we only support 12-bit grayscale
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
//    lsize = inpage->iPitch;
    iDCPred0 = 0;
    // luminance values are always in these positions
    iLum0 = MCU0;
    cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
    cy = (inpage->iHeight + 7)>>3;
    iQuant1 = pJPEG->sQuantTable[pJPEG->JPCI[0].quant_tbl_no*DCTSIZE2];
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            if (bb->pBuf > &inpage->pData[inpage->iDataSize+4])
                return PIL_ERROR_DECOMP; // problem
            //          if (inpage->cState == PIL_PAGE_STATE_OPEN && *iOff > inpage->iHighWater) // need to read more data
            //             {
            //             if (inpage->iFilePos >= inpage->iDataSize) // no more data to read
            //                return PIL_ERROR_DECOMP; // fatal error
            //             else
            //                PILReadBlock(inpage, iOff); // read the next chunk of data
            //             }
            //          _m_prefetch(&inpage->pData[*iOff + 64]); // prefetch data to save time
            pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
            pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
            // do the first luminance component
            iErr = JPEGDecodeMCU(bb, &pMCU[iLum0], pJPEG, &iDCPred0);
            if (pJPEG->ucMaxACCol == 0) // no AC components, save some time
            {
                s = (signed short)((iDCPred0 * iQuant1)>>5);
                s += 2048; // adjust for center value
                if (s < 0) s = 0;
                else if (s > 0xfff) s = 0xfff;
                pl = (uint32_t *)&pMCU[iLum0];
                l = (uint32_t)s;
                l |= (l << 16); // store 2 pixels at a time
                for (i=0; i<32; i++)
                    *pl++ = l;
            }
            else
            {
                JPEGIDCT12(pJPEG, &pMCU[iLum0], pJPEG->JPCI[0].quant_tbl_no); // first quantization table
            }
            
            JPEGPutMCUGray12(inpage, pMCU, cOutput, x, y, lsize);
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = 0; // reset DC predictors
                    if (bb->ulBitOff & 7) // need to start at the next even byte
                    {
                        bb->ulBitOff += (8 - (bb->ulBitOff & 7));  // new restart interval starts on byte boundary
                        //                   *iBit = 0;
                        //                   (*iOff)++;
                    }
                }
            }
        }
    }
    
    return iErr;
} /* GetJPEGExtended() */

/***************************************************************************
 *                                                                          *
 *  FUNCTION   : PILDecodeJPEGSlice(...)                                    *
 *                                                                          *
 *  PURPOSE    : Decode a "slice" of a JPEG image. Used to allow multiple   *
 *               threads to decode an image in parallel. Each slice         *
 *               represents 1 or more MCU rows of the image.                *
 *                                                                          *
 ****************************************************************************/
void PILDecodeJPEGSlice(void *pInStruct)
{
    int cx, cy, x, y, lsize;
    int iLum0, iLum1, iLum2, iLum3, iCr, iCb;
    signed int iDCPred0, iDCPred1, iDCPred2, iDCPred3;
    int i, iQuant1, iQuant2, iQuant3, iErr;
    signed int iDCPreds[4];
    unsigned char c;
    uint32_t l;
    unsigned char cDCTable0, cACTable0, cDCTable1, cACTable1, cDCTable2, cACTable2;
    JPEG_SLICE *pSlice;
    JPEGDATA *pJPEG, *pMiniJPEG;
    int *iDummy[32]; // need to create a dummy JPEGDATA structure to swap Huffman table pointers for each thread
    BUFFERED_BITS *bb, bbstruct;
    signed short *pMCU;
    PIL_PAGE inpage;
    pSlice = (JPEG_SLICE *) pInStruct;
    pJPEG = pSlice->pJPEG;
    pSlice->uiResCount = pSlice->uiResInterval;
    pMCU = &pSlice->pMCU[0];
    inpage.iWidth = pSlice->uiWidth;
    inpage.iHeight = pSlice->uiHeight;
    pMiniJPEG = (JPEGDATA *)&iDummy[0];
    pMiniJPEG->b11Bit = pJPEG->b11Bit;
    pMiniJPEG->iOptions = pJPEG->iOptions;
    bb = &bbstruct;
    bbstruct.pBuf = pSlice->pData;
    bbstruct.ulBitOff = pSlice->uiBitOffset;
#ifdef _64BITS
    bbstruct.ulBits = MOTOEXTRALONG(pSlice->pData); // preload first 8 bytes
#else
    bbstruct.ulBits = MOTOLONG(pSlice->pData); // preload first 4 bytes
#endif
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    
    lsize = pSlice->uiPitch;
    iDCPreds[0] = iDCPred0 = pSlice->iDCPred0; // starting DC values for this slice
    iDCPreds[1] = iDCPred1 = pSlice->iDCPred1;
    iDCPreds[2] = iDCPred2 = pSlice->iDCPred2;
    iDCPreds[3] = iDCPred3 = pSlice->iDCPred3;
    
    // luminance values are always in these positions
    iLum0 = MCU0;
    iLum1 = MCU1;
    iLum2 = MCU2;
    iLum3 = MCU3;
    if (pJPEG->ucNumComponents == 4) // DEBUG - hacked value for YCCK & CMYK
    {
        pJPEG->jpegsample = 0x01;
    }
    
    switch (pJPEG->jpegsample) // set up the parameters for the different subsampling options
    {
        case 0x00: // hacked value to handle grayscale
        case 0x01: // hacked value to handle sRGB/CMYK
        case 0x11:
            cx = (pSlice->uiWidth + 7) >> 3;  // number of MCU blocks
            cy = (pSlice->uiHeight + 7) >> 3;
            iCr = MCU1;
            iCb = MCU2;
            break;
        case 0x12:
            cx = (pSlice->uiWidth + 7) >> 3;  // number of MCU blocks
            cy = (pSlice->uiHeight + 15) >> 4;
            iCr = MCU2;
            iCb = MCU3;
            break;
        case 0x21:
            cx = (pSlice->uiWidth + 15) >> 4;  // number of MCU blocks
            cy = (pSlice->uiHeight + 7) >> 3;
            iCr = MCU2;
            iCb = MCU3;
            break;
        case 0x22:
            cx = (pSlice->uiWidth + 15) >> 4;  // number of MCU blocks
            cy = (pSlice->uiHeight + 15) >> 4;
            iCr = MCU4;
            iCb = MCU5;
            break;
        default: // to suppress compiler warning
            cx = cy = 0;
            iCr = iCb = 0;
            break;
    }
    iQuant1 = pJPEG->sQuantTable[pJPEG->JPCI[0].quant_tbl_no*DCTSIZE2];
    iQuant2 = pJPEG->sQuantTable[pJPEG->JPCI[1].quant_tbl_no*DCTSIZE2];
    iQuant3 = pJPEG->sQuantTable[pJPEG->JPCI[2].quant_tbl_no*DCTSIZE2];
    iErr = 0;
    for (y = 0; y<cy; y++)
    {
        for (x = 0; x<cx; x++)
        {
            if (bb->pBuf > &pSlice->pData[pSlice->uiLen + 4])
            {
                pSlice->uiFlag = PIL_THREAD_COMPLETE; // completed
                pSlice->iError = PIL_ERROR_DECOMP; // problem
                return;
            }
            if (pJPEG->ucNumComponents != 4) // do Y component for grayscale and YCrCb images
            {
                pMiniJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
                pMiniJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
                // do the first luminance component
                iErr = JPEGDecodeMCU(bb, &pMCU[iLum0], pMiniJPEG, &iDCPred0);
                if (pMiniJPEG->ucMaxACCol == 0) // no AC components, save some time
                {
                    c = pJPEG->cRangeTable[((iDCPred0 * iQuant1) >> 5) & 0x3ff];
                    l = c | ((uint32_t) c << 8) | ((uint32_t) c << 16) | ((uint32_t) c << 24);
                    // dct stores byte values
                    for (i = 0; i<32; i++) // 8x8 bytes = 32 shorts
                        pMCU[iLum0 + i] = (signed short) l;
                }
                else
                {
                    JPEGIDCT(pJPEG, &pMCU[iLum0], pJPEG->JPCI[0].quant_tbl_no, (pMiniJPEG->ucMaxACCol | (pMiniJPEG->ucMaxACRow << 8))); // first quantization table
                }
            }
            // do the second luminance component
            if (pJPEG->jpegsample > 0x11) // subsampling
            {
                iErr |= JPEGDecodeMCU(bb, &pMCU[iLum1], pMiniJPEG, &iDCPred0);
                if (pMiniJPEG->ucMaxACCol == 0) // no AC components, save some time
                {
                    c = pJPEG->cRangeTable[((iDCPred0 * iQuant1) >> 5) & 0x3ff];
                    l = c | ((uint32_t) c << 8) | ((uint32_t) c << 16) | ((uint32_t) c << 24);
                    // dct stores byte values
                    for (i = 0; i<32; i++) // 8x8 bytes = 32 shorts
                        pMCU[iLum1 + i] = (signed short) l;
                }
                else
                {
                    JPEGIDCT(pJPEG, &pMCU[iLum1], pJPEG->JPCI[0].quant_tbl_no, (pMiniJPEG->ucMaxACCol | (pMiniJPEG->ucMaxACRow << 8))); // first quantization table
                }
                if (pJPEG->jpegsample == 0x22)
                {
                    iErr |= JPEGDecodeMCU(bb, &pMCU[iLum2], pMiniJPEG, &iDCPred0);
                    if (pMiniJPEG->ucMaxACCol == 0) // no AC components, save some time
                    {
                        c = pJPEG->cRangeTable[((iDCPred0 * iQuant1) >> 5) & 0x3ff];
                        l = c | ((uint32_t) c << 8) | ((uint32_t) c << 16) | ((uint32_t) c << 24);
                        // dct stores byte values
                        for (i = 0; i<32; i++) // 8x8 bytes = 32 shorts
                            pMCU[iLum2 + i] = (signed short) l;
                    }
                    else
                    {
                        JPEGIDCT(pJPEG, &pMCU[iLum2], pJPEG->JPCI[0].quant_tbl_no, (pMiniJPEG->ucMaxACCol | (pMiniJPEG->ucMaxACRow << 8))); // first quantization table
                    }
                    iErr |= JPEGDecodeMCU(bb, &pMCU[iLum3], pMiniJPEG, &iDCPred0);
                    if (pMiniJPEG->ucMaxACCol == 0) // no AC components, save some time
                    {
                        c = pJPEG->cRangeTable[((iDCPred0 * iQuant1) >> 5) & 0x3ff];
                        l = c | ((uint32_t) c << 8) | ((uint32_t) c << 16) | ((uint32_t) c << 24);
                        // dct stores byte values
                        for (i = 0; i<32; i++) // 8x8 bytes = 32 shorts
                            pMCU[iLum3 + i] = (signed short) l;
                    }
                    else
                    {
                        JPEGIDCT(pJPEG, &pMCU[iLum3], pJPEG->JPCI[0].quant_tbl_no, (pMiniJPEG->ucMaxACCol | (pMiniJPEG->ucMaxACRow << 8))); // first quantization table
                    }
                } // if 2:2 subsampling
            } // if subsampling used
            if (pJPEG->jpegsample == 0x01) // sRGB/CMYK
            {
                int comp;
                for (comp = 0; comp<4; comp++)
                {
                    pMiniJPEG->pHuffACFast = pJPEG->huffacFast[pJPEG->JPCI[comp].ac_tbl_no];
                    pMiniJPEG->pHuffDCFast = pJPEG->huffdcFast[pJPEG->JPCI[comp].dc_tbl_no];
                    iErr |= JPEGDecodeMCU(bb, &pMCU[MCU1*comp], pMiniJPEG, &iDCPreds[comp]);
                    if (pMiniJPEG->ucMaxACCol == 0) // no AC components, save some time
                    {
                        c = pJPEG->cRangeTable[((iDCPreds[comp] * pJPEG->sQuantTable[pJPEG->JPCI[comp].quant_tbl_no*DCTSIZE2]) >> 5) & 0x3ff];
                        l = c | ((uint32_t) c << 8) | ((uint32_t) c << 16) | ((uint32_t) c << 24);
                        // dct stores byte values
                        for (i = 0; i<32; i++) // 8x8 bytes = 32 shorts
                            pMCU[(MCU1*comp) + i] = (signed short) l;
                    }
                    else
                    {
                        JPEGIDCT(pJPEG, &pMCU[MCU1*comp], pJPEG->JPCI[comp].quant_tbl_no, (pMiniJPEG->ucMaxACCol | (pMiniJPEG->ucMaxACRow << 8)));
                    }
                } // for the 3 other CMYK color components
            } // if CMYK
            if (pJPEG->jpegsample && pJPEG->ucNumComponents == 3) // if color (not CMYK)
            {
                // first chroma
                pMiniJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                pMiniJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                iErr |= JPEGDecodeMCU(bb, &pMCU[iCr], pMiniJPEG, &iDCPred1);
                if (pMiniJPEG->ucMaxACCol == 0) // no AC components, save some time
                {
                    c = pJPEG->cRangeTable[((iDCPred1 * iQuant2) >> 5) & 0x3ff];
                    l = c | ((uint32_t) c << 8) | ((uint32_t) c << 16) | ((uint32_t) c << 24);
                    // dct stores byte values
                    for (i = 0; i<32; i++) // 8x8 bytes = 32 shorts
                        pMCU[iCr + i] = (signed short) l;
                }
                else
                {
                    JPEGIDCT(pJPEG, &pMCU[iCr], pJPEG->JPCI[1].quant_tbl_no, (pMiniJPEG->ucMaxACCol | (pMiniJPEG->ucMaxACRow << 8))); // second quantization table
                }
                // second chroma
                pMiniJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                pMiniJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                iErr |= JPEGDecodeMCU(bb, &pMCU[iCb], pMiniJPEG, &iDCPred2);
                if (iErr)
                {
                    pSlice->uiFlag = PIL_THREAD_COMPLETE; // completed
                    pSlice->iError = iErr; // problem
                    return; // decoding error, stop
                }
                if (pMiniJPEG->ucMaxACCol == 0) // no AC components, save some time
                {
                    c = pJPEG->cRangeTable[((iDCPred2 * iQuant3) >> 5) & 0x3ff];
                    l = c | ((uint32_t) c << 8) | ((uint32_t) c << 16) | ((uint32_t) c << 24);
                    // dct stores byte values
                    for (i = 0; i<32; i++) // 8x8 bytes = 32 shorts
                        pMCU[iCb + i] = (signed short) l;
                }
                else
                {
                    JPEGIDCT(pJPEG, &pMCU[iCb], pJPEG->JPCI[2].quant_tbl_no, (pMiniJPEG->ucMaxACCol | (pMiniJPEG->ucMaxACRow << 8)));
                }
            } // if color components present
            
            switch (pJPEG->jpegsample)
            {
                case 0x00: // grayscale
                    JPEGPutMCUGray(&inpage, (unsigned char *) pMCU, pSlice->pBitmap, pJPEG, x, y, lsize);
                    break;
                case 0x01: // YCCK/CMYK
                    if (pJPEG->iOptions & PIL_CONVERT_JPEG_YCCK) // Adobe encoded a YCCK image as a 4-component JPEG
                    {
                        //                    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                        //                        JPEGPutMCURGBHALF(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                        //                    else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                        //                        JPEGPutMCURGBQUARTER(x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                        //                    else
                        JPEGPutMCUYCCK(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG);
                    }
                    else
                    {
                        if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                            JPEGPutMCUCMYKHALF(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image as CMYK
                        else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                            JPEGPutMCUCMYKQUARTER(x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image as CMYK
                        else
                            JPEGPutMCUCMYK(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image as CMYK
                    }
                    break;
                case 0x11:
                    if (pJPEG->iOptions & PIL_CONVERT_JPEG_RGB) // Adobe encoded a RGB image as JPEG
                    { // it can't be subsampled, so 1:1 is the only place it can be
                        if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                            JPEGPutMCURGBHALF(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                        else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                            JPEGPutMCURGBQUARTER(x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                        else
                            JPEGPutMCURGB(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG);
                    }
                    else
                    {
                        if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                            JPEGPutMCU11HALF(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                        else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                            JPEGPutMCU11QUARTER(x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                        else
                            JPEGPutMCU11(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    }
                    break;
                case 0x12:
                    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                        JPEGPutMCU12HALF(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                        JPEGPutMCU12QUARTER(x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    else
                        JPEGPutMCU12(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    break;
                case 0x21:
                    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                        JPEGPutMCU21HALF(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                        JPEGPutMCU21QUARTER(x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    else
                    {
//                        if (pJPEG->iOptions & PIL_CONVERT_SIMD)
//                            JPEGPutMCU21_SIMD(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
//                        else
                            JPEGPutMCU21(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    }
                    break;
                case 0x22:
                    if (pJPEG->iOptions & PIL_CONVERT_HALFSIZE)
                        JPEGPutMCU22HALF(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    else if (pJPEG->iOptions & PIL_CONVERT_QUARTERSIZE)
                        JPEGPutMCU22QUARTER(x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    else
                    {
//                        if (pJPEG->iOptions & PIL_CONVERT_SIMD)
//                            JPEGPutMCU22_SIMD(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
//                        else
                            JPEGPutMCU22(&inpage, x, y, lsize, &pMCU[0], pSlice->pBitmap, pJPEG); // lay down MCU in output image
                    }
                    break;
            } // switch on color option
            if (pSlice->uiResInterval)
            {
                if (--pSlice->uiResCount == 0)
                {
                    pSlice->uiResCount = pSlice->uiResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                    iDCPreds[0] = iDCPreds[1] = iDCPreds[2] = iDCPreds[3] = 0;
                    if (bb->ulBitOff & 7) // need to start at the next even byte
                    {
                        bb->ulBitOff += (8 - (bb->ulBitOff & 7));  // new restart interval starts on byte boundary
                        //                   *iBit = 0;
                        //                   (*iOff)++;
                    }
                } // if restart interval needs to reset
            } // if there is a restart interval
        } // for x
    } // for y
    pSlice->uiFlag = PIL_THREAD_COMPLETE; // completed
    pSlice->iError = 0; // no problem!
    return;
} /* PILDecodeJPEGSlice() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : GetJPEGLuma(...)                                           *
 *                                                                          *
 *  PURPOSE    : Decode loop for luma extraction of color image.            *
 *                                                                          *
 ****************************************************************************/
int GetJPEGLuma(PIL_PAGE *inpage, BUFFERED_BITS *bb, signed short *pMCU, JPEGDATA *pJPEG, unsigned char *cOutput, PILPROGRESS pfnProgress)
{
    int cx, cy, x, y, lsize;
    int iLum0, iLum1, iLum2, iLum3, iCr, iCb;
    signed int iDCPred0, iDCPred1, iDCPred2;
    int i, iQuant1, iErr;
    unsigned char c;
    uint32_t l;
    unsigned char cDCTable0, cACTable0, cDCTable1, cACTable1, cDCTable2, cACTable2;
    //#ifndef _WIN32_WCE
    //HANDLE hThread;
    //#endif
    
    //#ifndef _WIN32_WCE
    //    hThread = CreateThread(NULL, 0, PILReadThread, (LPVOID)inpage, 0, NULL);
    //#endif
    
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    
//    lsize = PILCalcSize(inpage->iWidth, 8);
    iDCPred0 = iDCPred1 = iDCPred2 = 0;
    // luminance values are always in these positions
    iLum0 = MCU0;
    iLum1 = MCU1;
    iLum2 = MCU2;
    iLum3 = MCU3;
    switch (pJPEG->jpegsample) // set up the parameters for the different subsampling options
    {
        case 0x00: // hacked value to handle grayscale
        case 0x11:
            cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
            cy = (inpage->iHeight + 7)>>3;
            iCr = MCU1;
            iCb = MCU2;
            break;
        case 0x12:
            cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
            cy = (inpage->iHeight + 15)>>4;
            iCr = MCU2;
            iCb = MCU3;
            break;
        case 0x21:
            cx = (inpage->iWidth + 15)>>4;  // number of MCU blocks
            cy = (inpage->iHeight + 7)>>3;
            iCr = MCU2;
            iCb = MCU3;
            break;
        case 0x22:
            cx = (inpage->iWidth + 15)>>4;  // number of MCU blocks
            cy = (inpage->iHeight + 15)>>4;
            iCr = MCU4;
            iCb = MCU5;
            break;
        default: // to suppress compiler warning
            cx = cy = 0;
            iCr = iCb = 0;
            break;
    }
    iQuant1 = pJPEG->sQuantTable[0];
    //    iQuant2 = pJPEG->sQuantTable[DCTSIZE2];
    for (y=0; y<cy; y++)
    {
        if (!(y & 15) && pfnProgress) // call progress function to display current progress
        {
            if ((*pfnProgress)(y, cy) == PIL_PROGRESS_CANCEL)
                return PIL_ERROR_CANCELED;
        }
        
        for (x=0; x<cx; x++)
        {
            if (bb->pBuf > &inpage->pData[inpage->iDataSize+4])
                return PIL_ERROR_DECOMP; // problem
            //          if (inpage->cState == PIL_PAGE_STATE_OPEN && *iOff > inpage->iHighWater) // need to read more data
            //             {
            //             if (inpage->iFilePos >= inpage->iDataSize) // no more data to read
            //                return PIL_ERROR_DECOMP; // fatal error
            //             else
            //                PILReadBlock(inpage, iOff); // read the next chunk of data
            //             }
            //          _m_prefetch(&inpage->pData[*iOff + 64]); // prefetch data to save time
            pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
            pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
            // do the first luminance component
            iErr = JPEGDecodeMCU(bb, &pMCU[iLum0], pJPEG, &iDCPred0);
            if (pJPEG->ucMaxACCol == 0) // no AC components, save some time
            {
                c = pJPEG->cRangeTable[((iDCPred0 * iQuant1)>>5) & 0x3ff];
                l = c | ((uint32_t)c << 8) | ((uint32_t)c << 16) | ((uint32_t)c << 24);
                // dct stores byte values
                for (i=0; i<32; i++) // 8x8 bytes = 32 shorts
                    pMCU[iLum0+i] = (signed short)l;
            }
            else
            {
                //             JPEGFixOrder(&pMCU[iLum0], &pMCU[iLum0 + MCUTEMP]);
                JPEGIDCT(pJPEG, &pMCU[iLum0], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
            }
            // do the second luminance component
            if (pJPEG->jpegsample > 0x11) // subsampling
            {
                iErr |= JPEGDecodeMCU(bb, &pMCU[iLum1], pJPEG, &iDCPred0);
                if (pJPEG->ucMaxACCol == 0) // no AC components, save some time
                {
                    c = pJPEG->cRangeTable[((iDCPred0 * iQuant1)>>5) & 0x3ff];
                    l = c | ((uint32_t)c << 8) | ((uint32_t)c << 16) | ((uint32_t)c << 24);
                    // dct stores byte values
                    for (i=0; i<32; i++) // 8x8 bytes = 32 shorts
                        pMCU[iLum1+i] = (signed short)l;
                }
                else
                {
                    //             JPEGFixOrder(&pMCU[iLum1], &pMCU[iLum1 + MCUTEMP]);
                    JPEGIDCT(pJPEG, &pMCU[iLum1], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                }
                if (pJPEG->jpegsample == 0x22)
                {
                    iErr |= JPEGDecodeMCU(bb, &pMCU[iLum2], pJPEG, &iDCPred0);
                    if (pJPEG->ucMaxACCol == 0) // no AC components, save some time
                    {
                        c = pJPEG->cRangeTable[((iDCPred0 * iQuant1)>>5) & 0x3ff];
                        l = c | ((uint32_t)c << 8) | ((uint32_t)c << 16) | ((uint32_t)c << 24);
                        // dct stores byte values
                        for (i=0; i<32; i++) // 8x8 bytes = 32 shorts
                            pMCU[iLum2+i] = (signed short)l;
                    }
                    else
                    {
                        //             JPEGFixOrder(&pMCU[iLum2], &pMCU[iLum2 + MCUTEMP]);
                        JPEGIDCT(pJPEG, &pMCU[iLum2], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                    }
                    iErr |= JPEGDecodeMCU(bb, &pMCU[iLum3], pJPEG, &iDCPred0);
                    if (pJPEG->ucMaxACCol == 0) // no AC components, save some time
                    {
                        c = pJPEG->cRangeTable[((iDCPred0 * iQuant1)>>5) & 0x3ff];
                        l = c | ((uint32_t)c << 8) | ((uint32_t)c << 16) | ((uint32_t)c << 24);
                        // dct stores byte values
                        for (i=0; i<32; i++) // 8x8 bytes = 32 shorts
                            pMCU[iLum3+i] = (signed short)l;
                    }
                    else
                    {
                        //             JPEGFixOrder(&pMCU[iLum3], &pMCU[iLum3 + MCUTEMP]);
                        JPEGIDCT(pJPEG, &pMCU[iLum3], 0, (pJPEG->ucMaxACCol | (pJPEG->ucMaxACRow << 8))); // first quantization table
                    }
                } // if 2:2 subsampling
            } // if subsampling used
            if (pJPEG->jpegsample) // if color
            {
                // first chroma
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                iErr |= JPEGDecodeMCU(bb, &pMCU[iCr], pJPEG, &iDCPred1);
                // second chroma
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                iErr |= JPEGDecodeMCU(bb, &pMCU[iCb], pJPEG, &iDCPred2);
                if (iErr)
                    return iErr; // decoding error, stop
            } // if color components present
            
            // copy the pixels from this MCU into the output image
            switch (pJPEG->jpegsample)
            {
                case 0x00: // grayscale
                case 0x11: // treated the same as grayscale
                    JPEGPutMCUGray(inpage, (unsigned char *)pMCU, cOutput, pJPEG, x, y, lsize);
                case 0x12:
                case 0x21:
                case 0x22:
                    JPEGPutLuma(x, y, lsize, &pMCU[0], cOutput, pJPEG); // lay down MCU in output image
                    break;
            } // switch on color option
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                    if (bb->ulBitOff & 7) // need to start at the next even byte
                    {
                        bb->ulBitOff += (8 - (bb->ulBitOff & 7));  // new restart interval starts on byte boundary
                        //                   *iBit = 0;
                        //                   (*iOff)++;
                    }
                }
            }
        }
    }
    //#ifndef _WIN32_WCE
    //    CloseHandle(hThread);
    //#endif
    return 0;
} /* GetJPEGLuma() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU12(int, int, int, int*, char *)                  *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU12(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1, Y2;
    int iRow, iCol, iXCount, iYCount;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU2];
    pCr = (unsigned char *)&pMCU[MCU3];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*16*lsize; // destination 8x16 block of output image
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<4;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<5;
    else
        cOutput += x*24;
    if (y*16+15 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 15;
    else
        iYCount = 16;
    if (x*8+7 >= inpage->iWidth)
        iXCount = inpage->iWidth & 7;
    else
        iXCount = 8;
    for (iRow=0; iRow<iYCount; iRow+=2) // up to 16 rows to do
    {
        for (iCol=0; iCol<iXCount; iCol++) // up to 8 cols to do
        {
            Y1 = pY[iCol];
            Y2 = pY[iCol+8];
            Y1 <<= 12;  // scale to level of conversion table
            Y2 <<= 12;
            Cb = pCb[iCol];
            Cr = pCr[iCol];
            JPEGPixel(pJPEG, cOutput, iCol, Y1, Cb, Cr);
            JPEGPixel(pJPEG, cOutput+lsize, iCol, Y2, Cb, Cr);
        }
        pY += 16; // skip to next 2 lines of source pixels
        if (iRow == 6) // next MCU block, skip ahead to correct spot
            pY += (128-64);
        pCb += 8;
        pCr += 8;
        cOutput += lsize*2; // next 2 lines of dest pixels
    }
    
} /* JPEGPutMCU12() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU12HALF(int, int, int, int*, char *)              *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU12HALF(PIL_PAGE *inpage, int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1;
    int iRow, iCol, iXCount, iYCount;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU2];
    pCr = (unsigned char *)&pMCU[MCU3];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*8*lsize; // destination 8x16 block of output image
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<3;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<4;
    else
        cOutput += x*24;
    if (y*16+15 >= inpage->iHeight)  // if last block overflows bottom of image
        iYCount = inpage->iHeight & 15;
    else
        iYCount = 16;
    if (x*8+7 >= inpage->iWidth)
        iXCount = (inpage->iWidth & 7)>>1;
    else
        iXCount = 4;
    for (iRow=0; iRow<iYCount; iRow+=2) // up to 16 rows to do
    {
        for (iCol=0; iCol<iXCount; iCol++) // up to 8 cols to do
        {
            Y1 = pY[iCol*2];
            Y1 += pY[iCol*2+1];
            Y1 += pY[iCol*2+8];
            Y1 += pY[iCol*2+9];
            Y1 <<= 10;  // scale to level of conversion table
            Cb = pCb[iCol*2];
            Cb += pCb[iCol*2+1];
            Cb >>= 1;
            Cr = pCr[iCol*2];
            Cr += pCr[iCol*2+1];
            Cr >>= 1;
            JPEGPixel(pJPEG, cOutput, iCol, Y1, Cb, Cr);
        }
        pY += 16; // skip to next line of source pixels
        if (iRow == 6) // skip to next MCU block
            pY += (128-64);
        pCb += 8;
        pCr += 8;
        cOutput += lsize; // next line of dest pixels
    }
    
} /* JPEGPutMCU12HALF() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGPutMCU12QUARTER(int, int, int, int*, char *)           *
 *                                                                          *
 *  PURPOSE    : Combine and output a subsampled color macro block.         *
 *                                                                          *
 ****************************************************************************/
void JPEGPutMCU12QUARTER(int x, int y, int lsize, signed short *pMCU, unsigned char *cOutput, JPEGDATA *pJPEG)
{
    uint32_t Cr,Cb;
    signed int Y1;
    unsigned char *pY, *pCr, *pCb;
    
    pY  = (unsigned char *)&pMCU[MCU0];
    pCb = (unsigned char *)&pMCU[MCU2];
    pCr = (unsigned char *)&pMCU[MCU3];
    
    /* Convert YCC pixels into RGB pixels and store in output image */
    cOutput += y*4*lsize; // destination 2x4 block of output image
    if (pJPEG->iOptions & PIL_CONVERT_16BPP)
        cOutput += x<<2;
    else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
        cOutput += x<<3;
    else
        cOutput += x*6;
    Y1  = pY[0] << 12; // scale to level of conversion table
    Cb  = pCb[0];
    Cr  = pCr[0];
    JPEGPixel(pJPEG, cOutput, 0, Y1, Cb, Cr);
    Y1  = pY[2] << 12; // scale to level of conversion table
    JPEGPixel(pJPEG, cOutput+lsize, 0, Y1, Cb, Cr);
    Y1  = pY[1] << 12; // scale to level of conversion table
    Cb  = pCb[1];
    Cr  = pCr[1];
    JPEGPixel(pJPEG, cOutput, 1, Y1, Cb, Cr);
    Y1  = pY[3] << 12; // scale to level of conversion table
    JPEGPixel(pJPEG, cOutput+lsize, 1, Y1, Cb, Cr);
    cOutput += lsize*2;
    pY += DCTSIZE2*2;
    Y1  = pY[0] << 12; // scale to level of conversion table
    Cb  = pCb[2];
    Cr  = pCr[2];
    JPEGPixel(pJPEG, cOutput, 0, Y1, Cb, Cr);
    Y1  = pY[2] << 12; // scale to level of conversion table
    JPEGPixel(pJPEG, cOutput+lsize, 0, Y1, Cb, Cr);
    Y1  = pY[1] << 12; // scale to level of conversion table
    Cb  = pCb[3];
    Cr  = pCr[3];
    JPEGPixel(pJPEG, cOutput, 1, Y1, Cb, Cr);
    Y1  = pY[3] << 12; // scale to level of conversion table
    JPEGPixel(pJPEG, cOutput+lsize, 1, Y1, Cb, Cr);
    
} /* JPEGPutMCU12QUARTER() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILFreeHuffTables()                                        *
 *                                                                          *
 *  PURPOSE    : Free the Huffman decode tables.                            *
 *                                                                          *
 ****************************************************************************/
void PILFreeHuffTables(JPEGDATA *pJPEG)
{
    
    memset(&pJPEG->ucHuffTableUsed, 0, sizeof(pJPEG->ucHuffTableUsed));
    return;
    
} /* PILFreeHuffTables() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILGetEXIFInfo(char *, int, int, int, PIL_PAGE *)         *
 *                                                                          *
 *  PURPOSE    : Try to extract useful info from the JPEG EXIF header.      *
 *                                                                          *
 ****************************************************************************/
void PILGetEXIFInfo(unsigned char *buf, int iEXIF1, int iEXIF2, int bMotorola, PIL_PAGE *outpage)
{
    int iCount, iOffset, j, k, x, y;
    int iMNOffset, iMNLen, iMarker;
    int iMaker = 0;
    TCHAR szTemp[256];
#ifdef _UNICODE
    size_t returnval;
#endif
    
#ifdef _UNICODE
    mbstowcs_s(&returnval, szTemp, 256, outpage->szMake, strlen(outpage->szMake)+1);
#else
//    if (strlen(outpage->szMake) < 256) // can be a corrupt string
//    {
//        strcpy((char *) szTemp, (char *) outpage->szMake);
//    }
//    else
//    {
//        szTemp[0] = '\0'; // no string
//    }
#endif	// #ifdef _UNICODE
    
#ifdef _UNICODE
    _wcsupr_s(szTemp, 256);
    if (wcscmp(szTemp, TEXT("CANON")) == 0)
        iMaker = 1;
    if (wcscmp(szTemp, TEXT("SONY")) == 0)
        iMaker = 2;
    if (wcscmp(szTemp, TEXT("EASTMAN KODAK COMPANY")) == 0)
        iMaker = 3;
    if (wcscmp(szTemp, TEXT("RICOH      ")) == 0)
        iMaker = 4;
    if (wcscmp(szTemp, TEXT("NIKON")) == 0) // Nikon Type II
        iMaker = 5;
#else
    strupr((char *) szTemp);
    if (strcmp((char *) szTemp, (char *) "CANON") == 0)
        iMaker = 1;
    if (strcmp((char *) szTemp, (char *) "SONY") == 0)
        iMaker = 2;
    if (strcmp((char *) szTemp, (char *) "EASTMAN KODAK COMPANY") == 0)
        iMaker = 3;
    if (strcmp((char *) szTemp, (char *) "RICOH      ") == 0)
        iMaker = 4;
    if (strcmp((char *) szTemp, (char *) "NIKON") == 0) // Nikon Type II
        iMaker = 5;
#endif
    
    iMNLen = 0;
    iMNOffset = 0;
    // Walk the EXIF subIFD for tags we want
    k = iEXIF1 + iEXIF2; // start of IFD
    iCount = PILTIFFSHORT(&buf[k], bMotorola); // tag count
    k += 2;
    if (iCount > 64) // something is very wrong, leave
        return;
    for (j=0; j<iCount; j++) // search for useful info
    {
        iMarker = PILTIFFSHORT(&buf[k], bMotorola);
        switch (iMarker)
        {
            case 0x829a: // shutter speed
                iOffset = PILTIFFVALUE(&buf[k], bMotorola) + iEXIF1;
                if (iOffset >=0 && iOffset < 0x8000)
                {
                    x = PILTIFFLONG(&buf[iOffset], bMotorola);
                    y = PILTIFFLONG(&buf[iOffset+4], bMotorola);
                    if (x != 0)
                        outpage->iShutter = y / x; // reverse rational since it is a fractional value of 1/n
                }
                break;
            case 0x829d: // F number
                iOffset = PILTIFFVALUE(&buf[k], bMotorola) + iEXIF1;
                if (iOffset >= 0 && iOffset < 0x8000)
                {
                    x = PILTIFFLONG(&buf[iOffset], bMotorola);
                    y = PILTIFFLONG(&buf[iOffset+4], bMotorola);
                    if (y != 0)
                        outpage->iFStop = (x*10) / y;
                }
                break;
            case 0x8822: // exposure program
                outpage->iExposureProgram = PILTIFFVALUE(&buf[k], bMotorola);
                break;
            case 0x8827: // ISO speed
                outpage->iISO = PILTIFFVALUE(&buf[k], bMotorola);
                break;
            case 0x9003: // ASCII date and time
                x = PILTIFFVALUE(&buf[k], bMotorola) + iEXIF1; /* Get the offset */
                y = PILTIFFLONG(&buf[k+4], bMotorola); /* Get the count */
                if (y> 31)
                    y = 31; // max we can handle
                if (y < 0)
                    y = 0; // prevent bogus values that would crash
                if (x < 0 || x > 0x10000)
                    y = 0; // same here
                if (y)
                {
                    memset(outpage->szDateTime, 0, 32);
                    if (y <= 4)
                        memcpy(outpage->szDateTime, &buf[k+8], y);
                    else
                        memcpy(outpage->szDateTime, &buf[x], y);
                }
                break;
            case 0x9204: // exposure bias
                iOffset = PILTIFFVALUE(&buf[k], bMotorola) + iEXIF1;
                if (iOffset >=0 && iOffset < 0x8000)
                {
                    x = PILTIFFLONG(&buf[iOffset], bMotorola);
                    y = PILTIFFLONG(&buf[iOffset+4], bMotorola);
                    if (y != 0)
                        outpage->iExposure = (x*10) / y;
                }
                break;
            case 0x9207: // metering mode
                outpage->iMetering = PILTIFFVALUE(&buf[k], bMotorola);
                break;
            case 0x9209: // flash used
                outpage->iFlash = PILTIFFVALUE(&buf[k], bMotorola);
                break;
            case 0x920a: // focal length
                iOffset = PILTIFFVALUE(&buf[k], bMotorola) + iEXIF1;
                if (iOffset >=0 && iOffset < 0x8000)
                {
                    x = PILTIFFLONG(&buf[iOffset], bMotorola);
                    y = PILTIFFLONG(&buf[iOffset+4], bMotorola);
                    if (y != 0)
                        outpage->iFocalLength = (x*10) / y;
                }
                break;
            case 0x927c: // MakerNote - private data unique to each camera
                iMNOffset = PILTIFFLONG(&buf[k+8], bMotorola); // offset to private data
                iMNLen = PILTIFFLONG(&buf[k+4], bMotorola); // length of private data
                break;
            case 0xa002: // true image width
                outpage->iOriginalWidth = PILTIFFVALUE(&buf[k], bMotorola);
                break;
            case 0xa003: // true image height
                outpage->iOriginalHeight = PILTIFFVALUE(&buf[k], bMotorola);
                break;
            case 0xa403: // white balance
                outpage->iWhiteBalance = PILTIFFVALUE(&buf[k], bMotorola);
                break;
            default:
                k |= 0;
                break;
        }
        k += 12; // skip to next tag
    }
    if (iMNLen && iMNOffset < 0x8000 && strcmp((const char *)&buf[iMNOffset+iEXIF1], "Nikon") == 0) // Nikon type 2
        iMaker = 6;
    
    // If we did not get ISO info, try to get it from MakerNote
    if (outpage->iISO == -1 && iMNLen && iMaker)
    {
        k = iMNOffset + iEXIF1; // start of IFD
        iCount = PILTIFFSHORT(&buf[k], bMotorola); // tag count
        k += 2;
        switch (iMaker)
        {
            case 5: // Nikon type 2
                for (j=0; j<iCount; j++) // search for useful info
                {
                    iMarker = PILTIFFSHORT(&buf[k], bMotorola);
                    switch (iMarker)
                    {
                        case 2: // ISO
                            outpage->iISO = PILTIFFSHORT(&buf[k+10], bMotorola);
                            break;
                    }
                    k += 12;
                }
                break; // Nikon type 2
                
            case 6: // Nikon type 1
                k = 8 + iMNOffset + iEXIF1; // start of IFD
                iCount = PILTIFFSHORT(&buf[k], bMotorola); // tag count
                k += 2;
                for (j=0; j<iCount; j++) // search for useful info
                {
                    iMarker = PILTIFFSHORT(&buf[k], bMotorola);
                    switch (iMarker)
                    {
                        case 6: // ISO
                            x = PILTIFFSHORT(&buf[k+8], bMotorola);
                            if (x == 0)
                                outpage->iISO = 80;
                            if (x == 2)
                                outpage->iISO = 160;
                            if (x == 4)
                                outpage->iISO = 320;
                            if (x == 5)
                                outpage->iISO = 100;
                            break;
                    }
                    k += 12;
                }
                break; // Nikon type 1
                
            case 1: // Canon
                for (j=0; j<iCount; j++) // search for useful info
                {
                    iMarker = PILTIFFSHORT(&buf[k], bMotorola);
                    switch (iMarker)
                    {
                        case 1: // useful info for Canon
                            iOffset = PILTIFFLONG(&buf[k+8], bMotorola); // offset to private data
                            x = iOffset+iEXIF1+16*2; // short #16
                            if (PILTIFFSHORT(&buf[x], bMotorola) == 15)
                                outpage->iISO = 0; // Auto
                            if (PILTIFFSHORT(&buf[x], bMotorola) == 16)
                                outpage->iISO = 50;
                            if (PILTIFFSHORT(&buf[x], bMotorola) == 17)
                                outpage->iISO = 100;
                            if (PILTIFFSHORT(&buf[x], bMotorola) == 18)
                                outpage->iISO = 200;
                            if (PILTIFFSHORT(&buf[x], bMotorola) == 19)
                                outpage->iISO = 400;
                            break;
                    }
                    k += 12;
                }
                break; // CANON
        } // switch on camera maker
    } // makernote
} /* PILGetEXIFInfo() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILPrepJPEGStruct(void)                                    *
 *                                                                          *
 *  PURPOSE    : Allocate and initialize the JPEG structure.                *
 *                                                                          *
 ****************************************************************************/
JPEGDATA * PILPrepJPEGStruct(void)
{
    JPEGDATA *p;
    int i;
    
    p = (JPEGDATA *) PILIOAllocNoClear(sizeof(JPEGDATA));
    if (p)
    {
        memset(p, 0, sizeof(JPEGDATA)); // clear all fields
        /* Create a range clipping table for results of multiplications */
        for (i=0; i<128; i++)
        {
            p->cRangeTable[i] = (unsigned char)(0x80 + i);
            p->cRangeTable[i+896] = (unsigned char)i;
        }
        for (i=0; i<384; i++)
        {
            p->cRangeTable[i+128] = 0xff;
            p->cRangeTable[i+512] = 0;
        }
        // setup the pointers to the Huffman decode tables
        for (i=0; i<4; i++)
        {
//            p->huffdcFast[i] = (int *)&p->ucHuffACDCBuf[i*0x100]; // first 256 bytes is fast DC table
//            p->huffdc[i] = (int *)&p->ucHuffACDCBuf[i*0x100 + 0x80]; // next 256 bytes is slow DC table
//            p->huffacFast[i] = (int *)&p->ucHuffACDCBuf[4*0x100 + i*0x1000]; // first 0x800 bytes is fast AC table
//            p->huffac[i] = (int *)&p->ucHuffACDCBuf[4*0x100 + i*0x1000 + 0x800]; // next 0x800 bytes is slow AC table
        }
        JPEGInitTables(p); // set up clipping tables for JPEG pixel conversion
    }
    return p;
    
} /* PILPrepJPEGStruct() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILReadJPEG(PIL_PAGE *, PIL_PAGE *, int)                   *
 *                                                                          *
 *  PURPOSE    : Decode a file or buffer of JPEG data.                      *
 *                                                                          *
 ****************************************************************************/
int PILReadJPEG(char *fname, PIL_PAGE *inpage, PFNDRAWMCU pfnDrawMCU, int iOptions)
{
    //int iMarker;
    int lsize, i, k, iErr, iOff, iAltOff, iBit, iScan, iScanTotal;
    //int iRestart = 0; /* Restart interval */
    //int iNumComps = 0; /* Number of color components */
    signed short *pMCU, *pMCUData;
    //int dcPred0; // DC predictor value
    unsigned char *buf, *cOutput;
    JPEGDATA *pJPEG;
    unsigned short us;
    PILOffset iSeekErr;
    int iNumBytes;
    int bThumbnail = FALSE;
    BUFFERED_BITS bb;
    unsigned char cMarker;
    JPEG_SLICE pJPEGSlices[32];
    int iNumThreads, iNumSlices;
    
    pMCU = NULL;
    iErr = PIL_ERROR_SUCCESS;
    if (iOptions & (PIL_CONVERT_THUMBNAIL | PIL_CONVERT_EIGHTHSIZE))
        bThumbnail = TRUE;
    pMCUData = NULL;
    pJPEG = PILPrepJPEGStruct(); /* jpeg tables */
    if (pJPEG == NULL)
    {
       iErr = PIL_ERROR_MEMORY;
       goto getjpgz;
    }
    for (i=0; i<4; i++)
    {
        pJPEG->JPCI[i].h_samp_factor = 1;
        pJPEG->JPCI[i].v_samp_factor = 1;
    }
    pJPEG->ulHeaderFlags = 0; // reset header status flags

// DEBUG - open file here if needed
    inpage->iOffset = 0;
    iSeekErr = PILIOSeek(inpage->file, (PILOffset) inpage->iOffset, 0);
    if (iSeekErr < 0)
    {
       iErr = PIL_ERROR_IO;
       goto getjpgz;
    }
        
    inpage->iFilePos = inpage->iOffset + PIL_BUFFER_SIZE; // next read pos
    iNumBytes = PILIORead(inpage->file, inpage->pData, PIL_BUFFER_SIZE);
        if ((iNumBytes < 0) || (iNumBytes != PIL_BUFFER_SIZE))
        {
            iErr = PIL_ERROR_IO;
            goto getjpgz;
        }
        
        inpage->iOffset = 0;
//    }
//    buf = inpage->pData; // point to raw JPEG data
//    iOff = inpage->iOffset;
    iAltOff = 0;
    //   buf = &inpage->pData[inpage->iOffset]; // point to raw JPEG data
    //   iOff = 0;
    iBit = 0;  /* Pointer into data stream */
    us = MOTOSHORT(buf); /* Do we start with an SOI marker? */
    if (us != 0xffd8)
    {
        if (0) //(inpage->pLocalPalette != NULL && (us & 0xffc0) == 0xffc0) // TIFF type 6 with separate header info
        {
//            us = MOTOSHORT(inpage->pLocalPalette);
            iOff += 0; // nothing to skip
            iAltOff = 2;
//            cMarker = JPEGProcessTables(inpage->pLocalPalette, &iAltOff, pJPEG, inpage->iAnnotationSize, inpage);
            // The SOF marker may have the whole image size, but this is just a strip
            // restore the TIFF image size for this situation
            pJPEG->cx = inpage->iWidth;
            pJPEG->cy = inpage->iHeight;
            if (cMarker != 0xd9) // something went wrong
            {
                iErr = PIL_ERROR_BADHEADER;
                goto getjpgz;
            }
        }
        else
        {
            us = MOTOSHORT(&buf[1]); // Ricoh files have a strange extra byte here
            if (us == 0xffd8)
                iOff += 3;
        }
    }
    else
    {
        iOff += 2;
        // may be a TIFF type 7 file
//        if (inpage->pLocalPalette != NULL && inpage->iAnnotationSize != 0)
//        {
//            iAltOff = 0;
//            cMarker = JPEGProcessTables(inpage->pLocalPalette, &iAltOff, pJPEG, inpage->iAnnotationSize, inpage);
//        }
    }
    if (us != 0xffd8) /* Error not a JPEG file */
    {
        iErr = PIL_ERROR_BADHEADER;
        goto getjpgz;
    }
//    outpage->iXres = inpage->iYres = 1; /* assume no valid resolution info */
    pJPEG->iOptions = 0;
    JPEGGetSOI(pJPEG); /* Process Start Of Image info */
    cMarker = JPEGProcessTables(buf, &iOff, pJPEG, inpage->iDataSize + inpage->iOffset, inpage);
//    outpage->cJPEGMode = (unsigned char)pJPEG->iMode;
//    outpage->cJPEGSubSample = pJPEG->jpegsample;
//    strcpy(outpage->szComment, pJPEG->szComment); // copy any comments from JPEG header
    if (cMarker != 0xda) // we should have processed all of the header up to the SOS
    {
        iErr = PIL_ERROR_BADHEADER;
        goto getjpgz;
    }
    // we now have the image size as read from the Start Of Frame header
    inpage->iWidth = pJPEG->cx;
    inpage->iHeight = pJPEG->cy;
//    outpage->iWidth = pJPEG->cx;
//    outpage->iHeight = pJPEG->cy;
    if (pJPEG->iMode == 0xc0 || pJPEG->iMode == 0xc2) // TIFF JPEG will come here with no bpp info, fix it
    {
        if (pJPEG->ucNumComponents == 1)
            inpage->cBitsperpixel = 8;
        else
            inpage->cBitsperpixel = 24;
    }
    
    if (pJPEG->iMode == 0xc1 || pJPEG->iMode == 0xc3) // we don't support reduced resolution decode of JPEG lossless or extended mode (yet) and output is 8-bpp gray
    {
        bThumbnail = FALSE;
        iOptions &= ~(PIL_CONVERT_HALFSIZE | PIL_CONVERT_QUARTERSIZE | PIL_CONVERT_EIGHTHSIZE | PIL_CONVERT_16BPP | PIL_CONVERT_32BPP);
        inpage->cBitsperpixel = 16; // for now, we convert DICOM output to 16-bpp gray
    }
    pJPEG->iOptions |= iOptions;
    if (iOptions & PIL_CONVERT_16BPP) // force RGB565 output from either RGB888 or grayscale-8
    {
        inpage->cBitsperpixel = 16;
    }
    if (iOptions & PIL_CONVERT_32BPP) // force RGBA888 output from either RGB888 or grayscale-8
    {
        inpage->cBitsperpixel = 32;
    }
//    inpage->iX = inpage->iWidth; // save original image size here
//    inpage->iY = inpage->iHeight;
    if (bThumbnail)
    { // shrink image to size of macro blocks
        inpage->iWidth = (inpage->iWidth+7) >> 3;
        inpage->iHeight = (inpage->iHeight+7) >> 3;
//        inpage->iWidth = outpage->iWidth;
//        inpage->iHeight = outpage->iHeight;
    }
    if (iOptions & PIL_CONVERT_HALFSIZE)
    {
        inpage->iWidth = (inpage->iWidth+1) >> 1;
        inpage->iHeight = (inpage->iHeight+1) >> 1;
    }
    if (iOptions & PIL_CONVERT_QUARTERSIZE)
    {
        inpage->iWidth = (inpage->iWidth+3) >> 2;
        inpage->iHeight = (inpage->iHeight+3) >> 2;
    }
    if (pJPEG->iMode == 0xc0 && pJPEG->ucNumComponents == 1 && inpage->cBitsperpixel > 8 && !(iOptions & (PIL_CONVERT_16BPP | PIL_CONVERT_32BPP))) // grayscale > 8bpp needs to be converted to 8bpp
    {
        inpage->cBitsperpixel = 8;
    }
    if (inpage->cBitsperpixel < 8 || inpage->cBitsperpixel > 32) // something is wrong, exit
        return PIL_ERROR_INVPARAM;
    if (pJPEG->iMode == 0xc1 || pJPEG->iMode == 0xc3) // we don't support reduced resolution decode of JPEG lossless or extended mode (yet) and output is 8-bpp gray
    { // DICOM needs to have pitch == width as a multiple of 8
//        lsize = PILCalcSize((inpage->iWidth + 7) & 0xfff8, inpage->cBitsperpixel); // handle worst case
//        inpage->iX = (inpage->iWidth+7) & 0xfff8; // keep this adjusted width around for rendering the bitmap later
    }
    else
    {
//        lsize = PILCalcSize((inpage->iWidth+15) & 0xfff0, inpage->cBitsperpixel); // handle worst case
    }
    if (iOptions & PIL_CONVERT_NOALLOC)
    {
        cOutput = inpage->pData;
//        if (inpage->iPitch != 0)
//        {
//            lsize = inpage->iPitch; // use the provided pitch
//        }
//        else
//        {
  //          inpage->iPitch = lsize;
//        }
//        inpage->iPitch = lsize;
    }
    else
    {
//        inpage->iPitch = lsize;
        k = (inpage->iHeight + 31) & 0xfff0; // make sure it's big enough to handle incomplete MCU
        k *= lsize; /* color bitmap size */
        cOutput = (unsigned char *) PILIOAllocNoClear(k); /* Output buffer is actual bitmap */
        //      cOutput = VirtualAlloc(NULL, i, MEM_COMMIT, PAGE_NOCACHE | PAGE_READWRITE);
        if (cOutput == NULL)
        {
            iErr = PIL_ERROR_MEMORY;
            goto getjpgz;
        }
        inpage->pData = (unsigned char *)cOutput;
        inpage->iDataSize = k;
    }
    if (pJPEG->iEXIF && !(iOptions & PIL_CONVERT_SKIPEXIF)) // ancillary info and thumbnail image in JPEG header, get it !
    {
        PIL_FILE pfTemp;
        PIL_PAGE ppTemp; // load the thumbnail from the embedded TIFF file
        int bMotorola;
        int iMarker, iError, iTags;
        unsigned char *pData;
        memset(&pfTemp, 0, sizeof(PIL_FILE));
        memset(&ppTemp, 0, sizeof(PIL_PAGE));
        // Copy over the page info for thumbnail display's use
//        ppTemp.iPageWidth = inpage->iPageWidth;
//        ppTemp.iPageHeight = inpage->iPageHeight;
//        ppTemp.iX = inpage->iX;
//        ppTemp.iFrameDelay = inpage->iFrameDelay;
//        ppTemp.lUser = inpage->lUser;
        ppTemp.pJPEG = inpage->pJPEG;
        // Pretend the embedded TIFF file is a separate, memory-mapped file
        if (inpage->cState != PIL_PAGE_STATE_LOADED && pJPEG->iEXIF < inpage->iFilePos && inpage->iFilePos > PIL_BUFFER_SIZE) // we read past it; need to read it again
        {
            inpage->iFilePos += iOff; // keep track of last position
            iOff = 0;
            PILIOSeek(inpage->file, 0, 0); // seek back to start
            PILIORead(inpage->file, buf, pJPEG->iEXIF); // read enough to know the length of the EXIF data
            k = MOTOSHORT(&buf[pJPEG->iEXIF-8]); // exif length
            PILIORead(inpage->file, &buf[pJPEG->iEXIF], k); // read only what we need
        }
        bMotorola = (buf[pJPEG->iEXIF] == 'M');
        pfTemp.pData = &buf[pJPEG->iEXIF];
        k = pJPEG->iEXIF - 8;
        pfTemp.iFileSize = MOTOSHORT(&buf[k]); // use the App1 marker length as a fake file length
        pfTemp.cFileType = PIL_FILE_TIFF;
        pfTemp.cState = PIL_FILE_STATE_LOADED;
        pfTemp.iPageTotal = 2;
        pfTemp.pPageList = (int *)pJPEG->iScanOffset; // thumbnails don't encode as progressive, so we can borrow this space
        pfTemp.pPageList[0] = PILTIFFLONG(&buf[pJPEG->iEXIF+4], bMotorola); // offset to first IFD
        iTags = 0;
        k = pJPEG->iEXIF + pfTemp.pPageList[0];
        if (k > 0 && k < pfTemp.iFileSize) // if within buffer
            iTags = PILTIFFSHORT(&buf[k], bMotorola);  /* Number of tags in this dir */
        if (iTags < 6 || iTags > 256) // invalid info, stop here
            goto normal_jpeg;
        pfTemp.pPageList[1] = PILTIFFLONG(&buf[pJPEG->iEXIF+pfTemp.pPageList[0]+2+iTags*12], bMotorola); // IFD of second page
//        ppTemp.iFrameDelay = 0; // assume no extra EXIF info
//        iError = PILRead(&pfTemp, &ppTemp, 0, PIL_CONVERT_NOALLOC); // Read the text info and EXIF offset from the first page
        if (iError != 0) // free the data
        {
            PILIOFree(ppTemp.pData);
            ppTemp.pData = NULL;
        }
        inpage->iOrientation = ppTemp.iOrientation; // transfer JPEG rotation info to output page
//        if (ppTemp.iFrameDelay) // EXIF info included, get it
//        {
//            strcpy(inpage->szSoftware, ppTemp.szSoftware);
//            strcpy(inpage->szArtist, ppTemp.szArtist);
//            inpage->iXres = ppTemp.iXres;
//            inpage->iYres = ppTemp.iYres; // get the resolution info
//            PILGetEXIFInfo(buf, pJPEG->iEXIF, ppTemp.iFrameDelay, bMotorola, inpage);
//        }
        if (iOptions & PIL_CONVERT_THUMBNAIL) // if we are reading a thumbnail image, try to get it here
        {
//            iError = PILRead(&pfTemp, &ppTemp, 1, 0); // Read the image info for the thumbnail page
            if (iError)
                goto normal_jpeg; // try to read a 1/64 sized version if the thumbnail image is bad
            inpage->cCompression = PIL_COMP_NONE; // decompress
            // Get the image width and height - without these, loading will fail
            if (ppTemp.cCompression == PIL_COMP_JPEG) // if JPEG compressed thumbnail, extract size
            {
                k = 2; /* Start at offset of first marker */
                iMarker = 0; /* Search for SOF (start of frame) marker */
                pData = &ppTemp.pData[ppTemp.iOffset];
                while (k < ppTemp.iDataSize)
                {
                    iMarker = MOTOSHORT(&pData[k]) & 0xfffc;
                    k += 2;
                    if (iMarker < 0xff00) // invalid marker, could be generated by "Arles Image Web Page Creator" or Accusoft
                        continue; // skip 2 bytes and try to resync
                    if (iMarker == 0xffc0)
                        break;
                    k += MOTOSHORT(&pData[k]); /* Skip to next marker */
                }
                if (iMarker != 0xffc0) // something went wrong, try to load the normal way
                {
                    goto normal_jpeg; // try to load it normally
                }
                else
                {
                    ppTemp.iHeight = MOTOSHORT(&pData[k+3]);
                    ppTemp.iWidth = MOTOSHORT(&pData[k+5]);
                    if (pData[k+7] == 1) /* number of components */
                    {
                        ppTemp.cBitsperpixel = 8; /* grayscale */
                    }
                    else
                        ppTemp.cBitsperpixel = 24;
                }
                // Isn't recursion great? :)
                ppTemp.pData = buf;
                ppTemp.iOffset += pJPEG->iEXIF; // add the EXIF offset to the thumbnail
                ppTemp.file = inpage->file; // read the file directly
// DEBUG
//                iError = PILConvert(&ppTemp, inpage, PIL_CONVERT_16BPP, NULL, pTables); // we want a thumbnail...
                ppTemp.pData = NULL; // don't free the data buffer since it is from the original page object
                PILFree(&ppTemp); // free this page because it has been "filtered" and a new data buffer was allocated
                if (iError)
                    goto normal_jpeg; // try to load a 1/64th version if EXIF thumbnail fails
            }
            else // uncompressed thumbnail, convert to 16bpp
            {
 //               if (ppTemp.cBitsperpixel == 24)
 //                   PILModify(&ppTemp, PIL_MODIFY_COLORS, 16, PIL_COLORS_BEST);
                memcpy(inpage, &ppTemp, sizeof(PIL_PAGE)); // use the page as-is
            }
            PILIOFree(pJPEG);
            PILIOFree(pMCUData);
            PILIOFree(cOutput); // don't need this buffer since we decompressed another image
 //           inpage->iPitch = PILCalcSize(inpage->iWidth, inpage->cBitsperpixel); // recalc pitch
            return iError; // we are done!
        }
        else // preserve any EXIF info
        {
//            strcpy(inpage->szInfo1, ppTemp.szInfo1);
//            strcpy(inpage->szInfo2, ppTemp.szInfo2);
//            strcpy(inpage->szArtist, ppTemp.szArtist);
//            strcpy(inpage->szSoftware, ppTemp.szSoftware);
//            strcpy(inpage->szMake, ppTemp.szMake);
//            strcpy(inpage->szModel, ppTemp.szModel);
//            strcpy(inpage->szComment, ppTemp.szComment);
            // GPS info is gathered in a different function and needs to be copied to the output page
            // Normal EXIF info is written directly into the output page
//            strcpy(inpage->szLatitude, ppTemp.szLatitude);
//            strcpy(inpage->szLongitude, ppTemp.szLongitude);
//            inpage->iLatDeg = ppTemp.iLatDeg;
//            inpage->iLatMin = ppTemp.iLatMin;
//            inpage->iLatSec = ppTemp.iLatSec;
//            inpage->iLongDeg = ppTemp.iLongDeg;
//            inpage->iLongMin = ppTemp.iLongMin;
//            inpage->iLongSec = ppTemp.iLongSec;
//            inpage->iAltitude = ppTemp.iAltitude;
        }
    }
normal_jpeg:
    if (inpage->cState != PIL_PAGE_STATE_LOADED && pJPEG->iEXIF > 0 && pJPEG->iEXIF < inpage->iFilePos && inpage->iFilePos > PIL_BUFFER_SIZE) // we read past EXIF data, need to reset position
    {
        // subtract PIL_BUFFER_SIZE from offset since we read that much before
        PILIOSeek(inpage->file, inpage->iFilePos - PIL_BUFFER_SIZE, 0);
        PILIORead(inpage->file, buf, PIL_BUFFER_SIZE);
    }
    if (!bThumbnail) // use the real image size instead of the EXIF size which may be wrong
    {
        inpage->iOriginalWidth = inpage->iWidth;
        inpage->iOriginalHeight = inpage->iHeight;
    }
    if (pJPEG->iMode != 0xc0 && pJPEG->iMode != 0xc1 && pJPEG->iMode != 0xc2 && pJPEG->iMode != 0xc3) // we only handle baseline DCT jpeg, extended DCT, progressive DCT, and lossless Huffman
    {
        iErr = PIL_ERROR_UNSUPPORTED;
        goto getjpgz;
    }
    if (pJPEG->iMode == 0xc2)
        pJPEG->iOptions |= PIL_CONVERT_PROGRESSIVE; // mark this as a progressive JPEG
    
    if (pJPEG->ucNumComponents != 1 && pJPEG->ucNumComponents != 3 && pJPEG->ucNumComponents != 4) // we only support gray, and 3 or 4-component rgb images; cmyk will have to wait for a future time
    {
        iErr = PIL_ERROR_UNSUPPORTED;
        goto getjpgz;
    }
    if (pJPEG->ucNumComponents == 1) // must be grayscale
    {
        if (pJPEG->iOptions & PIL_CONVERT_16BPP)
            inpage->cBitsperpixel = 16;
        else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
            inpage->cBitsperpixel = 32;
        else
        {
            inpage->cBitsperpixel = 8;
        }
    }
    if (pJPEG->ucNumComponents == 3 || pJPEG->ucNumComponents == 4) // color
    {
        if (pJPEG->iOptions & PIL_CONVERT_16BPP)
            inpage->cBitsperpixel = 16;
        else if (pJPEG->iOptions & PIL_CONVERT_LUMA_ONLY)
            inpage->cBitsperpixel = 8;
        else if (pJPEG->iOptions & PIL_CONVERT_32BPP)
            inpage->cBitsperpixel = 32;
        else
            inpage->cBitsperpixel = 24;
    }
#ifdef BOGUS
    if (inpage->pLocalPalette) // process tables from other data block
    {
        i = 2;
        k = JPEGProcessTables(inpage->pLocalPalette, &i, pJPEG, inpage->iAnnotationSize + 20, inpage);
        if (k != 0xd9) // check for M_EOI
        {
            iErr = PIL_ERROR_BADHEADER;
            goto getjpgz;
        }
        k = JPEGProcessTables(buf, &iOff, pJPEG, inpage->iDataSize, inpage); // need SOS
        if (k != 0xda) // M_SOS
        {
            iErr = PIL_ERROR_BADHEADER;
            goto getjpgz;
        }
    }
    else
    {
        if (JPEGProcessTables(buf, &iOff, pJPEG, inpage->iDataSize + inpage->iOffset, inpage) != 0xda) // check for M_SOS
        {
            iErr = PIL_ERROR_BADHEADER;
            goto getjpgz;
        }
    }
#endif // BOGUS
    pJPEG->iScan = 0; // get info ready for first scan (of multiscan progressive file)
    pJPEG->iHuffOffset[0] = 0; // use already-loaded Huff table for first scan
    pJPEG->iScanOffset[0] = 0; // first scan offset is always 0
    JPEGGetSOS(buf, &iOff, pJPEG);
    if (pJPEG->ucComponentsInScan < pJPEG->ucNumComponents) // the image has the scans encoded individually, treat it like a progressive JPEG
    {
        pJPEG->iOptions |= PIL_CONVERT_PROGRESSIVE;
        pJPEG->iMode = 0xc2;
    }
    if ((pJPEG->iMode == 0xc1 || pJPEG->iMode == 0xc3) && pJPEG->ucNumComponents != 1) // we only support grayscale for lossless and extended jpeg
    {
        iErr = PIL_ERROR_UNSUPPORTED;
        goto getjpgz;
    }
    pJPEG->iScan++; // at least 1 scan
    iScanTotal = 0; // suppress compiler warning
    // create huffman tables
 //   if (!bMJPEG)
    {
        if (pJPEG->iMode == 0xc2) // use slower 11-bit AC tables for progressive. Performance is less important
        {
            if (JPEGMakeHuffTables_Slow(pJPEG, FALSE))
            {
                iErr = PIL_ERROR_UNSUPPORTED;
                goto getjpgz;
            }
            // reset the standard AC table pointers to all point to the alternate set
//            pJPEG->huffacFast[1] = (int *) &pJPEG->ucAltHuff[0x0000];
//            pJPEG->huffacFast[2] = (int *) &pJPEG->ucAltHuff[0x4000];
//            pJPEG->huffacFast[3] = (int *) &pJPEG->ucAltHuff[0x8000];
        }
        else
        {
            if (JPEGMakeHuffTables(pJPEG, bThumbnail))
            {
                iErr = PIL_ERROR_UNSUPPORTED;
                goto getjpgz;
            }
        }
    }
    // reorder and fix the quantization table for decoding
    JPEGFixQuantD(pJPEG);
    if (iOptions & PIL_CONVERT_NOALLOC)
        JPEGInitTables(pJPEG);
//jpeg_strips:
    if (pJPEG->iOptions & PIL_CONVERT_PROGRESSIVE)
    {
#ifdef JPEG_PROGRESSIVE
        iErr = JPEGFilter(inpage, iOff, pJPEG); // start with a clean data stream to decode
        iScanTotal = pJPEG->iScan; // total number of scans (for progressive)
        iOff = 0;
        buf = inpage->pData; // pointer to new data buffer
        if (iErr)
            goto getjpgz;
#endif // JPEG_PROGRESSIVE
    }
    else
    {
//        if (inpage->cSpecial != PIL_JPEG_FILTERED)
//        {
//            if (pJPEG->iOptions & PIL_CONVERT_SIMD)
//                iOff = JPEGSimpleFilter_SIMD(inpage, iOff, pJPEG, pJPEGSlices, iNumThreads, &iNumSlices, cOutput, bThumbnail); // remove stuffed 0's and marker bytes to speed up decode
//            else
//                iOff = JPEGSimpleFilter(inpage, iOff, pJPEG, pJPEGSlices, iNumThreads, &iNumSlices, cOutput, bThumbnail); // remove stuffed 0's and marker bytes to speed up decode
//        }
    }
    
    iBit = 0;  // point to start of image data stream
    pJPEG->iDataSize = /*inpage->iOffset +*/ inpage->iDataSize;
    //   iOff += inpage->iOffset; // start at real data
    //   inpage->iOffset = 0;
    //   pJPEG->ulBits = JPEGGet32Bits(buf, &iOff); // start with 32-bits of huffman data
#ifdef _64BITS
    bb.ulBits = MOTOEXTRALONG(&inpage->pData[iOff]); // preload first 8 bytes
#else
    bb.ulBits = MOTOLONG(&inpage->pData[iOff]); // preload first 4 bytes
#endif
    //   iOff += (REGISTER_WIDTH>>3);
    bb.pBuf = &inpage->pData[iOff];
    bb.ulBitOff = iBit;
    bb.ulDataSize = inpage->iDataSize - iOff;
    // Loop through all of the MCU's and decode the image
    //   dcPred0 = 0;
    
    if (pJPEG->iMode == 0xc3) // lossless
    {
        iErr = GetJPEGLossless(inpage, &bb, pJPEG);
        goto getjpgz;
    }
    else if (pJPEG->iMode == 0xc1) // extended (12-bit) DCT mode
    {
        pMCU = pMCUData = &pJPEG->pMCUs[0];
        iErr = GetJPEGExtended(inpage, &bb, pMCU, pJPEG, cOutput);
        // Allocate the visible buffer of 8-bit grayscale data
        inpage->cBitsperpixel = 8;
//        inpage->lUser = (void *) cOutput;
//        inpage->pData = (unsigned char *)PILIOAlloc(inpage->iPitch * inpage->iHeight);
//        if (inpage->pData == NULL)
//        {
//            iErr = PIL_ERROR_MEMORY;
//            goto getjpgz;
//        }
//        if (inpage->iWindowWidth == 0) // figure out the window/level from the pixel values
//            PILCalcDICOMRange(inpage);
//        PILRenderDICOM(inpage, inpage->iWindowWidth, inpage->iWindowCenter);
        goto getjpgz;
    }
    if (bThumbnail && !(pJPEG->iOptions & PIL_CONVERT_PROGRESSIVE))
    {
        if (iNumSlices == 1)
        {
            pJPEGSlices[0].uiWidth = inpage->iWidth;
//            pJPEGSlices[0].uiPitch = inpage->iPitch;
            pJPEGSlices[0].uiHeight = inpage->iHeight;
            pJPEGSlices[0].pData = bb.pBuf;
            pJPEGSlices[0].pJPEG = pJPEG;
            pJPEGSlices[0].uiBitOffset = (uint32_t) bb.ulBitOff;
            pJPEGSlices[0].uiLen = (uint32_t) bb.ulDataSize;
            pJPEGSlices[0].uiResInterval = pJPEG->iResInterval;
            pJPEGSlices[0].uiResCount = pJPEG->iResInterval;
            pJPEGSlices[0].pBitmap = cOutput;
            pJPEGSlices[0].iDCPred0 = pJPEGSlices[0].iDCPred1 = pJPEGSlices[0].iDCPred2 = pJPEGSlices[0].iDCPred3 = 0;
            PILDecodeJPEGThumbSlice(&pJPEGSlices[0]);
            iErr = pJPEGSlices[0].iError;
        }
        else // use multiple threads
        {
            int iDoneCount = 0;
            for (i = 0; i < iNumSlices - 1; i++)
            {
//                PILIOCreateThread(PILDecodeJPEGThumbSlice, &pJPEGSlices[i], i + 1);
            }
            PILDecodeJPEGThumbSlice(&pJPEGSlices[iNumSlices - 1]); // do last slice on current thread
            while (iDoneCount != iNumSlices)
            {
//                PILIOSleep(1); // yield to other threads being created and running
                iDoneCount = 0;
                for (i = 0; i < iNumSlices; i++)
                {
                    if (PIL_THREAD_COMPLETE == pJPEGSlices[i].uiFlag) // finished processing
                        iDoneCount++;
                }
            }
            iErr = 0;
            for (i = 0; i < iNumSlices; i++)
            {
                iErr |= pJPEGSlices[i].iError; // see if it succeeded
            }
        }
    }
    else
    {
        if (pJPEG->iOptions & PIL_CONVERT_PROGRESSIVE)
        {
#ifdef JPEG_PROGRESSIVE
            if (bThumbnail)
            {
                pJPEG->iOptions |= PIL_CONVERT_THUMBNAIL; // pass the thumbnail flag to the progressive drawing code
                i = pJPEG->ucNumComponents * inpage->iWidth * inpage->iHeight;
            }
            else
                i = pJPEG->ucNumComponents * ((inpage->iWidth + 7)/8) * ((inpage->iHeight+7)/8);
            pMCU = pMCUData = (short *)PILIOAlloc((i + 32)*DCTSIZE2*sizeof(short)); /* Allocate space for MCU buffers */
            if (pMCU == NULL)
            {
                iErr = PIL_ERROR_MEMORY;
                goto getjpgz;
            }
            if (bThumbnail)
                iScanTotal = 1; // only run the first scan for thumbnail images
            for (iScan = 0; iScan < iScanTotal && !iErr; iScan++)
            {
                iOff = pJPEG->iScanOffset[iScan]; // offset of jpeg data to decode
                //               pJPEG->ulBits = JPEGGet32Bits(inpage->pData, &iOff); // start with 32-bits of huffman data
                if (iScan != 0) // we already have data for the first scan
                    JPEGGetSOS(inpage->pData, &iOff, pJPEG); // Get scan-specific info for progressive JPEGs
                iBit = 0;  // each scan starts at bit 0
                k = pJPEG->iHuffOffset[iScan];
                if (k) // if there is a new Huffman table, use it
                {
                    PILFreeHuffTables(pJPEG);  // free the old tables
                    i = MOTOSHORT(&inpage->pData[k]); // get the huff data length
                    i -= 2; // minus the length itself
                    if (JPEGGetHuffTables(&inpage->pData[k + 2], i, pJPEG)) // get the new Huffman table(s)
                    {
                        iErr = PIL_ERROR_BADHEADER;
                        goto getjpgz;
                    }
                    //			   if (JPEGMakeHuffTables(pJPEG, FALSE)) // Create the new decode tables
                    if (JPEGMakeHuffTables_Slow(pJPEG, FALSE)) // user slower tables for progressive; performance is less important
                    {
                        iErr = PIL_ERROR_UNSUPPORTED;
                        goto getjpgz;
                    }
                }
                switch (pJPEG->jpegsample) // call the correct code based on color subsampling
                {
                    case 0x00: // grayscale
                        iErr = GetJPEGGrayP(inpage, &iOff, &iBit, pMCU, pJPEG);
                        break;
                    case 0x22: // subsampled in both directions
                        iErr = GetJPEG22P(inpage, &iOff, &iBit, pMCU, pJPEG);
                        break;
                    case 0x11: // no subsampling
                        iErr = GetJPEG11P(inpage, &iOff, &iBit, pMCU, pJPEG);
                        break;
                    case 0x12: // 2:1 vertical
                        iErr = GetJPEG12P(inpage, &iOff, &iBit, pMCU, pJPEG);
                        break;
                    case 0x21: // 2:1 horizontal
                        iErr = GetJPEG21P(inpage, &iOff, &iBit, pMCU, pJPEG);
                        break;
                }
            }
            // Now that we have decoded the scans, convert the MCUs into an image
            switch (pJPEG->jpegsample) // call the correct code based on color subsampling
            {
                case 0x00: // grayscale
                    DrawJPEGGrayP(inpage, pMCU, pJPEG, cOutput);
                    break;
                case 0x22: // subsampled in both directions
                    DrawJPEG22(inpage, pMCU, pJPEG, cOutput);
                    break;
                case 0x11: // no subsampling
                    DrawJPEG11(inpage, pMCU, pJPEG, cOutput);
                    break;
                case 0x12: // 2:1 vertical
                    DrawJPEG12(inpage, pMCU, pJPEG, cOutput);
                    break;
                case 0x21: // 2:1 horizontal
                    DrawJPEG21(inpage, pMCU, pJPEG, cOutput);
                    break;
            }
#endif // JPEG_PROGRESSIVE
        }
        else
        {
            pMCU = pMCUData = &pJPEG->pMCUs[0];
            iBit = 0;  // each scan starts at bit 0
            if (iOptions & PIL_CONVERT_LUMA_ONLY)
                iErr = GetJPEGLuma(inpage, &bb, pMCU, pJPEG, cOutput, NULL);
            else
            {	// only use multi-thread approach on large images (e.g. not when decoding thumbnails - it's not worth the thread overhead)
                if (iNumThreads == 1 || inpage->iWidth < 240 || iOptions & (PIL_CONVERT_HALFSIZE | PIL_CONVERT_QUARTERSIZE)) // normal image
                { // single threaded decode is all we can do
                    pJPEGSlices[0].uiWidth = inpage->iWidth;
//                    pJPEGSlices[0].uiPitch = inpage->iPitch;
                    pJPEGSlices[0].uiHeight = inpage->iHeight;
                    pJPEGSlices[0].pData = bb.pBuf;
                    pJPEGSlices[0].pJPEG = pJPEG;
                    pJPEGSlices[0].uiBitOffset = (uint32_t)bb.ulBitOff;
                    pJPEGSlices[0].uiLen = (uint32_t)bb.ulDataSize;
                    pJPEGSlices[0].uiResInterval = pJPEG->iResInterval;
                    pJPEGSlices[0].uiResCount = pJPEG->iResInterval;
                    pJPEGSlices[0].pBitmap = cOutput;
                    pJPEGSlices[0].iDCPred0 = pJPEGSlices[0].iDCPred1 = pJPEGSlices[0].iDCPred2 = pJPEGSlices[0].iDCPred3 = 0;
                    PILDecodeJPEGSlice(&pJPEGSlices[0]);
                    iErr = pJPEGSlices[0].iError;
                }
                else // try multi-thread decode
                {
                    int iDoneCount = 0;
// DEBUG
//                    if (1 == iNumSlices && 0 == pJPEG->iResInterval) // no restart markers; make our own :)
//                        PILMapJPEGSlices(inpage, pJPEG, &bb, iNumThreads, &iNumSlices, pJPEGSlices, cOutput);
                    if (iNumSlices == 1) // still couldn't be mapped, just decode it with 1 thread
                    {
                        pJPEGSlices[0].uiWidth = inpage->iWidth;
//                        pJPEGSlices[0].uiPitch = inpage->iPitch;
                        pJPEGSlices[0].uiHeight = inpage->iHeight;
                        pJPEGSlices[0].pData = bb.pBuf;
                        pJPEGSlices[0].pJPEG = pJPEG;
                        pJPEGSlices[0].uiBitOffset = (uint32_t)bb.ulBitOff;
                        pJPEGSlices[0].uiLen = (uint32_t)bb.ulDataSize;
                        pJPEGSlices[0].uiResInterval = pJPEG->iResInterval;
                        pJPEGSlices[0].uiResCount = pJPEG->iResInterval;
                        pJPEGSlices[0].pBitmap = cOutput;
                        pJPEGSlices[0].iDCPred0 = pJPEGSlices[0].iDCPred1 = pJPEGSlices[0].iDCPred2 = pJPEGSlices[0].iDCPred3 = 0;
                        PILDecodeJPEGSlice(&pJPEGSlices[0]);
                        iErr = pJPEGSlices[0].iError;
                    }
                    else // decode it with multiple threads
                    {
                        for (i = 0; i < iNumSlices - 1; i++)
                        {
//                            PILIOCreateThread((void*) PILDecodeJPEGSlice, &pJPEGSlices[i], i + 1);
                        }
                        PILDecodeJPEGSlice(&pJPEGSlices[iNumSlices - 1]); // do last slice on current thread
                        while (iDoneCount != iNumSlices)
                        {
//                            PILIOSleep(1); // yield to other threads being created and running
                            iDoneCount = 0;
                            for (i = 0; i < iNumSlices; i++)
                            {
                                if (PIL_THREAD_COMPLETE == pJPEGSlices[i].uiFlag) // finished processing
                                    iDoneCount++;
                            }
                        }
                        iErr = 0;
                        for (i = 0; i < iNumSlices; i++)
                        {
                            iErr |= pJPEGSlices[i].iError; // see if it succeeded
                        }
                    }
                }
            }
        }
    }
    
getjpgz:
    if (pJPEG != NULL && pJPEG->iOptions & PIL_CONVERT_PROGRESSIVE)
    {
        PILIOFree(pMCU); // we allocated a big block of MCU data for progressive mode
    }
    if (pJPEG != NULL)
    {
        PILFreeHuffTables(pJPEG);
        if (!(iOptions & PIL_CONVERT_NOALLOC))
            PILIOFree(pJPEG);
    }
//    if (inpage->lUser == NULL) // don't recalculate the pitch for DICOM images
//    {
//        i = (inpage->iWidth+15) & 0xfff0;
//        inpage->iPitch = PILCalcSize(i, inpage->cBitsperpixel); // recalc pitch
//    }
    if ((iOptions & PIL_CONVERT_IGNORE_ERRORS)  && iErr == PIL_ERROR_DECOMP)
        iErr = 0; // keep the partial page
    if (iErr && !(iOptions & PIL_CONVERT_NOALLOC)) /* Error, free the image data too */
    {
        PILIOFree(cOutput);
    }
    return iErr;
    
} /* PILReadJPEG() */

#ifndef JPEG_DECODE_ONLY

//#ifndef USE_ARM_ASM
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILStoreCode(PIL_CODE *, ulong, int)                       *
 *                                                                          *
 *  PURPOSE    : Store a Huffman code into an output data stream.           *
 *                                                                          *
 ****************************************************************************/
void PILStoreCode(PIL_CODE *pPC, uint32_t ulCode, int iLen)
{
    if (iLen + pPC->iLen > REGISTER_WIDTH) // won't fit, dump old codes first
    {
        while (pPC->iLen >= 8) // need to write to memory
        {
            unsigned char c = (unsigned char) (pPC->ulAcc >> (REGISTER_WIDTH-8));
            *pPC->pOut++ = c;
            if (c == 0xff) // insert a padded 0 to not mistake it for a marker (FFXX)
                *pPC->pOut++ = 0;
            pPC->ulAcc <<= 8;
            pPC->iLen -= 8;
        }
    }
    pPC->iLen += iLen;
    pPC->ulAcc |= (ulCode << (REGISTER_WIDTH - pPC->iLen));
} /* PILStoreCode() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILFlushCode(PIL_CODE *, int)                          *
 *                                                                          *
 *  PURPOSE    : Flush any remaining data from the code accumulator.        *
 *                                                                          *
 ****************************************************************************/
void PILFlushCode(PIL_CODE *pPC, int bJPEG)
{
    unsigned char c;
    
    while (pPC->iLen > 0)
    {
        c = (unsigned char) (pPC->ulAcc >> (REGISTER_WIDTH-8));
        *pPC->pOut++ = c;
        if (bJPEG && c == 0xff) // stuffed 0
            *pPC->pOut++ = 0;
        pPC->ulAcc <<= 8;
        pPC->iLen -= 8;
    }
    pPC->iLen = 0;
} /* PILFlushCode() */

//#ifndef USE_ARM_ASM
#if defined(_X64)
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGEncodeMCU()                                            *
 *                                                                          *
 *  PURPOSE    : Use the Huffman table to encode the block as JPEG data     *
 *               Special 64-bit version uses a bit mask to avoid table      *
 *               lookups and counting of runs of 0 coefficients.            *
 *                                                                          *
 ****************************************************************************/
int JPEGEncodeMCU(int iDCTable, JPEGDATA *pJPEG, signed short *pMCUData, PIL_CODE *pPC, int iDCPred, uint64_t ullBitMask)
{
    //int iOff, iBitnum; // faster access
    unsigned char cMagnitude;
    unsigned char ucCode, *pZig, *pZigEnd;
    int iZeroCount;
    BIGINT iDelta;
    BIGUINT iLen, iNewLen;
    unsigned short *pHuff;
    BIGUINT ulCode;
    unsigned char *pOut;
    BIGUINT ulAcc;
    uint32_t ulMagVal;
    uint32_t *pMagFix = (uint32_t *)&ulMagnitudeFix[1024]; // allows indexing positive and negative values - speeds up total encode time by 15%
    
    // Put in local vars to allow compiler to do a better job of optimization using registers
    ulAcc = pPC->ulAcc;
    pOut = pPC->pOut;
    iLen = pPC->iLen;
    
    // compress the DC component
    iDelta = pMCUData[0] - iDCPred;
    iDCPred = pMCUData[0]; // this is the new DC value
    pHuff = (unsigned short *) pJPEG->huffdc[iDCTable];
    ulMagVal = pMagFix[iDelta]; // get magnitude and new delta in one table read
    iDelta = (ulMagVal >> 16);
    cMagnitude = ulMagVal & 0xf;
    ulCode = (BIGUINT) pHuff[cMagnitude];
    iNewLen = pHuff[cMagnitude + 512];
    ulCode = (ulCode << cMagnitude) | iDelta; // code in msb, followed by delta
    iNewLen += cMagnitude; // add lengths together
    STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
    // Encode the AC components
    ullBitMask >>= 1; // we don't care about the DC component
    pZig = (unsigned char *)&cZigZag2[1];
    pZigEnd = (unsigned char *)&cZigZag2[64];
    pHuff += 1024; // point to AC table
    while (ullBitMask) // when we run out of non-zero A/C coefficients, we're done
    {
        // count the number of leading zeros
        PILFIRST1(ullBitMask, iZeroCount);
        ullBitMask >>= (iZeroCount + 1); // prepare for next pass
        // Encode a zero count and AC coefficient
        pZig += iZeroCount;
        iDelta = pMCUData[*pZig++]; // get non-zero coefficient and prepare for next run
        while (iZeroCount >= 16)  // maximum that can be encoded at once
        { // 16 zeros is called ZRL (f0)
            ulCode = (uint32_t)pHuff[0xf0];
            iNewLen = pHuff[512 + 0xf0];
            STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
            iZeroCount -= 16;
        }
        // Encode a normal RRRR/SSSS pair
        ulMagVal = pMagFix[iDelta]; // get magnitude and new delta in one table read
        iDelta = (ulMagVal >> 16);
        cMagnitude = ulMagVal & 0xf;
        ucCode = (unsigned char)((iZeroCount << 4) | cMagnitude); // combine zero count and 'extra' size
        // store the huffman code
        ulCode = (uint32_t)pHuff[ucCode];
        iNewLen = pHuff[512 + ucCode];
        ulCode = (ulCode << cMagnitude) | iDelta; // code followed by magnitude
        iNewLen += cMagnitude;
        STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
    } // while (ullBitMask != 0)
    if (pZig < pZigEnd) // no more coefficients, but we didn't code #63, so write an EOB
    { // encode EOB (end of block)
        ulCode = (BIGUINT) pHuff[0];
        iNewLen = pHuff[512];
        STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
    }
    
    pPC->ulAcc = ulAcc;
    pPC->pOut = pOut;
    pPC->iLen = iLen;
    return iDCPred;
    
} /* JPEGEncodeMCU() */
#else
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGEncodeMCU()                                            *
 *                                                                          *
 *  PURPOSE    : Use the Huffman table to encode the block as JPEG data     *
 *                                                                          *
 ****************************************************************************/
int JPEGEncodeMCU(int iDCTable, JPEGDATA *pJPEG, signed short *pMCUData, PIL_CODE *pPC, int iDCPred, int bSparse)
{
    //int iOff, iBitnum; // faster access
    unsigned char cMagnitude;
    unsigned char ucCode, *pZig, *pZigEnd, *pZigStart;
    int iZeroCount;
    BIGINT iDelta;
    BIGUINT iLen, iNewLen;
    unsigned short *pHuff;
    BIGUINT ulCode;
    unsigned char *pOut;
    BIGUINT ulAcc;
    uint32_t ulMagVal;
    uint32_t *pMagFix = (uint32_t *)&ulMagnitudeFix[1024]; // allows indexing positive and negative values - speeds up total encode time by 15%
    
    // Put in local vars to allow compiler to do a better job of optimization using registers
    ulAcc = pPC->ulAcc;
    pOut = pPC->pOut;
    iLen = pPC->iLen;
    
    // compress the DC component
    iDelta = pMCUData[0] - iDCPred;
    iDCPred = pMCUData[0]; // this is the new DC value
    pHuff = (unsigned short *) pJPEG->huffdc[iDCTable];
    ulMagVal = pMagFix[iDelta]; // get magnitude and new delta in one table read
    iDelta = (ulMagVal >> 16);
    cMagnitude = ulMagVal & 0xf;
    // Old way of dealing with negative and positive magnitudes; faster to use a lookup table once
    //   if (iDelta < 0)
    //      {
    //      iDelta = 0 - iDelta;
    //      cMagnitude = cMagnitudes[iDelta];
    //      iDelta = iBitMasks[cMagnitude] - iDelta;
    //      }
    //   else
    //      {
    //      cMagnitude = cMagnitudes[iDelta];
    //      }
    ulCode = (BIGUINT) pHuff[cMagnitude];
    iNewLen = pHuff[cMagnitude + 512];
    ulCode = (ulCode << cMagnitude) | iDelta; // code in msb, followed by delta
    iNewLen += cMagnitude; // add lengths together
    STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
    // Encode the AC components
    pZig = (unsigned char *)&cZigZag2[1];
    if (bSparse)
        pZigEnd = (unsigned char *)&cZigZag2[29]; // second half is all zeros
    else
        pZigEnd = (unsigned char *)&cZigZag2[64];
    pHuff += 1024; // point to AC table
    while (pZig < pZigEnd)
    {
        // count the number of leading zeros
        pZigStart = pZig;
        while (pZig < pZigEnd && (iDelta = pMCUData[pZig[0]]) == 0)
        {
            pZig++;
        }
        if (pZig == pZigEnd) // special case, no more coefficients
        { // encode EOB (end of block)
            ulCode = (BIGUINT) pHuff[0];
            iNewLen = pHuff[512];
            STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
            goto encodemcuz;
        }
        else // Encode a zero count and AC coefficient
        {
            iZeroCount = (int)(pZig - pZigStart);
            while (iZeroCount >= 16)  // maximum that can be encoded at once
            { // 16 zeros is called ZRL (f0)
                ulCode = (uint32_t)pHuff[0xf0];
                iNewLen = pHuff[512 + 0xf0];
                STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
                iZeroCount -= 16;
            }
            // Encode a normal RRRR/SSSS pair
            ulMagVal = pMagFix[iDelta]; // get magnitude and new delta in one table read
            iDelta = (ulMagVal >> 16);
            cMagnitude = ulMagVal & 0xf;
            ucCode = (unsigned char)((iZeroCount << 4) | cMagnitude); // combine zero count and 'extra' size
            // store the huffman code
            ulCode = (uint32_t)pHuff[ucCode];
            iNewLen = pHuff[512 + ucCode];
            ulCode = (ulCode << cMagnitude) | iDelta; // code followed by magnitude
            pZig++;  // skip to next coefficient
            iNewLen += cMagnitude;
            STORECODE(pOut, iLen, ulCode, ulAcc, iNewLen)
        }
    }
    
encodemcuz:
    pPC->ulAcc = ulAcc;
    pPC->pOut = pOut;
    pPC->iLen = iLen;
    return iDCPred;
    
} /* JPEGEncodeMCU() */
#endif // _X64
/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGetMCU()                                               *
 *                                                                          *
 *  PURPOSE    : Get a 8x8 block of image data read for compression         *
 *                                                                          *
 ****************************************************************************/
void JPEGGetMCU(unsigned char *pImage, PIL_PAGE *pPage, int lsize, int x, int y, signed short *pMCUData, unsigned char *ucGrayPalette)
{
    int iDelta, width, height, cx, cy;
    signed short *pDest;
    unsigned char *pSrc;
    
    if (pPage->cFlags & PIL_PAGEFLAGS_BOTTOMUP) // upside-down
    {
        pImage = pImage + (lsize * (pPage->iHeight-1));
        lsize = -lsize;
    }
    pSrc = pImage + x*8 + (y * 8 * lsize);
    pDest = pMCUData;
    width = height = 8;
    iDelta = 0;
    if (x*8 + width > pPage->iWidth)
        width = 4;
    if (y*8 + height > pPage->iHeight)
        height = pPage->iHeight & 7;
    if (width != 8 || height != 8)
        memset(pMCUData, 0, 64*sizeof(short)); // make sure untouched pixels are zero
    iDelta = 8 - width; // amount to skip in dest if at right edge
    if (ucGrayPalette) // need to translate through palette table
    {
        for (cy = 0; cy < height; cy++)
        {
            for (cx = 0; cx < width; cx++)
            {
                *pDest++ = (signed short) ucGrayPalette[*pSrc++] - 128;
            }
            pDest += iDelta;
            pSrc += lsize - width; // skip to next line
        }
    }
    else
    {
        for (cy = 0; cy < height; cy++)
        {
            for (cx = 0; cx < width; cx++)
            {
                *pDest++ = (signed short)pSrc[0] - 128;
                pSrc++;
            }
            pDest += iDelta;
            pSrc += lsize - width; // skip to next line
        }
    }
} /* JPEGGetMCU() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSubSample24()                                          *
 *                                                                          *
 *  PURPOSE    : Subsample a 8x8 color block by 2:1                         *
 *                                                                          *
 ****************************************************************************/
void JPEGSubSample24(unsigned char *pSrc, signed short *pLUM, signed short *pCb, signed short *pCr, int lsize, int cx, int cy)
{
    int x;
    unsigned char cRed, cGreen, cBlue;
    int iY1, iY2, iY3, iY4, iCr1, iCr2, iCr3, iCr4, iCb1, iCb2, iCb3, iCb4;
    int y;
    
    cx = (cx + 1)>>1; // do pixels in 2x2 blocks
    cy = (cy + 1)>>1;
    
    for (y=0; y<cy; y++)
    {
        for (x = 0; x<cx; x++) // do 8x8 pixels in 2x2 blocks
        {
            cBlue = pSrc[0];
            cGreen = pSrc[1];
            cRed = pSrc[2];
            iY1 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb1 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr1 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cBlue = pSrc[3];
            cGreen = pSrc[4];
            cRed = pSrc[5];
            iY2 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb2 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr2 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cBlue = pSrc[lsize];
            cGreen = pSrc[lsize+1];
            cRed = pSrc[lsize+2];
            iY3 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb3 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr3 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cBlue = pSrc[lsize+3];
            cGreen = pSrc[lsize+4];
            cRed = pSrc[lsize+5];
            iY4 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb4 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr4 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // Average the chroma values together
            iCr1 = (iCr1 + iCr2 + iCr3 + iCr4) >> 14;
            iCb1 = (iCb1 + iCb2 + iCb3 + iCb4) >> 14;
            
            // store in the MCUs
            pLUM[0] = (signed short)iY1;
            pLUM[1] = (signed short)iY2;
            pLUM[8] = (signed short)iY3;
            pLUM[9] = (signed short)iY4;
            pLUM += 2;
            pCr[0] = (signed short)iCr1;
            pCb[0] = (signed short)iCb1;
            pCr++;
            pCb++;
            pSrc += 6; // skip 2 pixels to right
        } // for x
        pCr += 8 - cx; // skip to next row;
        pCb += 8 - cx;
        pLUM += 8 + (4-cx)*2; // skip down a row since 2 at a time
        pSrc += lsize*2 - cx*6; // skip 2 lines
    } // for y
    
} /* JPEGSubSample24() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSubSample32()                                          *
 *                                                                          *
 *  PURPOSE    : Subsample a 8x8 color block by 2:1                         *
 *                                                                          *
 ****************************************************************************/
void JPEGSubSample32(unsigned char *pSrc, signed short *pLUM, signed short *pCb, signed short *pCr, int lsize, int cx, int cy)
{
    int x;
    unsigned char cRed, cGreen, cBlue;
    int iY1, iY2, iY3, iY4, iCr1, iCr2, iCr3, iCr4, iCb1, iCb2, iCb3, iCb4;
    int y;
    
    cx = (cx + 1)>>1; // do pixels in 2x2 blocks
    cy = (cy + 1)>>1;
    
    for (y = 0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels in 2x2 blocks
        {
            cRed = pSrc[0];
            cGreen = pSrc[1];
            cBlue = pSrc[2];
            iY1 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb1 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr1 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cRed = pSrc[4];
            cGreen = pSrc[5];
            cBlue = pSrc[6];
            iY2 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb2 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr2 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cRed = pSrc[lsize+0];
            cGreen = pSrc[lsize+1];
            cBlue = pSrc[lsize+2];
            iY3 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb3 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr3 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            cRed = pSrc[lsize+4];
            cGreen = pSrc[lsize+5];
            cBlue = pSrc[lsize+6];
            iY4 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb4 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr4 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // Average the chroma values together
            iCr1 = (iCr1 + iCr2 + iCr3 + iCr4) >> 14;
            iCb1 = (iCb1 + iCb2 + iCb3 + iCb4) >> 14;
            
            // store in the MCUs
            pLUM[0] = (signed short)iY1;
            pLUM[1] = (signed short)iY2;
            pLUM[8] = (signed short)iY3;
            pLUM[9] = (signed short)iY4;
            pLUM += 2;
            pCr[0] = (signed short)iCr1;
            pCb[0] = (signed short)iCb1;
            pCr++;
            pCb++;
            pSrc += 8; // skip 2 pixels to right
        } // for x
        pCr += 8 - cx; // skip to next row;
        pCb += 8 - cx;
        pLUM += 8 + (4-cx)*2; // skip down a row since 2 at a time
        pSrc += lsize*2 - cx*8; // skip 2 lines
    } // for y
    
} /* JPEGSubSample32() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSubSample18()                                          *
 *                                                                          *
 *  PURPOSE    : Subsample a 8x8 color block by 2:1                         *
 *  The odd bitsperpixel value was chosen to differentiate YV12 planar data.*
 ****************************************************************************/
void JPEGSubSample18(unsigned char *pSrc, PIL_PAGE *pPage, int x, int y, signed short *pLUM, signed short *pCb, signed short *pCr)
{
    int cx, cy, lsize, lsize2;
    unsigned char *pY, *pV, *pU;
    signed int iY1, iY2, iY3, iY4, iCr1, iCb1;
    
    // figure out where to read the Y, V and U since the data is planar
    
    lsize = pPage->iWidth;
    lsize2 = lsize>>1;
    pV = pSrc + (lsize*pPage->iHeight); // start of V section
    pU = pV + ((lsize*pPage->iHeight)>>2); // start of U section
    pY = pSrc + (x<<3) + ((y<<3)*lsize);
    pV += (x<<2) + ((y<<2)*lsize2);
    pU += (x<<2) + ((y<<2)*lsize2);
    
    for (cy=0; cy<4; cy++)
    {
        for (cx=0; cx<4; cx++) // do 8x8 pixels in 2x2 blocks
        {
            iY1 = pY[0] - 0x80;
            iY2 = pY[1] - 0x80;
            iY3 = pY[lsize+0] - 0x80;
            iY4 = pY[lsize+1] - 0x80;
            iCr1 = (*pV++) - 0x80;
            iCb1 = (*pU++) - 0x80;
            
            // store in the MCUs
            pLUM[0] = (signed short)iY1;
            pLUM[1] = (signed short)iY2;
            pLUM[8] = (signed short)iY3;
            pLUM[9] = (signed short)iY4;
            pLUM += 2;
            *pCr++ = (signed short)iCr1;
            *pCb++ = (signed short)iCb1;
            pSrc += 2; // skip 2 pixels to right
        } // for x
        pLUM += 8; // skip down a row since 2 at a time
        pSrc += lsize*2 - 8; // skip 2 lines
        pV += (lsize2 - 4);
        pU += (lsize2 - 4);
    } // for y
    
} /* JPEGSubSample18() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSubSample17()                                          *
 *                                                                          *
 *  PURPOSE    : Subsample a 8x8 color block by 2:1                         *
 *  The odd bitsperpixel value was chosen to differentiate VYUY data.       *
 ****************************************************************************/
void JPEGSubSample17(unsigned char *pSrc, signed short *pLUM, signed short *pCb, signed short *pCr, int lsize, int cx, int cy)
{
    int x, y;
    signed int iY1, iY2, iY3, iY4, iCr1, iCr2, iCb1, iCb2;
    
    cx = (cx + 1)>>1; // do pixels in 2x2 blocks
    cy = (cy + 1)>>1;
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels in 2x2 blocks
        {
            iCr1 = pSrc[0] - 0x80;
            iY1 = pSrc[1] - 0x80;
            iCb1 = pSrc[2] - 0x80;
            iY2 = pSrc[3] - 0x80;
            
            iCr2 = pSrc[lsize] - 0x80;
            iY3 = pSrc[lsize+1] - 0x80;
            iCb2 = pSrc[lsize+2] - 0x80;
            iY4 = pSrc[lsize+3] - 0x80;
            
            // Average the chroma values together
            iCr1 = (iCr1 + iCr2) >> 1;
            iCb1 = (iCb1 + iCb2) >> 1;
            
            // store in the MCUs
            pLUM[0] = (signed short)iY1;
            pLUM[1] = (signed short)iY2;
            pLUM[8] = (signed short)iY3;
            pLUM[9] = (signed short)iY4;
            pLUM += 2;
            *pCr++ = (signed short)iCr1;
            *pCb++ = (signed short)iCb1;
            pSrc += 4; // skip 2 pixels to right
        } // for x
        pCr += 8 - cx; // skip to next row;
        pCb += 8 - cx;
        pLUM += 8 + (4-cx)*2; // skip down a row since 2 at a time
        pSrc += lsize*2 - cx*4; // skip 2 lines
    } // for y
    
} /* JPEGSubSample17() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSubSample16()                                          *
 *                                                                          *
 *  PURPOSE    : Subsample a 8x8 color block by 2:1                         *
 *                                                                          *
 ****************************************************************************/
void JPEGSubSample16(unsigned char *pSrc, signed short *pLUM, signed short *pCb, signed short *pCr, int lsize, int cx, int cy)
{
    int x, y;
    unsigned short us;
    unsigned short *pUS = (unsigned short *)pSrc;
    unsigned char cRed, cGreen, cBlue;
    int iY1, iY2, iY3, iY4, iCr1, iCr2, iCr3, iCr4, iCb1, iCb2, iCb3, iCb4;
    
    cx = (cx + 1)>>1; // do pixels in 2x2 blocks
    cy = (cy + 1)>>1;
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels in 2x2 blocks
        {
            us = pUS[0];
            cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
            cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            iY1 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb1 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr1 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            us = pUS[1];
            cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
            cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            iY2 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb2 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr2 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            us = pUS[lsize>>1];
            cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
            cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            iY3 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb3 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr3 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            us = pUS[(lsize>>1)+1];
            cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
            cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            iY4 = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb4 = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr4 = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // Average the chroma values together
            iCr1 = (iCr1 + iCr2 + iCr3 + iCr4) >> 14;
            iCb1 = (iCb1 + iCb2 + iCb3 + iCb4) >> 14;
            
            // store in the MCUs
            pLUM[0] = (signed short)iY1;
            pLUM[1] = (signed short)iY2;
            pLUM[8] = (signed short)iY3;
            pLUM[9] = (signed short)iY4;
            pLUM += 2;
            pCr[0] = (signed short)iCr1;
            pCb[0] = (signed short)iCb1;
            pCr++;
            pCb++;
            pUS += 2; // skip 2 pixels to right
        } // for x
        pCr += 8 - cx; // skip to next row;
        pCb += 8 - cx;
        pLUM += 8 + (4-cx)*2; // skip down a row since 2 at a time
        pUS += lsize - cx*2; // skip 2 lines
    } // for y
    
} /* JPEGSubSample16() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGetMCU22()                                             *
 *                                                                          *
 *  PURPOSE    : Get a 16x16 block of color image data read for compression *
 *                                                                          *
 ****************************************************************************/
void JPEGGetMCU22(unsigned char *pImage, PIL_PAGE *pPage, int lsize, int x, int y, signed short *pMCUData, int bUseSIMD)
{
    int cx, cy, width, height;
    //signed short *pDest;
    unsigned char *pSrc = NULL;
    
    if (pPage->cFlags & PIL_PAGEFLAGS_BOTTOMUP)
    {
        pImage += lsize * (pPage->iHeight-1);
        lsize = -lsize;
    }
    if (pPage->cBitsperpixel == 16)
        pSrc = pImage + x*16*2 + (y * 16 * lsize);
    else if (pPage->cBitsperpixel == 24)
        pSrc = pImage + x*16*3 + (y * 16 * lsize);
    else if (pPage->cBitsperpixel == 17)
        pSrc = pImage + x*8*4 + (y * 16 * lsize);
    else if (pPage->cBitsperpixel == 32)
        pSrc = pImage + x*16*4 + (y * 16 * lsize);
    else
        return; // invalid bit depth
    //    pDest = pMCUData;
    width = height = 16;
    if (x*16 + width > pPage->iWidth)
        width = pPage->iWidth & 15;
    if (y*16 + height > pPage->iHeight)
        height = pPage->iHeight & 15;
    if (width < 8)
        cx = width;
    else
        cx = 8;
    if (height < 8)
        cy = height;
    else
        cy = 8;
    if (cy != 8 || cx != 8) // for edge MCUs, make sure all unused slots are 0
        memset(pMCUData, 0, 6*64*sizeof(short));
    if (pPage->cBitsperpixel == 16)
    {
        // upper left
        JPEGSubSample16(pSrc, pMCUData, &pMCUData[DCTSIZE2*4], &pMCUData[DCTSIZE2*5], lsize, cx, cy);
        // upper right
        if (width > 8)
            JPEGSubSample16(pSrc+8*2, &pMCUData[DCTSIZE2*1], &pMCUData[4+DCTSIZE2*4], &pMCUData[4+DCTSIZE2*5], lsize, width-8, cy);
        if (height > 8)
        {
            // lower left
            JPEGSubSample16(pSrc+8*lsize, &pMCUData[DCTSIZE2*2], &pMCUData[32+DCTSIZE2*4], &pMCUData[32+DCTSIZE2*5], lsize, cx, height - 8);
            // lower right
            if (width > 8)
                JPEGSubSample16(pSrc+8*lsize + 8*2, &pMCUData[DCTSIZE2*3], &pMCUData[36+DCTSIZE2*4], &pMCUData[36+DCTSIZE2*5], lsize, width - 8, height - 8);
        }
    }
    else if (pPage->cBitsperpixel == 24)
    {
        if (bUseSIMD)
        {
            // upper left
            JPEGSubSample24_SIMD(pSrc, pMCUData, &pMCUData[DCTSIZE2*4], &pMCUData[DCTSIZE2*5], lsize, cx, cy);
            // upper right
            if (width > 8)
                JPEGSubSample24_SIMD(pSrc+8*3, &pMCUData[DCTSIZE2*1], &pMCUData[4+DCTSIZE2*4], &pMCUData[4+DCTSIZE2*5], lsize, width-8, cy);
            if (height > 8)
            {
                // lower left
                JPEGSubSample24_SIMD(pSrc+8*lsize, &pMCUData[DCTSIZE2*2], &pMCUData[32+DCTSIZE2*4], &pMCUData[32+DCTSIZE2*5], lsize, cx, height - 8);
                // lower right
                if (width > 8)
                    JPEGSubSample24_SIMD(pSrc+8*lsize + 8*3, &pMCUData[DCTSIZE2*3], &pMCUData[36+DCTSIZE2*4], &pMCUData[36+DCTSIZE2*5], lsize, width - 8, height - 8);
            }
        }
        else
        {
            // upper left
            JPEGSubSample24(pSrc, pMCUData, &pMCUData[DCTSIZE2*4], &pMCUData[DCTSIZE2*5], lsize, cx, cy);
            // upper right
            if (width > 8)
                JPEGSubSample24(pSrc+8*3, &pMCUData[DCTSIZE2*1], &pMCUData[4+DCTSIZE2*4], &pMCUData[4+DCTSIZE2*5], lsize, width-8, cy);
            if (height > 8)
            {
                // lower left
                JPEGSubSample24(pSrc+8*lsize, &pMCUData[DCTSIZE2*2], &pMCUData[32+DCTSIZE2*4], &pMCUData[32+DCTSIZE2*5], lsize, cx, height - 8);
                // lower right
                if (width > 8)
                    JPEGSubSample24(pSrc+8*lsize + 8*3, &pMCUData[DCTSIZE2*3], &pMCUData[36+DCTSIZE2*4], &pMCUData[36+DCTSIZE2*5], lsize, width - 8, height - 8);
            }
        }
    }
    else if (pPage->cBitsperpixel == 32)
    {
        if (bUseSIMD)
        {
            // upper left
            JPEGSubSample32_SIMD(pSrc, pMCUData, &pMCUData[DCTSIZE2*4], &pMCUData[DCTSIZE2*5], lsize, cx, cy);
            // upper right
            if (width > 8)
                JPEGSubSample32_SIMD(pSrc+8*4, &pMCUData[DCTSIZE2*1], &pMCUData[4+DCTSIZE2*4], &pMCUData[4+DCTSIZE2*5], lsize, width-8, cy);
            if (height > 8)
            {
                // lower left
                JPEGSubSample32_SIMD(pSrc+8*lsize, &pMCUData[DCTSIZE2*2], &pMCUData[32+DCTSIZE2*4], &pMCUData[32+DCTSIZE2*5], lsize, cx, height - 8);
                // lower right
                if (width > 8)
                    JPEGSubSample32_SIMD(pSrc+8*lsize + 8*4, &pMCUData[DCTSIZE2*3], &pMCUData[36+DCTSIZE2*4], &pMCUData[36+DCTSIZE2*5], lsize, width - 8, height - 8);
            }
        }
        else
        {
            // upper left
            JPEGSubSample32(pSrc, pMCUData, &pMCUData[DCTSIZE2*4], &pMCUData[DCTSIZE2*5], lsize, cx, cy);
            // upper right
            if (width > 8)
                JPEGSubSample32(pSrc+8*4, &pMCUData[DCTSIZE2*1], &pMCUData[4+DCTSIZE2*4], &pMCUData[4+DCTSIZE2*5], lsize, width-8, cy);
            if (height > 8)
            {
                // lower left
                JPEGSubSample32(pSrc+8*lsize, &pMCUData[DCTSIZE2*2], &pMCUData[32+DCTSIZE2*4], &pMCUData[32+DCTSIZE2*5], lsize, cx, height - 8);
                // lower right
                if (width > 8)
                    JPEGSubSample32(pSrc+8*lsize + 8*4, &pMCUData[DCTSIZE2*3], &pMCUData[36+DCTSIZE2*4], &pMCUData[36+DCTSIZE2*5], lsize, width - 8, height - 8);
            }
        }
    }
    else if (pPage->cBitsperpixel == 17) // special case for VYUY data
    {
        // upper left
        JPEGSubSample17(pSrc, pMCUData, &pMCUData[DCTSIZE2*4], &pMCUData[DCTSIZE2*5], lsize, cx, cy);
        // upper right
        if (width > 8)
            JPEGSubSample17(pSrc+4*4, &pMCUData[DCTSIZE2*1], &pMCUData[4+DCTSIZE2*4], &pMCUData[4+DCTSIZE2*5], lsize, width-8, cy);
        if (height > 8)
        {
            // lower left
            JPEGSubSample17(pSrc+8*lsize, &pMCUData[DCTSIZE2*2], &pMCUData[32+DCTSIZE2*4], &pMCUData[32+DCTSIZE2*5], lsize, cx, height - 8);
            // lower right
            if (width > 8)
                JPEGSubSample17(pSrc+8*lsize + 4*4, &pMCUData[DCTSIZE2*3], &pMCUData[36+DCTSIZE2*4], &pMCUData[36+DCTSIZE2*5], lsize, width - 8, height - 8);
        }
    }
    else if (pPage->cBitsperpixel == 18) // special case for YV12 (planar, subsampled) data
    {
        // upper left
        JPEGSubSample18(pImage, pPage, x*2, y*2, pMCUData, &pMCUData[DCTSIZE2*4], &pMCUData[DCTSIZE2*5]);
        // upper right
        JPEGSubSample18(pImage, pPage, (x*2)+1, y*2, &pMCUData[DCTSIZE2*1], &pMCUData[4+DCTSIZE2*4], &pMCUData[4+DCTSIZE2*5]);
        // lower left
        JPEGSubSample18(pImage, pPage, x*2, (y*2)+1, &pMCUData[DCTSIZE2*2], &pMCUData[32+DCTSIZE2*4], &pMCUData[32+DCTSIZE2*5]);
        // lower right
        JPEGSubSample18(pImage, pPage, (x*2)+1,(y*2)+1, &pMCUData[DCTSIZE2*3], &pMCUData[36+DCTSIZE2*4], &pMCUData[36+DCTSIZE2*5]);
    }
} /* JPEGGetMCU22() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSample16()                                             *
 *                                                                          *
 *  PURPOSE    : Sample a 8x8 color block                                   *
 *                                                                          *
 ****************************************************************************/
void JPEGSample16(unsigned char *pSrc, signed short *pMCU, int lsize, int cx, int cy)
{
    int x, y;
    unsigned short us;
    unsigned short *pUS = (unsigned short *)pSrc;
    unsigned char cRed, cGreen, cBlue;
    int iY, iCr, iCb;
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels
        {
            us = *pUS++;
            cBlue = (unsigned char)(((us & 0x1f)<<3) | (us & 7));
            cGreen = (unsigned char)(((us & 0x7e0)>>3) | ((us & 0x60)>>5));
            cRed = (unsigned char)(((us & 0xf800)>>8) | ((us & 0x3800)>>11));
            iY = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // store in the MCUs
            pMCU[64]  = (signed short)(iCb >> 12);
            pMCU[128]  = (signed short)(iCr >> 12);
            *pMCU++ = (signed short)iY;
        } // for x
        pMCU += 8 - cx;
        pUS += (lsize>>1) - cx;
    } // for y
    
} /* JPEGSample16() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSample24()                                             *
 *                                                                          *
 *  PURPOSE    : Sample a 8x8 color block                                   *
 *                                                                          *
 ****************************************************************************/
void JPEGSample24(unsigned char *pSrc, signed short *pMCU, int lsize, int cx, int cy)
{
    int x;
    unsigned char cRed, cGreen, cBlue;
    int iY, iCr, iCb;
    int y;
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels
        {
            cBlue = *pSrc++;
            cGreen = *pSrc++;
            cRed = *pSrc++;
            iY = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // store in the MCUs
            pMCU[64]  = (signed short)(iCb >> 12);
            pMCU[128]  = (signed short)(iCr >> 12);
            *pMCU++ = (signed short)iY;
        } // for x
        pMCU += 8 - cx;
        pSrc += lsize - cx*3;
    } // for y
    
} /* JPEGSample24() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGSample32()                                             *
 *                                                                          *
 *  PURPOSE    : Sample a 8x8 color block                                   *
 *                                                                          *
 ****************************************************************************/
void JPEGSample32(unsigned char *pSrc, signed short *pMCU, int lsize, int cx, int cy)
{
    int x, y;
    unsigned char cRed, cGreen, cBlue;
    int iY, iCr, iCb;
    
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++) // do 8x8 pixels
        {
            cRed = pSrc[0];
            cGreen = pSrc[1];
            cBlue = pSrc[2];
            pSrc += 4;
            iY = (((cRed * 1225) + (cGreen * 2404) + (cBlue * 467)) >> 12) - 0x80;
            iCb = (cBlue << 11) + (cRed * -691) + (cGreen * -1357);
            iCr = (cRed << 11) + (cGreen * -1715) + (cBlue * -333);
            
            // store in the MCUs
            pMCU[64]  = (signed short)(iCb >> 12);
            pMCU[128]  = (signed short)(iCr >> 12);
            *pMCU++ = (signed short)iY;
        } // for x
        pMCU += 8 - cx;
        pSrc += lsize - cx*4;
    } // for y
    
} /* JPEGSample32() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGGetMCU11()                                             *
 *                                                                          *
 *  PURPOSE    : Get a 8x8 block of color image data read for compression   *
 *                                                                          *
 ****************************************************************************/
void JPEGGetMCU11(unsigned char *pImage, PIL_PAGE *pPage, int lsize, int x, int y, signed short *pMCUData, int bUseSIMD)
{
    int cx, cy;
    //signed short *pDest;
    unsigned char *pSrc;
    
    if (pPage->cFlags & PIL_PAGEFLAGS_BOTTOMUP)
    {
        pImage += lsize * (pPage->iHeight-1);
        lsize = -lsize;
    }
    if (pPage->cBitsperpixel == 24)
        pSrc = pImage + x*8*3 + (y * 8 * lsize);
    else if (pPage->cBitsperpixel == 16)
        pSrc = pImage + x*8*2 + (y * 8 * lsize);
    else // 32bpp
        pSrc = pImage + x*8*4 + (y * 8 * lsize);
    //    pDest = pMCUData;
    if (x*8 + 8 > pPage->iWidth)
        cx = pPage->iWidth & 7;
    else
        cx = 8;
    if (y*8 + 8 > pPage->iHeight)
        cy = pPage->iHeight & 7;
    else
        cy = 8;
    if (cy != 8 || cx != 8)
        memset(pMCUData, 0, 3*64*sizeof(short)); // make sure unused pixels are 0
    if (pPage->cBitsperpixel == 24)
    {
        if (bUseSIMD)
            JPEGSample24_SIMD(pSrc, pMCUData, lsize, cx, cy);
        else
            JPEGSample24(pSrc, pMCUData, lsize, cx, cy);
    }
    else if (pPage->cBitsperpixel == 16)
        JPEGSample16(pSrc, pMCUData, lsize, cx, cy);
    else
        JPEGSample32(pSrc, pMCUData, lsize, cx, cy);
    
} /* JPEGGetMCU11() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGMakeHuffE(JPEGDATA *)                                  *
 *                                                                          *
 *  PURPOSE    : Create the Huffman tables for encoding an MCU.             *
 *                                                                          *
 ****************************************************************************/
void JPEGMakeHuffE(JPEGDATA *pJPEG)
{
    int code, iLen, iTable;
    unsigned short *pTable;
    int iBitNum; // current code bit length
    int n_bits; // number of bits to do
    int cc; // code
    unsigned char *p, *pBits;
    int iTableCount;
    
    if (pJPEG->ucNumComponents == 1)
        iTableCount = 1;
    else
        iTableCount = 2;
    
    // first do DC components (up to 12-bit codes)
    for (iTable = 0; iTable < iTableCount; iTable++)
    {
        pJPEG->huffdc[iTable] = (int *)&pJPEG->ucHuffACDCBuf[iTable*0x1000]; // each table gets 4K
        pTable = (unsigned short *)pJPEG->huffdc[iTable];
        if (iTable == 0)
            pBits = (unsigned char *)huffl_dc;
        else
            pBits = (unsigned char *)huffcr_dc;
        p = (unsigned char *)pBits;
        p += 16; // point to bit data
        iBitNum = 1;
        cc = 0; // start with a code of 0
        for (n_bits = 0; n_bits < 16; n_bits++)
        {
            iLen = *pBits++; // get number of codes for this bit length
            while (iLen)
            {
                code = *p++;  // get actual huffman code
                pTable[code] = (unsigned short)cc;
                pTable[code+512] = (unsigned short)iBitNum; // store the length here
                cc++;
                iLen--;
            }
            iBitNum++;
            cc <<= 1;
        }
    }
    // now do AC components (up to 16-bit codes)
    for (iTable = 0; iTable < iTableCount; iTable++)
    {
        pTable = (unsigned short *)pJPEG->huffdc[iTable];
        if (iTable == 0)
            pBits = (unsigned char *)huffl_ac;
        else
            pBits = (unsigned char *)huffcr_ac;
        p = (unsigned char *)pBits;
        p += 16; // point to bit data
        iBitNum = 1;
        cc = 0; // start with a code of 0
        for (n_bits = 0; n_bits < 16; n_bits++)
        {
            iLen = *pBits++; // get number of codes for this bit length
            while (iLen)
            {
                code = *p++;  // get actual huffman code
                pTable[1024+code] = (unsigned short)cc;
                pTable[1536+code] = (unsigned short)iBitNum;
                cc++;
                iLen--;
            }
            iBitNum++;
            cc <<= 1;
        }
    }
} /* JPEGMakeHuffE() */

#if defined(_X86) && defined(_X64)
/******************************************************************************
 *                                                                            *
 *  FUNCTION   : JPEGQuantize(JPEGDATA, int *)                                *
 *                                                                            *
 *  PURPOSE    : Quantize and re-order the MCU data.                          *
 *                                                                            *
 ******************************************************************************/
uint64_t JPEGQuantize(JPEGDATA *pJPEG, signed short *pMCUSrc, int iTable)
{
#ifdef _X86
    __m128i xmmIn, xmmQuant, xmmQuant2, xmmMask, xmmTemp, xmmZero;
#endif // _X86
    int i, iBits;
    signed short *pQuant;
    uint64_t *pZigFlags = (uint64_t *)&ullZigZagConvert[0]; // translation table for zigzag order
    uint64_t ullBits = 0; // one bit for each non-zero A/C coefficient
    
    pQuant = (signed short *)&pJPEG->sQuantTable[iTable * 64];
    xmmZero = _mm_setzero_si128();
    // Preload to unroll the loop 1x
    for (i = 0; i < 8; i++) // do 8 rows of 8 values
    {
        xmmQuant = _mm_loadu_si128((__m128i *)&pQuant[256]);
        xmmQuant2 = _mm_loadu_si128((__m128i*)&pQuant[0]); // get original values for rounding
        xmmIn = _mm_loadu_si128((__m128i *)&pMCUSrc[0]);
        xmmQuant2 = _mm_srli_epi16(xmmQuant2, 1);
        xmmMask = _mm_cmplt_epi16(xmmIn, xmmZero); // get a mask for the negative values
        xmmTemp = _mm_sub_epi16(xmmQuant2, xmmIn); // prepare for negative results
        xmmIn = _mm_add_epi16(xmmIn, xmmQuant2); // prepare for positive results
        xmmTemp = _mm_mulhi_epi16(xmmTemp, xmmQuant); // high results of multiply are the scaled values
        xmmIn = _mm_mulhi_epi16(xmmIn, xmmQuant);
        xmmTemp = _mm_sub_epi16(xmmZero, xmmTemp); // final result of negative values
        xmmIn = _mm_andnot_si128(xmmMask, xmmIn); // keep the positive results
        xmmTemp = _mm_and_si128(xmmTemp, xmmMask); // keep only the negative results we need
        xmmIn = _mm_or_si128(xmmTemp, xmmIn); // combine negative and positive results
        xmmTemp = _mm_cmpeq_epi16(xmmIn, xmmZero); // determine which coeff's are 0
        xmmTemp = _mm_packs_epi16(xmmTemp, xmmZero); // we can only create a mask from 8-bit values
        iBits = _mm_movemask_epi8(xmmTemp); // collect upper bits of comparison
        _mm_storeu_si128((__m128i*)pMCUSrc, xmmIn); // store the finished values
        ullBits |= pZigFlags[iBits]; // accumulate the flags for each row
        pZigFlags += 256; // next set
        pMCUSrc += 8;
        pQuant += 8;
    }
    return ullBits;
} /* JPEGQuantize() */
#else
/******************************************************************************
 *                                                                            *
 *  FUNCTION   : JPEGQuantize(JPEGDATA, int *)                                *
 *                                                                            *
 *  PURPOSE    : Quantize and re-order the MCU data.                          *
 *                                                                            *
 *  NOTES:  Try to avoid divides which result in 0 or 1 (lots).               *
 *          This doesn't make much of a difference on x86, but it does on ARM *
 ******************************************************************************/
int JPEGQuantize(JPEGDATA *pJPEG, signed short *pMCUSrc, int iTable)
{
#ifdef _X86
    __m128i xmmIn, xmmQuant, xmmQuant2, xmmMask, xmmTemp, xmmZero, xmmSparse, xmmSparseMask;
    __m128i preIn, preQuant, preQuant2; // preloaded values
#else // _X86
    signed int d, sQ1, sQ2;
    int bSparse = FALSE; // determine if it results in a sparse matrix and flag it for faster encoding
#endif
    int i;
    signed short *pQuant;
    //unsigned char *pZigZag = cZigZag;
    
    // The idea behind the sparse mask is to determine if the lower right corner of the
    // MCU block is filled with zeros. This will allow quicker encoding since the last 36
    // zeros don't have to be scanned.
    //
    // *******z
    // ******zz
    // *****zzz
    // ****zzzz
    // ***zzzzz
    // **zzzzzz
    // *zzzzzzz
    // zzzzzzzz
    
    pQuant = (signed short *)&pJPEG->sQuantTable[iTable * 64];
#ifdef _X86
    xmmZero = _mm_setzero_si128();
    xmmSparse = _mm_setzero_si128(); // accumulator to test for sparse matrix
    xmmSparseMask = _mm_cmpeq_epi16(xmmZero, xmmZero); // all FF's
    // Preload to unroll the loop 1x
    preIn = _mm_loadu_si128((__m128i *)pMCUSrc);
    preQuant = _mm_loadu_si128((__m128i *)&pQuant[256]);
    preQuant2 = _mm_loadu_si128((__m128i*)&pQuant[0]);
    for (i = 0; i < 8; i++) // do 8 rows of 8 values
    {
        xmmIn = preIn; // use the pre-loaded values
        xmmQuant = preQuant;
        xmmQuant2 = preQuant2;
        preQuant = _mm_loadu_si128((__m128i *)&pQuant[256+8]);
        preQuant2 = _mm_loadu_si128((__m128i*)&pQuant[8]); // get original values for rounding
        preIn = _mm_loadu_si128((__m128i *)&pMCUSrc[8]);
        xmmSparseMask = _mm_srli_si128(xmmSparseMask, 2); // open up 2 more bytes of 0000 in top end
        xmmQuant2 = _mm_srli_epi16(xmmQuant2, 1);
        xmmMask = _mm_cmplt_epi16(xmmIn, xmmZero); // get a mask for the negative values
        xmmTemp = _mm_sub_epi16(xmmQuant2, xmmIn); // prepare for negative results
        xmmIn = _mm_add_epi16(xmmIn, xmmQuant2); // prepare for positive results
        xmmTemp = _mm_mulhi_epi16(xmmTemp, xmmQuant); // high results of multiple are the scaled values
        xmmIn = _mm_mulhi_epi16(xmmIn, xmmQuant);
        xmmTemp = _mm_sub_epi16(xmmZero, xmmTemp); // final result of negative values
        xmmIn = _mm_andnot_si128(xmmMask, xmmIn); // keep the positive results
        xmmTemp = _mm_and_si128(xmmTemp, xmmMask); // keep only the negative results we need
        xmmIn = _mm_or_si128(xmmTemp, xmmIn); // combine negative and positive results
        xmmTemp = _mm_andnot_si128(xmmSparseMask, xmmIn); // mask off the part we care about
        xmmSparse = _mm_or_si128(xmmSparse, xmmTemp); // accumulate lower right triangle to see if all 0's
        _mm_storeu_si128((__m128i*)pMCUSrc, xmmIn); // store the finished values
        pMCUSrc += 8;
        pQuant += 8;
    }
    xmmSparse = _mm_cmpeq_epi16(xmmSparse, xmmZero); //see if any elements are not zero
    return (int)(_mm_movemask_epi8(xmmSparse) == 0xffff); // if all elements are 0, we have a sparse matrix
#endif
#if !defined(_X86)
    for (i=0; i<64; i++)
    {
        sQ1 = pQuant[i];
        sQ2 = sQ1 >> 1;
        d = *pMCUSrc;
        // avoid doing divides
        if (d < 0)
        {
            *pMCUSrc++ = 0 - (((sQ2 - d) * pQuant[i + 256]) >> 16);
        }
        else
        {
            *pMCUSrc++ = (((sQ2 + d) * pQuant[i + 256]) >> 16);
        }
    } // for
    return bSparse;
#endif // !_X86
} /* JPEGQuantize() */
#endif

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MakeGrayJPEG()                                             *
 *                                                                          *
 *  PURPOSE    : Encode an image as grayscale JPEG.                         *
 *                                                                          *
 ****************************************************************************/
void MakeGrayJPEG(void *p)
{
    unsigned char *pImage;
    signed short *pMCUData;
    int x, y, cx, cy, iDCPred;
    int lsize;
    int iRestart;
    PIL_CODE pc;
    JPEGDATA *pJPEG;
    JPEG_SLICE *pSlice;
#ifdef _X64
    uint64_t bSparse;
#else
    int bSparse;
#endif
    PIL_PAGE ppTemp;
    int bTrueGray;
    unsigned char ucGrayPalette[256], *pPalette;
    
    pSlice = (JPEG_SLICE *) p;
    
    // make a grayscale palette to translate the pixels (if needed)
    pPalette = NULL;
    bTrueGray = TRUE;
    if (pSlice->pPalette != NULL)
    {
        for (cx = 0; cx < 256; cx++)
        {
            cy = pSlice->pPalette[(cx * 3)] + (pSlice->pPalette[(cx * 3) + 1] << 1) + pSlice->pPalette[(cx * 3) + 2];
            cy = (cy >> 2); // -128;
            ucGrayPalette[cx] = (unsigned char) cy;
            if (cy != cx) bTrueGray = FALSE; // see if it's really a grayscale image
        }
        if (!bTrueGray)
            pPalette = ucGrayPalette; // we'll need to translate it through a palette
    }
    
    pJPEG = pSlice->pJPEG;
    iRestart = pSlice->uiResCount;
    ppTemp.cBitsperpixel = (char)pSlice->iDCPred1; // stored here
    ppTemp.iWidth = pSlice->uiWidth;
    ppTemp.iHeight = pSlice->uiHeight;
//    ppTemp.iPitch = pSlice->uiPitch;
    
    pc.iLen = 0;
    pc.ulAcc = 0;
    pc.pOut = pSlice->pData;
    
    pImage = pSlice->pBitmap;
    lsize = pSlice->uiPitch;
    pMCUData = pSlice->pMCU;
    cx = (pSlice->uiWidth + 7)>>3; // number of MCU blocks
    cy = (pSlice->uiHeight + 7)>>3;
    //   pJPEG->pHuffDC = pJPEG->huffdc[0];
    iDCPred = 0;
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            JPEGGetMCU(pImage, &ppTemp, lsize, x, y, pMCUData, pPalette);
            if (pJPEG->iOptions & PIL_CONVERT_SIMD)
                JPEGFDCT_SIMD(pMCUData);
            else
                JPEGFDCT(pMCUData);
            bSparse = JPEGQuantize(pJPEG, pMCUData, 0);
            iDCPred = JPEGEncodeMCU(0, pJPEG, pMCUData, &pc, iDCPred, bSparse);
        }
        // Store the restart marker
        PILFlushCode(&pc, TRUE);
        *(pc.pOut)++ = 0xff; // store restart marker
        *(pc.pOut)++ = (unsigned char) (0xd0 + (iRestart & 7));
        iRestart++;
        iDCPred = 0; // reset the DC predictor
    }
    PILFlushCode(&pc, TRUE);
    pSlice->uiLen = (int)(pc.pOut - pSlice->pData);
    pSlice->iError = 0;
    pSlice->uiFlag = PIL_THREAD_COMPLETE;
    
} /* MakeGrayJPEG() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MakeColorJPEG()                                            *
 *                                                                          *
 *  PURPOSE    : Encode an image as RGB color JPEG.                         *
 *                                                                          *
 ****************************************************************************/
void MakeColorJPEG(void *p)
{
    unsigned char *pImage;
    signed short *pMCUData;
    int x, y, cx, cy, iDCPred0, iDCPred1, iDCPred2;
    int lsize, iQFactor, iRestart;
    PIL_CODE pc;
#if defined(_X86) && defined(_X64)
    uint64_t bSparse;
#else
    int bSparse;
#endif
    JPEG_SLICE *pSlice = (JPEG_SLICE *) p;
    JPEGDATA *pJPEG;
    PIL_PAGE ppTemp;
    int bUseSIMD;
    
    pJPEG = pSlice->pJPEG;
    bUseSIMD = pJPEG->iOptions & PIL_CONVERT_SIMD;
    iQFactor = pSlice->iDCPred0;
    iRestart = pSlice->uiResCount; // restart marker to start this "slice"
    ppTemp.cBitsperpixel = (char)pSlice->iDCPred1; // stored here
    ppTemp.iWidth = pSlice->uiWidth;
    ppTemp.iHeight = pSlice->uiHeight;
//    ppTemp.iPitch = pSlice->uiPitch;
    ppTemp.cFlags = 0;
    
    // init code stream structure
    pc.pOut = pSlice->pData; // output data pointer
    pc.ulAcc = 0;
    pc.iLen = 0;
    
    pImage = pSlice->pBitmap;
    lsize = pSlice->uiPitch;
    pMCUData = pSlice->pMCU;
    iDCPred0 = iDCPred1 = iDCPred2 = 0;
    if (iQFactor & PIL_CONVERT_QUALITY_SUBSAMPLE)
    {
        cx = (pSlice->uiWidth + 15)>>4; // number of MCU blocks
        cy = (pSlice->uiHeight + 15)>>4;
        for (y=0; y<cy; y++)
        {
            for (x=0; x<cx; x++)
            {
                JPEGGetMCU22(pImage, &ppTemp, lsize, x, y, pMCUData, pJPEG->iOptions & PIL_CONVERT_SIMD);
                /*--- First, encode the 4 luma blocks ---*/
                JPEGFDCT(pMCUData);
                bSparse = JPEGQuantize(pJPEG, pMCUData, 0);
                iDCPred0 = JPEGEncodeMCU(0, pJPEG, pMCUData, &pc, iDCPred0, bSparse);
                
                JPEGFDCT(&pMCUData[1*DCTSIZE2]);
                bSparse = JPEGQuantize(pJPEG, &pMCUData[1 * DCTSIZE2], 0);
                iDCPred0 = JPEGEncodeMCU(0, pJPEG, &pMCUData[1 * DCTSIZE2], &pc, iDCPred0, bSparse);
                
                JPEGFDCT(&pMCUData[2*DCTSIZE2]);
                bSparse = JPEGQuantize(pJPEG, &pMCUData[2 * DCTSIZE2], 0);
                iDCPred0 = JPEGEncodeMCU(0, pJPEG, &pMCUData[2 * DCTSIZE2], &pc, iDCPred0, bSparse);
                
                JPEGFDCT(&pMCUData[3*DCTSIZE2]);
                bSparse = JPEGQuantize(pJPEG, &pMCUData[3 * DCTSIZE2], 0);
                iDCPred0 = JPEGEncodeMCU(0, pJPEG, &pMCUData[3 * DCTSIZE2], &pc, iDCPred0, bSparse);
                
                /*--- Now do the chroma blocks ---*/
                JPEGFDCT(&pMCUData[4*DCTSIZE2]);
                bSparse = JPEGQuantize(pJPEG, &pMCUData[4 * DCTSIZE2], 1);
                iDCPred1 = JPEGEncodeMCU(1, pJPEG, &pMCUData[4 * DCTSIZE2], &pc, iDCPred1, bSparse);
                
                JPEGFDCT(&pMCUData[5*DCTSIZE2]);
                bSparse = JPEGQuantize(pJPEG, &pMCUData[5 * DCTSIZE2], 1);
                iDCPred2 = JPEGEncodeMCU(1, pJPEG, &pMCUData[5 * DCTSIZE2], &pc, iDCPred2, bSparse);
            } // for x
            // Store the restart marker
            PILFlushCode(&pc, TRUE);
            *(pc.pOut)++ = 0xff; // store restart marker
            *(pc.pOut)++ = (unsigned char) (0xd0 + (iRestart & 7));
            iRestart++;
            iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset the DC predictors
        } // for y
    }
    else
    { // interleaved, but no subsampling
        cx = (pSlice->uiWidth + 7)>>3; // number of MCU blocks
        cy = (pSlice->uiHeight + 7)>>3;
        for (y=0; y<cy; y++)
        {
            for (x=0; x<cx; x++)
            {
                JPEGGetMCU11(pImage, &ppTemp, lsize, x, y, pMCUData, bUseSIMD);
                /*--- First, encode the luma block ---*/
                JPEGFDCT(pMCUData);
                bSparse = JPEGQuantize(pJPEG, pMCUData, 0);
                iDCPred0 = JPEGEncodeMCU(0, pJPEG, pMCUData, &pc, iDCPred0, bSparse);
                
                /*--- Now do the chroma blocks ---*/
                JPEGFDCT(&pMCUData[1*DCTSIZE2]);
                bSparse = JPEGQuantize(pJPEG, &pMCUData[1 * DCTSIZE2], 1);
                iDCPred1 = JPEGEncodeMCU(1, pJPEG, &pMCUData[1 * DCTSIZE2], &pc, iDCPred1, bSparse);
                
                JPEGFDCT(&pMCUData[2*DCTSIZE2]);
                bSparse = JPEGQuantize(pJPEG, &pMCUData[2 * DCTSIZE2], 1);
                iDCPred2 = JPEGEncodeMCU(1, pJPEG, &pMCUData[2 * DCTSIZE2], &pc, iDCPred2, bSparse);
            } // for x
            // Store the restart marker
            PILFlushCode(&pc, TRUE);
            *(pc.pOut)++ = 0xff; // store restart marker
            *(pc.pOut)++ = (unsigned char)(0xd0 + (iRestart & 7));
            iRestart++;
            iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset the DC predictors
        } // for y
    }
    PILFlushCode(&pc, TRUE);
    pSlice->uiLen = (int)(pc.pOut - pSlice->pData);
    pSlice->iError = 0;
    pSlice->uiFlag = PIL_THREAD_COMPLETE;
    
} /* MakeColorJPEG() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILMakeJPEG(PIL_PAGE *, PIL_PAGE *, int)                   *
 *                                                                          *
 *  PURPOSE    : Convert an image into JPEG compressed data (JFIF format).  *
 *                                                                          *
 ****************************************************************************/
int PILMakeJPEG(PIL_PAGE *pPage, PIL_PAGE *pOutPage, int iQFactor)
{
    int i = 0, iOffset, iErr;
    int iOutSize;
    JPEGDATA *pJPEG;
    unsigned char *pBuf;
    int iNumThreads;
    JPEG_SLICE pJPEGSlices[16];
    
    iErr = 0;
    if (iQFactor & PIL_CONVERT_MULTITHREAD)
    {
        iNumThreads = PILIONumProcessors(); // see if we can accelerate the job
    }
    else
    {
        iNumThreads = 1; // user wants it to run on a single thread
    }
    //   iNumThreads = 1; // DEBUG - force single-threaded
    if (iQFactor & PIL_CONVERT_NOALLOC)
    {
        pBuf = pOutPage->pData;
        iOutSize = pPage->iDataSize; // assume it's the same size as the input image buffer
    }
    else
    {
        iOutSize = pPage->iDataSize + 8192;
        pOutPage->pData = pBuf = (unsigned char *) PILIOAllocNoClear(iOutSize); // this is a temp buffer which will be reclaimed to the true size at the end
        if (!pBuf) /* Allocate the output buffer structure */
            return PIL_ERROR_MEMORY;
    }
    if (iQFactor & PIL_CONVERT_NOALLOC)
        pJPEG =  pOutPage->pJPEG;
    else
        pJPEG = (JPEGDATA *)PILIOAlloc(sizeof(JPEGDATA));
    iOffset = 0;
    
    if (pPage->cBitsperpixel != 8 && pPage->cBitsperpixel != 32 && pPage->cBitsperpixel != 24 && pPage->cBitsperpixel != 16 && pPage->cBitsperpixel != 17 && pPage->cBitsperpixel != 18)
    {
        iErr = PIL_ERROR_INVPARAM;
        goto makejpegz;
    }
    if (pPage->cBitsperpixel == 8)
        pJPEG->ucNumComponents = 1;
    else
        pJPEG->ucNumComponents = 3;
    WRITEMOTO32(pBuf, iOffset, 0xffd8ffe0); // write app0 marker
    iOffset += 4;
//    if (pOutPage->cCompression == PIL_COMP_JPEG)
    {
        WRITEMOTO32(pBuf, iOffset, 0x00104a46); // JFIF
        iOffset += 4;
        WRITEMOTO32(pBuf, iOffset, 0x49460001);
        iOffset += 4;
    }
//    else // motion jpeg uses another identifier
//    {
//        {
//            WRITEMOTO32(pBuf, iOffset, 0x00104156); // AVI1
//            iOffset += 4;
//            WRITEMOTO32(pBuf, iOffset, 0x49310001);
//            iOffset += 4;
//        }
//    }
    WRITEMOTO16(pBuf, iOffset, 0x0101); // resolution units = dots per inch
    iOffset += 2;
    if (pPage->iXres > 0xffff || pPage->iXres < 0) // invalid value
        pPage->iXres = 0;
    if (pPage->iYres > 0xffff || pPage->iYres < 0) // invalid value
        pPage->iYres = 0;
    WRITEMOTO16(pBuf, iOffset, pPage->iXres); // store spacial resolution
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, pPage->iYres);
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0); // add 2 zeros
    iOffset += 2;
    // define quantization tables
    WRITEMOTO16(pBuf, iOffset, 0xffdb); // quantization table marker
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0x0043); // table size
    iOffset += 2;
    pBuf[iOffset++] = 0; // table type and number 0,8 bit
    for (i=0; i<64; i++)
    {
        switch (iQFactor & 7) // adjust table depending on quality factor
        {
            default:
            case 0: // best quality, divide by 4
                pBuf[iOffset++] = quant_lum[i] >> 2;
                break;
            case 1: // high quality, divide by 2
                pBuf[iOffset++] = quant_lum[i] >> 1;
                break;
            case 2: // medium quality factor, use values unchanged
                pBuf[iOffset++] = quant_lum[i];
                break;
            case 3: // low quality, use values * 2
                pBuf[iOffset++] = quant_lum[i] << 1;
                break;
            case 4: // ridiculously high quality
                pBuf[iOffset++] = quant95_lum[i];
                break;
        }
    }
    if (pPage->cBitsperpixel > 8) // add color quant tables
    {
        WRITEMOTO16(pBuf, iOffset, 0xffdb); // quantization table
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, 0x0043); // table size
        iOffset += 2;
        pBuf[iOffset++] = 1;  // table 1, 8 bit
        for (i=0; i<64; i++)
        {
            switch (iQFactor & 7) // adjust table depending on quality factor
            {
                case 0: // best quality, divide by 4
                    pBuf[iOffset++] = quant_color[i] >> 2;
                    break;
                case 1: // high quality, divide by 2
                    pBuf[iOffset++] = quant_color[i] >> 1;
                    break;
                case 2: // medium quality factor, use values unchanged
                    pBuf[iOffset++] = quant_color[i];
                    break;
                case 3: // low quality, use values * 2
                    pBuf[iOffset++] = quant_color[i] << 1;
                    break;
                case 4: // ridiculously high quality
                    pBuf[iOffset++] = quant95_color[i];
                    break;
            }
        }
    }
    // store the restart interval
    // use an interval of one MCU row
    if ((iQFactor & PIL_CONVERT_QUALITY_SUBSAMPLE) && pPage->cBitsperpixel > 8)
        i = (pPage->iWidth + 15) / 16; // number of MCUs in a row
    else
        i = (pPage->iWidth + 7) / 8;
    WRITEMOTO16(pBuf, iOffset, 0xffdd); // DRI marker
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 4); // fixed length of 4
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, i); // restart interval count
    iOffset += 2;
    
    // store the frame header
    WRITEMOTO16(pBuf, iOffset, 0xffc0); // SOF0 marker
    iOffset += 2;
    if (pPage->cBitsperpixel == 8)
    {
        pBuf[iOffset++] = 0;
        pBuf[iOffset++] = 11; // length = 11
        pBuf[iOffset++] = 8;   // sample precision
        WRITEMOTO16(pBuf, iOffset, pPage->iHeight); // image height
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, pPage->iWidth); // image width
        iOffset += 2;
        pBuf[iOffset++] = 1; // number of components = 1 (grayscale)
        pBuf[iOffset++] = 0; // component number
        WRITEMOTO16(pBuf, iOffset, 0x1100); // subsampling and quant table selector
        iOffset += 2;
    }
    else  // set up color stuff
    {
        pBuf[iOffset++] = 0;
        pBuf[iOffset++] = 17; // length = 17
        pBuf[iOffset++] = 8;   // sample precision
        WRITEMOTO16(pBuf, iOffset, pPage->iHeight); // image height
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, pPage->iWidth); // image width
        iOffset += 2;
        pBuf[iOffset++] = 3; // number of components = 3 (Ycc)
        pBuf[iOffset++] = 0; // component number 0 (Y)
        if (iQFactor & PIL_CONVERT_QUALITY_SUBSAMPLE)
        {
            WRITEMOTO16(pBuf, iOffset, 0x2200); // 2:1 subsampling and quant table selector
        }
        else
        {
            WRITEMOTO16(pBuf, iOffset, 0x1100); // no subsampling and quant table selector
        }
        iOffset += 2;
        pBuf[iOffset++] = 1; // component number 1 (Cb)
        WRITEMOTO16(pBuf, iOffset, 0x1101); // subsampling and quant table selector
        iOffset += 2;
        pBuf[iOffset++] = 2; // component number 2 (Cr)
        WRITEMOTO16(pBuf, iOffset, 0x1101); // subsampling and quant table selector
        iOffset += 2;
    }
    // define Huffman tables
    WRITEMOTO16(pBuf, iOffset, 0xffc4); // Huffman DC table
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0x1f); // Table length = 31
    iOffset += 2;
    pBuf[iOffset++] = 0; // table class = 0 (DC), id = 0
    memcpy(&pBuf[iOffset], huffl_dc, 28); // copy DC table
    iOffset += 28;
    // now the AC table
    WRITEMOTO16(pBuf, iOffset, 0xffc4); // Huffman AC table
    iOffset += 2;
    WRITEMOTO16(pBuf, iOffset, 0xb5); // Table length = 181
    iOffset += 2;
    pBuf[iOffset++] = 0x10; // table class = 1 (AC), id = 0
    memcpy(&pBuf[iOffset], huffl_ac, 178); // copy AC table
    iOffset += 178;
    if (pPage->cBitsperpixel > 8) // define a second set of tables for color
    {
        WRITEMOTO16(pBuf, iOffset, 0xffc4); // Huffman DC table
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, 0x1f); // Table length = 31
        iOffset += 2;
        pBuf[iOffset++] = 1; // table class = 0 (DC), id = 1
        memcpy(&pBuf[iOffset], huffcr_dc, 28); // copy DC table
        iOffset += 28;
        // now the AC table
        WRITEMOTO16(pBuf, iOffset, 0xffc4); // Huffman AC table
        iOffset += 2;
        WRITEMOTO16(pBuf, iOffset, 0xb5); // Table length = 181
        iOffset += 2;
        pBuf[iOffset++] = 0x11; // table class = 1 (AC), id = 1
        memcpy(&pBuf[iOffset], huffcr_ac, 178); // copy AC table
        iOffset += 178;
    }
    // Define the start of scan header (SOS)
    WRITEMOTO16(pBuf, iOffset, 0xffda); // SOS
    iOffset += 2;
    if (pPage->cBitsperpixel == 8)
    {
        WRITEMOTO16(pBuf, iOffset, 0x8); // Table length = 8
        iOffset += 2;
        pBuf[iOffset++] = 1;            // number of components in scan = 1 (grayscale)
        pBuf[iOffset++] = 0; // component id = 0
        pBuf[iOffset++] = 0; // dc/ac huffman table = 0/0
    }
    else // color
    {
        WRITEMOTO16(pBuf, iOffset, 0xc); // Table length = 12
        iOffset += 2;
        pBuf[iOffset++] = 3;            // number of components in scan = 3 (color)
        pBuf[iOffset++] = 0; // component id = 0
        pBuf[iOffset++] = 0; // dc/ac huffman table = 0/0
        pBuf[iOffset++] = 1; // component id = 1
        pBuf[iOffset++] = 0x11; // dc/ac huffman table = 1/1
        pBuf[iOffset++] = 2; // component id = 2
        pBuf[iOffset++] = 0x11; // dc/ac huffman table = 1/1
    }
    pBuf[iOffset++] = 0; // start of spectral selection
    pBuf[iOffset++] = 63; // end of spectral selection
    pBuf[iOffset++] = 0; // successive approximation bit
    
    // prepare the luma & chroma quantization tables
    for (i = 0; i<64; i++)
    {
        switch (iQFactor & 7)
        {
            case 0:
                pJPEG->sQuantTable[i] = quant_lum[i] >> 2;
                pJPEG->sQuantTable[i + 64] = quant_color[i] >> 2;
                break;
            case 1:
                pJPEG->sQuantTable[i] = (quant_lum[i] >> 1);
                pJPEG->sQuantTable[i + 64] = (quant_color[i] >> 1);
                break;
            case 2:
                pJPEG->sQuantTable[i] = quant_lum[i];
                pJPEG->sQuantTable[i + 64] = quant_color[i];
                break;
            case 3:
                pJPEG->sQuantTable[i] = (quant_lum[i] << 1);
                pJPEG->sQuantTable[i + 64] = (quant_color[i] << 1);
                break;
            case 4: // ridiculous quality
                pJPEG->sQuantTable[i] = quant95_lum[i];
                pJPEG->sQuantTable[i + 64] = quant95_color[i];
                break;
        }
    }
    JPEGFixQuantE(pJPEG); // reorder and scale quant table(s)
    JPEGMakeHuffE(pJPEG); // create the Huffman tables to encode
    
    // Prepare 1 or more "slices" to encode the image with multiple threads
    if (iNumThreads > 1)
    {
        int cy, dy, iRowsPerThread; // we divide the output into restart intervals of 1 row each
        int iRowsToCompress, iOutDelta, iRemainder;
        int iStartingRow;
        if ((iQFactor & PIL_CONVERT_QUALITY_SUBSAMPLE) && pPage->cBitsperpixel > 8)
        {
            cy = (pPage->iHeight + 15) / 16; // number of MCU rows
            dy = 16;
        }
        else
        {
            cy = (pPage->iHeight + 7) / 8; // number of MCU rows
            dy = 8;
        }
        iRowsPerThread = cy / iNumThreads;
        iRemainder = cy % iNumThreads; // divide the remainder evenly among the threads
        iOutDelta = iOutSize / iNumThreads;
        iStartingRow = 0;
        for (i = 0; i < iNumThreads; i++) // divide up the job
        {
            iRowsToCompress = iRowsPerThread*dy; // scanlines for the each thread to process
            if (iRemainder)
            {
                iRowsToCompress += dy; // spread out the remainder as evenly as possible
                iRemainder--;
            }
            if ((iStartingRow + iRowsToCompress) > pPage->iHeight) // last piece might be beyond true end of image by up to dy-1 lines
                iRowsToCompress = pPage->iHeight - iStartingRow;
//            pJPEGSlices[i].pBitmap = &pPage->pData[pPage->iOffset + (iStartingRow*pPage->iPitch)]; // starting point in the image
//            pJPEGSlices[i].uiPitch = pPage->iPitch;
            pJPEGSlices[i].pJPEG = pJPEG;
            pJPEGSlices[i].pData = &pBuf[iOffset + (iOutDelta*i)]; // divide up the output buffer
            pJPEGSlices[i].uiWidth = pPage->iWidth;
            pJPEGSlices[i].uiHeight = iRowsToCompress;
//            pJPEGSlices[i].pPalette = pPage->pPalette;
            pJPEGSlices[i].uiResCount = iStartingRow / dy; // starting restart marker value
            pJPEGSlices[i].iDCPred0 = iQFactor;
            pJPEGSlices[i].iDCPred1 = pPage->cBitsperpixel;
            pJPEGSlices[i].iDCPred2 = i; // DEBUG - not needed
            pJPEGSlices[i].uiFlag = PIL_THREAD_BUSY; // indicates thread is still working
            iStartingRow += iRowsToCompress;
        }
    }
    else // single job
    {
        pJPEGSlices[0].pBitmap = &pPage->pData[pPage->iOffset];
//        pJPEGSlices[0].uiPitch = pPage->iPitch;
        pJPEGSlices[0].pJPEG = pJPEG;
        pJPEGSlices[0].pData = &pBuf[iOffset];
        pJPEGSlices[0].uiWidth = pPage->iWidth;
        pJPEGSlices[0].uiHeight = pPage->iHeight;
//        pJPEGSlices[0].pPalette = pPage->pPalette;
        pJPEGSlices[0].uiResCount = 0; // starting restart value
        pJPEGSlices[0].iDCPred0 = iQFactor;
        pJPEGSlices[0].iDCPred1 = pPage->cBitsperpixel;
        pJPEGSlices[0].uiFlag = PIL_THREAD_BUSY; // indicates thread is still working
    }
    for (i = 0; i < iNumThreads - 1; i++) // spawn off N threads to do the job
    {
        if (pPage->cBitsperpixel == 8)
        {
//            PILIOCreateThread((void*) MakeGrayJPEG, &pJPEGSlices[i], i + 1);
        }
        else
        {
//            PILIOCreateThread((void*) MakeColorJPEG, &pJPEGSlices[i], i + 1);
        }
    } // spread job across threads
    // Last thread is done on the current thread
    if (pPage->cBitsperpixel == 8)
        MakeGrayJPEG(&pJPEGSlices[iNumThreads - 1]);
    else
    {
        MakeColorJPEG(&pJPEGSlices[iNumThreads - 1]);
        pOutPage->cBitsperpixel = 24; // if left to be 16/17/32/etc, it can mess up writing it to TIFF/PDF files
    }
    // Wait for all threads to finish
    if (iNumThreads > 1)
    {
        int bFinished = FALSE;
        while (!bFinished)
        {
            bFinished = TRUE;
//            PILIOSleep(1); // yield to other threads while we wait
            for (i = 0; i < iNumThreads - 1; i++)
            {
                if (pJPEGSlices[i].uiFlag != PIL_THREAD_COMPLETE)
                    bFinished = FALSE;
            }
        }
        // Glue the output buffers together to make a single data stream
        iOutSize = iOffset + pJPEGSlices[0].uiLen; // start at the end of the first slice's output
        for (i = 1; i < iNumThreads; i++)
        {
            int j;
            for (j = 0; j < (int)pJPEGSlices[i].uiLen; j++) // move everything together to form a single buffer
                pBuf[iOutSize++] = pJPEGSlices[i].pData[j];
        }
    }
    else
    {
        iOutSize = iOffset + pJPEGSlices[0].uiLen; // single slice of data
    }
    
makejpegz:
    if (!(iQFactor & PIL_CONVERT_NOALLOC))
        PILIOFree(pJPEG);
    if (iErr == 0)
    {
        pBuf[iOutSize++] = 0xff;
        pBuf[iOutSize++] = 0xd9;  // end of image (EOI)
        pOutPage->iDataSize = iOutSize;
    }
    pOutPage->cState = PIL_PAGE_STATE_LOADED;
    pOutPage->iOffset = 0;
    // re-allocate the output buffer to be the size needed, nothing more
    if (iErr == 0)
    {
        pBuf = (unsigned char *) PILIOAlloc(pOutPage->iDataSize);
        if (pBuf != NULL)
        {
            memcpy(pBuf, pOutPage->pData, pOutPage->iDataSize);
            PILIOFree(pOutPage->pData);
            pOutPage->pData = pBuf;
        }
    }
    return iErr;
    
} /* PILMakeJPEG() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILInitMJPEG()                                             *
 *                                                                          *
 *  PURPOSE    : Initialize the Huffman tables for motion JPEG decomp.      *
 *                                                                          *
 ****************************************************************************/
void PILInitMJPEG(PIL_FILE *pFile, unsigned char *buf, int bMJPEG)
{
    JPEGDATA *pJPEG;
    int i, iOffset;
    signed short sLen;
    
    pJPEG = pFile->pJPEG;
    pJPEG->ucNumComponents = 3; // assume a color MJPEG // DEBUG
    
    /* Create a range clipping table for results of multiplications */
    for (i=0; i<128; i++)
    {
        pJPEG->cRangeTable[i] = (unsigned char)(0x80 + i);
        pJPEG->cRangeTable[i+896] = (unsigned char)i;
    }
    for (i=0; i<384; i++)
    {
        pJPEG->cRangeTable[i+128] = 0xff;
        pJPEG->cRangeTable[i+512] = 0;
    }
    
    // Read the huffman data from the standard MJPEG table
    if (bMJPEG)
    {
        iOffset = 0;
        while (MOTOSHORT(&buf[iOffset]) == 0xffc4) // process all Huffman tables
        {
            sLen = MOTOSHORT(&buf[iOffset+2]); // get the length of the whole story
            sLen -= 2; // subtract length length
            iOffset += 4; // skip market and length
            JPEGGetHuffTables(&buf[iOffset], sLen, pJPEG);
            iOffset += sLen;
        }
        // Initialize the huffman tables for quick decompression
        JPEGMakeHuffTables(pJPEG, FALSE);
    }
    
    JPEGInitTables(pJPEG); // initialize range clipping tables
    
} /* PILInitMJPEG() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILRotateMCU90()                                           *
 *                                                                          *
 *  PURPOSE    : Rotate and copy an MCU.                                    *
 *                                                                          *
 ****************************************************************************/
void PILRotateMCU90(signed short *pSrc, signed short *pDest)
{
    int i, j;
    
    for (i = 0; i < 8; i+=2)
    {
        for (j = 0; j < 8; j++)
        {
            pDest[cZigZag[j*8+i]] = pSrc[i*8+j];
            pDest[cZigZag[j*8+i+1]] = -pSrc[(i+1)*8+j];
        }
	   }
    
} /* PILRotateMCU90() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILRotateMCU270()                                          *
 *                                                                          *
 *  PURPOSE    : Rotate and copy an MCU.                                    *
 *                                                                          *
 ****************************************************************************/
void PILRotateMCU270(signed short *pSrc, signed short *pDest)
{
    int i, j;
    
    for (i = 0; i < 8; i++)
    {
        for (j = 0; j < 8; j+=2)
        {
            pDest[cZigZag[j*8+i]] = pSrc[i*8+j];
            pDest[cZigZag[(j+1)*8+i]] = -pSrc[i*8+j+1];
        }
	   }
    
} /* PILRotateMCU270() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILFixQTable(JPEGDATA *, int)                              *
 *                                                                          *
 *  PURPOSE    : Rotate the quantization tables 90 degrees.                 *
 *                                                                          *
 ****************************************************************************/
void PILFixQTable(JPEGDATA *pJPEGe, int iTable)
{
    int x, y, iTableOffset;
    short sQTTemp[64];
    
    iTableOffset = iTable*DCTSIZE2;
    for (x=0; x<8; x++)
    {
        for (y=0; y<8; y++)
        {
            sQTTemp[cZigZag[x*8+y]] = pJPEGe->sQuantTable[iTableOffset+cZigZag[y*8+x]];
        }
    }
    memcpy(&pJPEGe->sQuantTable[iTableOffset], sQTTemp, 64*sizeof(short)); // copy it back
    
} /* PILFixQTable() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILRotateJPEGData()                                        *
 *                                                                          *
 *  PURPOSE    : Special routine for losslessly rotating a JPEG image.      *
 *                                                                          *
 ****************************************************************************/
int PILRotateJPEGData(unsigned char *pBuf, unsigned char *pDest, int iAngle, int *iSize, unsigned char *pEXIF, int iEXIFLen)
{
    int i, j, k, x, iMarker, iError, iDCPred0e, iDCPred1e, iDCPred2e;
    int iOff, iBit, iStart;
    int iOutOff, iOutSize;
    int iMCUCount, iWidth, iHeight, iCX, iCY, iHeaderSize;
    //int iTotalSize;
    signed short *pMCU, *iMCUTemp;
    char cBitsperpixel;
    unsigned char c, *pTemp, *pHeader, *pOutBuf;
    JPEGDATA *pJPEG, *pJPEGe;
    unsigned short us;
    unsigned char cDCTable0, cACTable0, cDCTable1, cACTable1, cDCTable2, cACTable2;
    PIL_CODE pc;
    
    pJPEG = pJPEGe = NULL; // suppress compiler warnings
    pMCU = NULL;
    iError = iHeight = iWidth = iCX = iCY = iMCUCount = 0;
    cBitsperpixel = 0;
    iOutSize = 0;
    
    // Theory of operation....
    // Lossless JPEG rotation requires undoing the entropy coding and rearranging the order of the MCUs
    // This operation requires slightly more memory than a normal image decode, but the alternative is
    // not pretty.  To use less memory and make multiple passes over the image takes a tremendous amount
    // of time and would make the function impractical even on a fast PC.  For example, a 4 megapixel
    // file would take several minutes to rotate on a fast machine; no good.
    // The tricky part is dealing with the 4 different sub-sampling options we support
    
    // Get some info about the file
    pTemp = (unsigned char *) PILIOAlloc(0x10000);
    iMCUTemp = (short *)PILIOAlloc(6*DCTSIZE2*sizeof(short)); // enough room for max blocks per MCU
    pOutBuf = (unsigned char *) PILIOAlloc(0x10000);
    if (iMCUTemp == NULL || pTemp == NULL || pOutBuf == NULL)
    {
        iError = PIL_ERROR_MEMORY;
        goto pilrotjpgz;
    }
    pJPEG = PILPrepJPEGStruct(); /* jpeg decoding tables */
    pJPEGe = (JPEGDATA *)PILIOAlloc(sizeof(JPEGDATA)); /* jpeg encoding tables */
    if (pJPEG == NULL || pJPEGe == NULL)
    {
        iError = PIL_ERROR_MEMORY;
        goto pilrotjpgz;
    }
    i = 2; /* Start at offset of first marker */
    iMarker = 0; /* Search for SOF (start of frame) marker */
    while (i < PIL_BUFFER_SIZE && iMarker != 0xffda) // search until start of scan (SOS)
    {
        iMarker = MOTOSHORT(&pBuf[i]);
        i += 2;
        if (iMarker < 0xff00) // invalid marker, could be generated by "Arles Image Web Page Creator" or Accusoft
            continue; // skip 2 bytes and try to resync
        if ((iMarker & 0xfffc) == 0xffc0)
        {
            if (iMarker != 0xffc0)
            {
                iError = PIL_ERROR_BADHEADER;
                goto pilrotjpgz;
            }
            else
            {
                iHeight = MOTOSHORT(&pBuf[i+3]);
                iWidth = MOTOSHORT(&pBuf[i+5]);
                if (pBuf[i+7] == 1) /* number of components */
                    cBitsperpixel = 8; /* grayscale */
                else
                    if (pBuf[i+7] == 3)
                        cBitsperpixel = 24;
                    else // unsupported
                    {
                        iError = PIL_ERROR_UNSUPPORTED;
                        goto pilrotjpgz;
                    }
                break;
            }
        }
        i += MOTOSHORT(&pBuf[i]); /* Skip to next marker */
    }
    
    iOff = iBit = 0;  /* Pointer into data stream */
    us = MOTOSHORT(pBuf); /* Do we start with an SOI marker? */
    if (us != 0xffd8)
    {
        us = MOTOSHORT(&pBuf[1]); // Ricoh files have a strange extra byte here
        if (us == 0xffd8)
            iOff += 3;
    }
    else
        iOff += 2;
    if (us != 0xffd8) /* Error not a JPEG file */
    {
        iError = PIL_ERROR_BADHEADER;
        goto pilrotjpgz;
    }
    JPEGGetSOI(pJPEG); /* Process Start Of Image info */
    i = JPEGProcessTables(pBuf, &iOff, pJPEG, 0x10000, NULL);
    if (i != 0xc0) // we only handle baseline DCT
    {
        iError = PIL_ERROR_UNSUPPORTED;
        goto pilrotjpgz;
    }
    if (JPEGGetSOF(pBuf, &iOff, pJPEG)) // get start of frame marker
    {
        iError = PIL_ERROR_BADHEADER;
        goto pilrotjpgz;
    }
    if (JPEGProcessTables(pBuf, &iOff, pJPEG, 0x10000, NULL) != 0xda) // check for M_SOS
    {
        iError = PIL_ERROR_BADHEADER;
        goto pilrotjpgz;
    }
    JPEGGetSOS(pBuf, &iOff, pJPEG);
    // create huffman tables
    JPEGMakeHuffTables(pJPEG, FALSE);
    
    iStart = iOff; // start of image data
    
    // Fix the quantization table to be rotated in the same direction
    memcpy(pJPEGe->sQuantTable, pJPEG->sQuantTable, 2*DCTSIZE2*sizeof(short)); // get the quantization tables
    for (i=0; i<4; i++) // rotate up to 4 quantization tables
        PILFixQTable(pJPEGe, i);
    pHeader = (unsigned char *) PILIOAlloc(0x10000);
    iHeaderSize = 0;
    WRITEMOTO16(pHeader, iHeaderSize, 0xffd8); // JPEG ID
    iHeaderSize += 2;
    if (MOTOSHORT(&pBuf[2]) == 0xffe1) // preserve App1 marker (usually EXIF) if present
    {
        if (pEXIF) // if we are replacing the exif header with a rotated thumbnail
        {
            memcpy(&pHeader[iHeaderSize], pEXIF, iEXIFLen);
            iHeaderSize += iEXIFLen;
        }
        else // copy the original to our output header
        {
            i = MOTOSHORT(&pBuf[4]); // get the header length
            memcpy(&pHeader[iHeaderSize], &pBuf[2], i+2); // copy the EXIF header into our header buffer
            iHeaderSize += i + 2;
        }
    }
    // Create the header info for the new file with the x and y swapped
    WRITEMOTO16(pHeader, iHeaderSize, 0xffe0); // write app0 marker
    iHeaderSize += 2;
    WRITEMOTO32(pHeader, iHeaderSize, 0x00104a46); // JFIF
    iHeaderSize += 4;
    WRITEMOTO32(pHeader, iHeaderSize, 0x49460001);
    iHeaderSize += 4;
    
    WRITEMOTO16(pHeader, iHeaderSize, 0x0101); // resolution units = dots per inche
    iHeaderSize += 2;
    WRITEMOTO16(pHeader, iHeaderSize, 1); // store spacial resolution of 1
    iHeaderSize += 2;
    WRITEMOTO16(pHeader, iHeaderSize, 1);
    iHeaderSize += 4; // skip 2 zeros
    // define quantization tables
    WRITEMOTO16(pHeader, iHeaderSize, 0xffdb); // quantization table marker
    iHeaderSize += 2;
    WRITEMOTO16(pHeader, iHeaderSize, 0x0043); // table size
    iHeaderSize += 2;
    pHeader[iHeaderSize++] = 0; // table type and number 0,8 bit
    for (i=0; i<64; i++)
        pHeader[iHeaderSize++] = (unsigned char)pJPEGe->sQuantTable[i];
    
    if (cBitsperpixel > 8) // add color quant tables
    {
        WRITEMOTO16(pHeader, iHeaderSize, 0xffdb); // huff table
        iHeaderSize += 2;
        WRITEMOTO16(pHeader, iHeaderSize, 0x0043); // table size
        iHeaderSize += 2;
        pHeader[iHeaderSize++] = 1;  // table 1, 8 bit
        for (i=0; i<64; i++)
            pHeader[iHeaderSize++] = (unsigned char)pJPEGe->sQuantTable[64+i];
    }
    
    // store the frame header
    WRITEMOTO16(pHeader, iHeaderSize, 0xffc0); // SOF0 marker
    iHeaderSize += 2;
    if (cBitsperpixel == 8)
    {
        pHeader[iHeaderSize++] = 0;
        pHeader[iHeaderSize++] = 11; // length = 11
        pHeader[iHeaderSize++] = 8;   // sample precision
        WRITEMOTO16(pHeader, iHeaderSize, iWidth); // image height (swapped)
        iHeaderSize += 2;
        WRITEMOTO16(pHeader, iHeaderSize, iHeight); // image width (swapped)
        iHeaderSize += 2;
        pHeader[iHeaderSize++] = 1; // number of components = 1 (grayscale)
        pHeader[iHeaderSize++] = 0; // component number
        WRITEMOTO16(pHeader, iHeaderSize, 0x1100); // subsampling and quant table selector
        iHeaderSize += 2;
    }
    else  // set up color stuff
    {
        pHeader[iHeaderSize++] = 0;
        pHeader[iHeaderSize++] = 17; // length = 17
        pHeader[iHeaderSize++] = 8;   // sample precision
        WRITEMOTO16(pHeader, iHeaderSize, iWidth); // image height (swapped)
        iHeaderSize += 2;
        WRITEMOTO16(pHeader, iHeaderSize, iHeight); // image width (swapped)
        iHeaderSize += 2;
        pHeader[iHeaderSize++] = 3; // number of components = 3 (Ycc)
        pHeader[iHeaderSize++] = 0; // component number 0 (Y)
        if (pJPEG->jpegsample == 0x12 || pJPEG->jpegsample == 0x21) // need to change the subsampling direction
            pHeader[iHeaderSize++] = 0x33 - pJPEG->jpegsample;
        else
            pHeader[iHeaderSize++] = pJPEG->jpegsample;
        pHeader[iHeaderSize++] = 0; // quant table selector for (Y)
        pHeader[iHeaderSize++] = 1; // component number 1 (Cb)
        WRITEMOTO16(pHeader, iHeaderSize, 0x1101); // subsampling and quant table selector
        iHeaderSize += 2;
        pHeader[iHeaderSize++] = 2; // component number 2 (Cr)
        WRITEMOTO16(pHeader, iHeaderSize, 0x1101); // subsampling and quant table selector
        iHeaderSize += 2;
    }
    // Write our own Huffman tables since the originals can be incomplete
    WRITEMOTO16(pHeader, iHeaderSize, 0xffc4); // Huffman DC table
    iHeaderSize += 2;
    WRITEMOTO16(pHeader, iHeaderSize, 0x1f); // Table length = 31
    iHeaderSize += 2;
    pHeader[iHeaderSize++] = 0; // table class = 0 (DC), id = 0
    for (i=0; i<28; i++) // copy DC table
    {
        pHeader[iHeaderSize++] = huffl_dc[i];
    }
    // now the AC table
    WRITEMOTO16(pHeader, iHeaderSize, 0xffc4); // Huffman AC table
    iHeaderSize += 2;
    WRITEMOTO16(pHeader, iHeaderSize, 0xb5); // Table length = 181
    iHeaderSize += 2;
    pHeader[iHeaderSize++] = 0x10; // table class = 1 (AC), id = 0
    for (i=0; i<178; i++) // copy AC table
    {
        pHeader[iHeaderSize++] = huffl_ac[i];
    }
    if (cBitsperpixel > 8) // define a second set of tables for color
    {
        WRITEMOTO16(pHeader, iHeaderSize, 0xffc4); // Huffman DC table
        iHeaderSize += 2;
        WRITEMOTO16(pHeader, iHeaderSize, 0x1f); // Table length = 31
        iHeaderSize += 2;
        pHeader[iHeaderSize++] = 1; // table class = 0 (DC), id = 1
        for (i=0; i<28; i++) // copy DC table
        {
            pHeader[iHeaderSize++] = huffcr_dc[i];
        }
        // now the AC table
        WRITEMOTO16(pHeader, iHeaderSize, 0xffc4); // Huffman AC table
        iHeaderSize += 2;
        WRITEMOTO16(pHeader, iHeaderSize, 0xb5); // Table length = 181
        iHeaderSize += 2;
        pHeader[iHeaderSize++] = 0x11; // table class = 1 (AC), id = 1
        for (i=0; i<178; i++) // copy AC table
        {
            pHeader[iHeaderSize++] = huffcr_ac[i];
        }
    }
    // Define the start of scan header (SOS)
    WRITEMOTO16(pHeader, iHeaderSize, 0xffda); // SOS
    iHeaderSize += 2;
    if (cBitsperpixel == 8)
    {
        WRITEMOTO16(pHeader, iHeaderSize, 0x8); // Table length = 8
        iHeaderSize += 2;
        pHeader[iHeaderSize++] = 1;            // number of components in scan = 1 (grayscale)
        pHeader[iHeaderSize++] = 0; // component id = 0
        pHeader[iHeaderSize++] = 0; // dc/ac huffman table = 0/0
    }
    else // color
    {
        WRITEMOTO16(pHeader, iHeaderSize, 0xc); // Table length = 12
        iHeaderSize += 2;
        pHeader[iHeaderSize++] = 3;            // number of components in scan = 3 (color)
        pHeader[iHeaderSize++] = 0; // component id = 0
        pHeader[iHeaderSize++] = 0; // dc/ac huffman table = 0/0
        pHeader[iHeaderSize++] = 1; // component id = 1
        pHeader[iHeaderSize++] = 0x11; // dc/ac huffman table = 1/1
        pHeader[iHeaderSize++] = 2; // component id = 2
        pHeader[iHeaderSize++] = 0x11; // dc/ac huffman table = 1/1
    }
    pHeader[iHeaderSize++] = 0; // start of spectral selection
    pHeader[iHeaderSize++] = 63; // end of spectral selection
    pHeader[iHeaderSize++] = 0; // successive approximation bit
    
    pJPEGe->ucNumComponents = pJPEG->ucNumComponents;
    memcpy(pJPEGe->ucHuffVals, pJPEG->ucHuffVals, (8 * HUFF_TABLEN)); // use the same Huffman tables to encode
    JPEGMakeHuffE(pJPEGe); // create the Huffman tables to encode
    pJPEGe->pHuffDC = pJPEGe->huffdc[0];
    
    iDCPred0e = 0;
    //   iOutOff = iOutBit = 0; // output data pointers
    
    if (cBitsperpixel == 8) // grayscale image (simpler)
    {
        pJPEG->pHuffAC = pJPEG->huffac[0];
        pJPEG->pHuffDC = pJPEG->huffdc[0]; // use the first huff table
        pJPEG->pHuffACFast = pJPEG->huffacFast[0];
        pJPEG->pHuffDCFast = pJPEG->huffdcFast[0];
        
        iCY = (iHeight+7) / 8; // number of MCUs per col - this will be the new width
        iCX = (iWidth+7)/8;
        pMCU = (short *)PILIOAlloc(iCY*iCX*DCTSIZE2*sizeof(short)); // allocate enough MCUs for a complete line
        if (pMCU == NULL)
        {
            PILIOFree(pHeader);
            iError = PIL_ERROR_MEMORY;
            goto pilrotjpgz;
        }
        iOff = iStart; // point to start of image data
        //      iFileOffset = 0; // start of file
        iBit = 0;
        //      iDCPred0 = 0; // reset the DC predictor value for each pass through the image
        pJPEG->iResCount = pJPEG->iResInterval; // restart interval
        pJPEG->ulBits = JPEGGet32Bits(pBuf, &iOff); // start with 32-bits of huffman data
        // Fully decode the image, then recode in the new orientation
        for (j=0; j<iCY && !iError; j++)
        {
            for (k=0; k<iCX && !iError; k++)
            {
                //            if (iOff > 0xf000) // high water mark
                //               {
                //               iFileOffset += iOff;
                //               PILIOSeek(iHandle, (PILOffset) iFileOffset, 0); // read more data
                //               PILIORead(iHandle, pBuf, 0x10000);
                //               iOff = 0;
                //               }
                //            iError = JPEGDecodeMCU(pBuf, &iOff, &iBit, iMCUTemp, pJPEG, &iDCPred0);
                if (iAngle == 90)
                {
                    if (pJPEG->ucMaxACCol == 0) // no AC components, save some time
                    {
                        pMCU[(j*iCX+k)*DCTSIZE2] = iMCUTemp[0];
                        memset(&pMCU[((j*iCX+k)*DCTSIZE2)+1],0,63*sizeof(short));
                    }
                    else
                    {
                        PILRotateMCU90(iMCUTemp, &pMCU[(j*iCX+k)*DCTSIZE2]); // rotate and copy the MCU
                    }
                }
                else // rotate 270
                {
                    if (pJPEG->ucMaxACCol == 0) // no AC components, save some time
                    {
                        pMCU[((iCY-1-j)*iCX+(iCX-1-k))*DCTSIZE2] = iMCUTemp[0];
                        memset(&pMCU[(((iCY-1-j)*iCX+(iCX-1-k))*DCTSIZE2)+1],0,63*sizeof(short));
                    }
                    else
                    {
                        PILRotateMCU270(iMCUTemp, &pMCU[((iCY-1-j)*iCX+(iCX-1-k))*DCTSIZE2]); // rotate and copy the MCU
                    }
                }
                if (pJPEG->iResInterval)
                {
                    if (--pJPEG->iResCount == 0)
                    {
                        pJPEG->iResCount = pJPEG->iResInterval;
                        //                  iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                        if (iBit & 7)
                        {
                            iBit += (8 - (iBit & 7));
                        }
                    }
                }
            } // for each block
        } // for each row
        //      PILIOClose(iHandle);
        if (iError)
            goto pilrotjpgz; // don't continue if there was an error
        // Create the output file
        //      oHandle = PILIOCreate(szDest);
        //      if (oHandle == -1)
        //         {
        //         iError = PIL_ERROR_IO;
        //         goto pilrotjpgz; // don't continue if there was an error
        //         }
        //      PILIOWrite(oHandle, pHeader, iHeaderSize); // write the header info
        memcpy(pDest, pHeader, iHeaderSize);
        iOutSize += iHeaderSize;
        PILIOFree(pHeader);
        
        pc.iLen = 0;
        pc.pOut = pOutBuf;
        pc.ulAcc = 0;
        
        // We've decoded the full image, now write it to the new file in the rotated direction
        for (j=0; j<iCX; j++)
        {
            for (k=0; k<iCY; k++)
            {
                iDCPred0e = JPEGEncodeMCU(0, pJPEGe, &pMCU[((iCY-1-k)*iCX+j)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                iOutOff = (int)(pc.pOut - pOutBuf);
                if (iOutOff > 0xe000) // high water mark
                {
                    //               p = pTemp;
                    for (i=0; i<iOutOff; i++)
                    {
                        c = pDest[iOutSize++] = pOutBuf[i];
                        if (c == 0xff)  // insert a zero as needed
                            pDest[iOutSize++] = 0;
                    }
                    memset(pOutBuf, 0, iOutOff); // reset to zeros since it gets ORd
                    pOutBuf[0] = pOutBuf[iOutOff]; // copy down last partial byte
                    pOutBuf[iOutOff] = 0; // that byte also
                    pc.pOut = pOutBuf;
                }
            } // for each MCU in the line
        } // for each row
        PILFlushCode(&pc, TRUE);
        iOutOff = (int)(pc.pOut - pOutBuf);
        if (iOutOff)
        {
            for (j=0; j<=iOutOff; j++)
            {
                c = pDest[iOutSize++] = pOutBuf[j];
                if (c == 0xff)  // insert a zero as needed
                    pDest[iOutSize++] = 0;
            }
        }
        pDest[iOutSize++] = 0xff;
        pDest[iOutSize++] = 0xd9;  // end of image (EOI)
    }
    else // color
    {
        switch (pJPEG->jpegsample)
        {
            case 0x22: // subsampled in both directions
                iMCUCount = 6; // number of blocks per MCU
                iCY = (iHeight+15)/16; // number of MCUs per col - this will be the new width
                iCX = (iWidth+15)/16;
                break;
            case 0x11: // no subsampling
                iMCUCount = 3;
                iCY = (iHeight+7)/8; // number of MCUs per col - this will be the new width
                iCX = (iWidth+7)/8;
                break;
            case 0x12: // 2:1 vertical
                iMCUCount = 4;
                iCY = (iHeight+15)/16; // number of MCUs per col - this will be the new width
                iCX = (iWidth+7)/8;
                break;
            case 0x21: // 2:1 horizontal
                iMCUCount = 4;
                iCY = (iHeight+7)/8; // number of MCUs per col - this will be the new width
                iCX = (iWidth+15)/16;
                break;
        }
        pMCU = (short *)PILIOAlloc(iCY*iCX*iMCUCount*DCTSIZE2*sizeof(short)); // allocate enough MCUs for a complete line
        if (pMCU == NULL)
        {
            iError = PIL_ERROR_MEMORY;
            goto pilrotjpgz;
        }
        cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
        cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
        cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
        cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
        cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
        cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
        iDCPred0e = iDCPred1e = iDCPred2e = 0;
        iOff = iStart; // point to start of image data
        //      iFileOffset = 0; // start of file
        //      PILIOSeek(iHandle, (PILOffset) iFileOffset, 0);
        //      PILIORead(iHandle, pBuf, 0x10000); // read 64k to start
        iBit = 0;
        //      iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset the DC predictor value for each pass through the image
        pJPEG->iResCount = pJPEG->iResInterval; // restart interval
        pJPEG->ulBits = JPEGGet32Bits(pBuf, &iOff); // start with 32-bits of huffman data
        // Fully decode the image in the normal orientation, then write it back rotated
        for (j=0; j<iCY && !iError; j++)
        {
            for (k=0; k<iCX && !iError; k++)
            {
                //            if (iOff > 0xf000) // high water mark
                //               {
                //               iFileOffset += iOff;
                //               PILIOSeek(iHandle, (PILOffset) iFileOffset, 0); // read more data
                //               PILIORead(iHandle, pBuf, 0x10000);
                //               iOff = 0;
                //               }
                switch (pJPEG->jpegsample)
                {
                    case 0x11: // no subsampling
                        // decode luma
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable0];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable0]; // use the first huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
                        //                  iError = JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU0], pJPEG, &iDCPred0);
                        // first chroma
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable1];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable1]; // use the second huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                        //                  iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU1], pJPEG, &iDCPred1);
                        // second chroma
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable2];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable2]; // use the second huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                        //                  iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU2], pJPEG, &iDCPred2);
                        break;
                    case 0x21: // horizontal subsampling
                    case 0x12: // vertical subsampling
                        // decode lumas
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable0];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable0]; // use the first huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
                        if (iAngle == 90)
                        {
                            //                     iError = JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU0], pJPEG, &iDCPred0);
                            //                     iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU1], pJPEG, &iDCPred0);
                        }
                        else // need to swap the order of the lumas for 270 degree rotate
                        {
                            //                     iError = JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU1], pJPEG, &iDCPred0);
                            //                     iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU0], pJPEG, &iDCPred0);
                        }
                        // first chroma
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable1];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable1]; // use the second huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                        //                  iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU2], pJPEG, &iDCPred1);
                        // second chroma
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable2];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable2]; // use the second huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                        //                  iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU3], pJPEG, &iDCPred2);
                        break;
                    case 0x22:
                        // decode lumas
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable0];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable0]; // use the first huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
                        if (iAngle == 90)
                        {
                            //                     iError = JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU0], pJPEG, &iDCPred0);
                            //                     iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU1], pJPEG, &iDCPred0);
                            //                     iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU2], pJPEG, &iDCPred0);
                            //                     iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU3], pJPEG, &iDCPred0);
                        }
                        else // need to swap the order of the lumas for rotate 270
                        {
                            //                     iError = JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU3], pJPEG, &iDCPred0);
                            //                     iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU2], pJPEG, &iDCPred0);
                            //                     iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU1], pJPEG, &iDCPred0);
                            //                     iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU0], pJPEG, &iDCPred0);
                        }
                        // first chroma
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable1];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable1]; // use the second huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                        //                  iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU4], pJPEG, &iDCPred1);
                        // second chroma
                        pJPEG->pHuffAC = pJPEG->huffac[cACTable2];
                        pJPEG->pHuffDC = pJPEG->huffdc[cDCTable2]; // use the second huff table
                        pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                        pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                        //                  iError |= JPEGDecodeMCU(pBuf, &iOff, &iBit, &iMCUTemp[MCU5], pJPEG, &iDCPred2);
                        break;
                } // switch on subsampling
                // Rotate each block of the MCU into the destination image
                for (x=0; x<iMCUCount; x++)
                {
                    if (iAngle == 90)
                        PILRotateMCU90(&iMCUTemp[x*DCTSIZE2], &pMCU[((j*iCX+k)*iMCUCount+x)*DCTSIZE2]); // rotate and copy the MCU
                    else
                        PILRotateMCU270(&iMCUTemp[x*DCTSIZE2], &pMCU[(((iCY-1-j)*iCX+(iCX-1-k))*iMCUCount+x)*DCTSIZE2]); // rotate and copy the MCU
                }
                
                if (pJPEG->iResInterval)
                {
                    if (--pJPEG->iResCount == 0)
                    {
                        pJPEG->iResCount = pJPEG->iResInterval;
                        //                  iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                        if (iBit & 7)
                        {
                            iBit += (8 - (iBit & 7));
                        }
                    }
                }
            } // for each block
        } // for each row
        //      PILIOClose(iHandle);
        if (iError)
        {
            goto pilrotjpgz; // if error, leave here
        }
        // Create the output file
        //      oHandle = PILIOCreate(szDest);
        //      if (oHandle == -1)
        //         {
        //         iError = PIL_ERROR_IO;
        //         goto pilrotjpgz; // don't continue if there was an error
        //         }
        //      PILIOWrite(oHandle, pHeader, iHeaderSize); // write the header info
        memcpy(pDest, pHeader, iHeaderSize);
        iOutSize = iHeaderSize;
        PILIOFree(pHeader);
        // We've decoded the full image, now write it to the new file rotated
        // for encoding, we use only table 0 and 1
        cDCTable0 = 0;
        cACTable0 = 0;
        cDCTable1 = 1;
        cACTable1 = 1;
        cDCTable2 = 1;
        cACTable2 = 1;
        //      iTotalSize = 0; // output data size
        pc.iLen = 0;
        pc.pOut = pOutBuf;
        pc.ulAcc = 0;
        
        for (j=0; j<iCX; j++)
        {
            for (k=0; k<iCY; k++)
            {
                i = ((iCY-1-k)*iCX+j); // rotated index into MCU array
                switch (pJPEG->jpegsample)
                {
                    case 0x12:
                        // luma components
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable0];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable0];
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[((i*iMCUCount) + 1)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[((i*iMCUCount) + 0)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        // first chroma
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable1];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable1];
                        iDCPred1e = JPEGEncodeMCU(cDCTable1, pJPEGe, &pMCU[((i*iMCUCount) + 2)*DCTSIZE2], &pc, iDCPred1e, FALSE);
                        // second chroma
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable2];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable2];
                        iDCPred2e = JPEGEncodeMCU(cDCTable2, pJPEGe, &pMCU[((i*iMCUCount) + 3)*DCTSIZE2], &pc, iDCPred2e, FALSE);
                        break;
                        
                    case 0x21:
                        // luma components
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable0];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable0];
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[((i*iMCUCount) + 0)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[((i*iMCUCount) + 1)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        // first chroma
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable1];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable1];
                        iDCPred1e = JPEGEncodeMCU(cDCTable1, pJPEGe, &pMCU[((i*iMCUCount) + 2)*DCTSIZE2], &pc, iDCPred1e, FALSE);
                        // second chroma
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable2];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable2];
                        iDCPred2e = JPEGEncodeMCU(cDCTable2, pJPEGe, &pMCU[((i*iMCUCount) + 3)*DCTSIZE2], &pc, iDCPred2e, FALSE);
                        break;
                        
                    case 0x11:
                        // luma component
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable0];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable0];
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[(i*iMCUCount)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        // first chroma
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable1];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable1];
                        iDCPred1e = JPEGEncodeMCU(cDCTable1, pJPEGe, &pMCU[((i*iMCUCount) + 1)*DCTSIZE2], &pc, iDCPred1e, FALSE);
                        // second chroma
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable2];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable2];
                        iDCPred2e = JPEGEncodeMCU(cDCTable2, pJPEGe, &pMCU[((i*iMCUCount) + 2)*DCTSIZE2], &pc, iDCPred2e, FALSE);
                        break;
                        
                    case 0x22:
                        // luma components
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable0];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable0];
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[((i*iMCUCount) + 2)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[((i*iMCUCount) + 0)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[((i*iMCUCount) + 3)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        iDCPred0e = JPEGEncodeMCU(cDCTable0, pJPEGe, &pMCU[((i*iMCUCount) + 1)*DCTSIZE2], &pc, iDCPred0e, FALSE);
                        // first chroma
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable1];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable1];
                        iDCPred1e = JPEGEncodeMCU(cDCTable1, pJPEGe, &pMCU[((i*iMCUCount) + 4)*DCTSIZE2], &pc, iDCPred1e, FALSE);
                        // second chroma
                        //                  pJPEGe->pHuffDC = pJPEGe->huffdc[cDCTable2];
                        pJPEGe->pHuffAC = pJPEGe->huffac[cACTable2];
                        iDCPred2e = JPEGEncodeMCU(cDCTable2, pJPEGe, &pMCU[((i*iMCUCount) + 5)*DCTSIZE2], &pc, iDCPred2e, FALSE);
                        break;
                } // switch on subsampling
                iOutOff = (int)(pc.pOut - pOutBuf);
                if (iOutOff > 0xe000) // high water mark
                {
                    //               p = pTemp;
                    for (i=0; i<iOutOff; i++)
                    {
                        c = pDest[iOutSize++] = pOutBuf[i];
                        if (c == 0xff)  // insert a zero as needed
                            pDest[iOutSize++] = 0;
                    }
                    //               PILIOWrite(oHandle, pTemp, (int)(p-pTemp));
                    //               iTotalSize += (int)(p-pTemp);
                    memset(pOutBuf, 0, iOutOff); // reset to zeros since it gets ORd
                    pOutBuf[0] = pOutBuf[iOutOff]; // copy down last partial byte
                    pOutBuf[iOutOff] = 0; // that byte also
                    pc.pOut = pOutBuf;
                }
            } // for each MCU in the line
        } // for each row
        PILFlushCode(&pc, TRUE);
        iOutOff = (int)(pc.pOut - pOutBuf);
        if (iOutOff)
        {
            //         p = pTemp;
            for (j=0; j<=iOutOff; j++)
            {
                c = pDest[iOutSize++] = pOutBuf[j];
                if (c == 0xff)  // insert a zero as needed
                    pDest[iOutSize++] = 0;
            }
            //         PILIOWrite(oHandle, pTemp, (int)(p-pTemp));
        }
        pDest[iOutSize++] = 0xff;
        pDest[iOutSize++] = 0xd9;  // end of image (EOI)
        //      PILIOWrite(oHandle, pOutBuf, 2);
        //      PILIOClose(oHandle);
    }
pilrotjpgz:
    //   PILIOFree(pBuf);
    PILIOFree(pTemp);
    PILIOFree(pOutBuf);
    PILFreeHuffTables(pJPEG);
    PILFreeHuffTables(pJPEGe);
    PILIOFree(pJPEG);
    PILIOFree(pJPEGe);
    PILIOFree(pMCU);
    PILIOFree(iMCUTemp);
    *iSize = iOutSize; // number of bytes generated
    return iError;
} /* PILRotateJPEGData() */
#endif // JPEG_DECODE_ONLY

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILJPEGEXIF(unsigned char *)                               *
 *                                                                          *
 *  PURPOSE    : Find the EXIF header if present.  Return its offset.       *
 *                                                                          *
 ****************************************************************************/
int PILJPEGEXIF(unsigned char *pFile)
{
    int iOff = 2; // point to first marker
    int iMarker, iLen;
    
    iMarker = 0;
    while (iMarker != 0xffda) // search until SOS (start of scan)
    {
        iMarker = MOTOSHORT(&pFile[iOff]);
        if (iMarker < 0xff00) // invalid marker, could be generated by "Arles Image Web Page Creator" or Accusoft
        {
            iOff += 2;
            continue; // skip 2 bytes and try to resync
        }
        iLen = MOTOSHORT(&pFile[iOff+2]);
        if (iMarker == 0xffe1 && pFile[iOff+4] == 'E') // APP1 is the EXIF
        {
            return iOff; // found it
        }
        iOff += (iLen + 2);
    }
    return 0; // not found
    
} /* PILJPEGEXIF() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILRotateJPEG()                                            *
 *                                                                          *
 *  PURPOSE    : Special routine for losslessly rotating a JPEG image.      *
 *                                                                          *
 ****************************************************************************/
int PILRotateJPEG(TCHAR *szSource, TCHAR *szDest, int iAngle)
{
    iAngle |= 0; // suppress compiler warnings
    szDest[0] = szSource[0]; // ditto
    
#ifdef BOGUS // disabled until fixed
#ifndef _WIN32
    // Not implemented under non-Win32 environments
    PILASSERT(0);
    return(0);
#else
    unsigned char *pInData, *pOutData, *pThumb, *pEXIF;
    int i, iLen, iSize, iOff, rc, oHandle, iDestSize, iDelta, iEXIFSize, iThumbSize;
    HANDLE hInFile, hInMapping;
    TCHAR szTemp[256];
    
    if (iAngle != 90 && iAngle != 270)
        return PIL_ERROR_INVPARAM;
    
    if (szSource[0] > 0xff) // someone passed an ASCII string instead of UNICODE
    {
        mbstowcs((wchar_t *)szTemp, (char *)szSource, strlen((char *)szSource)+1);
        oHandle = PILIOOpenRO(szTemp);
    }
    else
        oHandle = PILIOOpenRO(szSource);
    if (oHandle == -1) // unable to open
        return PIL_ERROR_FILENF;
    iDestSize = PILIOSize(oHandle); // get the size of the source file
    PILIOClose(oHandle);
    
    // Prepare the input file
#ifdef _WIN32_WCE
    hInFile = CreateFileForMapping(szSource, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#else
    hInFile = CreateFile(szSource, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#endif
    hInMapping = CreateFileMapping(hInFile, NULL, PAGE_READONLY, 0, 0, NULL);
    pInData = (unsigned char *)MapViewOfFile(hInMapping, FILE_MAP_READ, 0, 0, 0);
    pOutData = PILIOAlloc(iDestSize + 1000000); // allow room for the data to expand a little
    
    // See if this file has an embedded thumbnail image; if so, rotate it also
    iOff = PILJPEGEXIF(pInData);
    if (iOff)
    {
        iLen = MOTOSHORT(&pInData[iOff+2]); // get the length of the whole EXIF header
        for (i=iOff; i<(iOff+iLen); i+= 2) // search for start of JPEG file
        {
            if (MOTOSHORT(&pInData[i]) == 0xffd8) // start of JFIF
                break;
        }
        if (MOTOSHORT(&pInData[i]) != 0xffd8) // we didn't find a JPEG, rotate main image only
            goto no_thumb;
        iThumbSize = MOTOSHORT(&pInData[iOff+2]) - (i-iOff); // jpeg data size
        pThumb = PILIOAlloc((iThumbSize * 3)/2); // allow for data expansion
        // Rotate the thumbnail image
        rc = PILRotateJPEGData(&pInData[i], pThumb, iAngle, &iSize, NULL, 0);
        iDelta = iSize - iThumbSize; // change in size of rotated JPEG data
        iEXIFSize = iLen + iDelta; // new size
        pEXIF = PILIOAlloc(iEXIFSize); // enough space for EXIF header + new image
        memcpy(pEXIF, &pInData[iOff], i-iOff); // copy rest of EXIF header
        memcpy(&pEXIF[i], pThumb, iSize); // copy rotated image back into EXIF header
        pEXIF[2] = (char)(iEXIFSize >> 8); // store high byte of new length
        pEXIF[3] = (char)iEXIFSize; // store low byte of new length
        PILIOFree(pThumb); // don't need this image any more
        // Rotate the main image and replace the thumbnail with the rotated one
        rc = PILRotateJPEGData(pInData, pOutData, iAngle, &iSize, pEXIF, iEXIFSize);
        PILIOFree(pEXIF);
    }
    else // no thumbnail, just rotate the image
    {
    no_thumb:
        rc = PILRotateJPEGData(pInData, pOutData, iAngle, &iSize, NULL, 0);
    }
    
    // Close the input file
    UnmapViewOfFile(pInData);
    CloseHandle(hInMapping);
    CloseHandle(hInFile);
    
    if (rc == 0) // if all went well, create the ouput file
    {
        if (szDest[0] > 0xff) // ASCII was passed instead of UNICODE
        {
            mbstowcs((wchar_t *)szTemp, (char *)szDest, strlen((char *)szDest)+1);
            oHandle = PILIOCreate(szTemp);
        }
        else
            oHandle = PILIOCreate(szDest);
        PILIOWrite(oHandle, pOutData, iSize);
        PILIOClose(oHandle);
    }
    PILIOFree(pOutData);
    return rc;
#endif	// #ifndef _WIN32
#endif // BOGUS
    return 0;
} /* PILRotateJPEG() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILScanJPEG(...)                                           *
 *                                                                          *
 *  PURPOSE    : Scan a JPEG image for MCU offsets.                         *
 *                                                                          *
 ****************************************************************************/
int PILScanJPEG(JPEG_SCAN **pScanList, BUFFERED_BITS *bb, JPEGDATA *pJPEG)
{
    int cx, cy, x, y;
    int iScanOffset;
    int iErr = 0;
    //uint32_t Cb,Cr;
    //signed int Y1,Y2,Y3,Y4;
    int iBit;
    JPEG_SCAN *pLocalList;
    signed int iDCPred0, iDCPred1, iDCPred2;
    unsigned char cACTable0, cDCTable0, cACTable1, cDCTable1, cACTable2, cDCTable2;
    
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    
    iDCPred0 = iDCPred1 = iDCPred2 = 0;
    iBit = 0;
    *pScanList = NULL;
    // set up the parameters for the different subsampling options
    if (pJPEG->jpegsample == 0 || pJPEG->jpegsample == 0x11 || pJPEG->jpegsample == 0x12)
        cx = (pJPEG->cx + 7) >> 3;
    else
        cx = (pJPEG->cx + 15) >> 4;
    if (pJPEG->jpegsample == 0 || pJPEG->jpegsample == 0x11 || pJPEG->jpegsample == 0x21)
        cy = (pJPEG->cy + 7) >> 3;
    else
        cy = (pJPEG->cy + 15) >> 4;
    //    Y1 = Y2 = Y3 = Y4 = 0; // suppress compiler warning
    pLocalList = (JPEG_SCAN *)PILIOAlloc(sizeof(JPEG_SCAN)*cx*cy); // allocate our scan list
    if (pLocalList == NULL)
    {
        iErr = PIL_ERROR_MEMORY;
        goto Cleanup;
    }
    iScanOffset = 0;
    for (y=0; y<cy; y++)
    {
        for (x=0; x<cx; x++)
        {
            // load up the info for the current MCU
            // DEBUG
            //		  pLocalList[iScanOffset].ulOffset = (uint32_t)iOffset;
            pLocalList[iScanOffset].ulBitOff = iBit;
            pLocalList[iScanOffset].ulBits = pJPEG->ulBits;
            pLocalList[iScanOffset].iYDC = iDCPred0;
            pLocalList[iScanOffset].iCbDC = iDCPred1;
            pLocalList[iScanOffset].iCrDC = iDCPred2;
            
            pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
            pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
            // do the luminance components
            iErr = JPEGDecodeMCUFast(bb, pJPEG, &iDCPred0);
            //          Y1 = iDCPred0;
            if (pJPEG->jpegsample > 0x11) // color subsampled image
            {
                iErr |= JPEGDecodeMCUFast(bb, pJPEG, &iDCPred0);
                //             Y2 = iDCPred0;
                if (pJPEG->jpegsample == 0x22) // 2:2 has 4 Lums
                {
                    iErr |= JPEGDecodeMCUFast(bb, pJPEG, &iDCPred0);
                    //                Y3 = iDCPred0;
                    iErr |= JPEGDecodeMCUFast(bb, pJPEG, &iDCPred0);
                    //                Y4 = iDCPred0;
                }
            }
            if (pJPEG->jpegsample > 0) // if color image
            {
                // first chroma
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                iErr |= JPEGDecodeMCUFast(bb, pJPEG, &iDCPred1);
                // second chroma
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                iErr |= JPEGDecodeMCUFast(bb, pJPEG, &iDCPred2);
            }
            if (iErr)
                goto Cleanup;  // decoding error, stop
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                    if (iBit & 7)
                    {
                        iBit += (8 - (iBit & 7));
                    }
                }
            }
        } // for x
    } // for y
    
Cleanup:
    if (iErr)
    {
        if (pLocalList) // decoding error, free the scan list
        {
            PILIOFree(pLocalList);
        }
    }
    else
    {
        *pScanList = pLocalList; // success, return the list
    }
    return iErr;
} /* PILScanJPEG() */

// Prepares a quantization table based on the given quality level (1-99)
int PILPrepQuantTable(int iSrcTable, unsigned short *pDest, int iQ)
{
    int i;
    int iScaleFactor;
    unsigned char *pSrc;
    
    if (iQ < 1 || iQ > 99) // problem
        return PIL_ERROR_INVPARAM;
    if (iSrcTable < 0 || iSrcTable > 1 || NULL == pDest)
        return PIL_ERROR_INVPARAM;
    
    if (iSrcTable == 0)
        pSrc = (unsigned char *)quant_lum;
    else
        pSrc = (unsigned char *)quant_color;
    
    if (iQ < 50)
    {
        iScaleFactor = 5000 / iQ;
    }
    else
    {
        iScaleFactor = 200 - (iQ * 2);
    }
    for (i = 0; i < 64; i++)
    {
        pDest[i] = (unsigned short)(((pSrc[i] * iScaleFactor) + 50) / 100);
    }
    return 0;
    
} /* PILPrepQuantTable() */

// Calculate the mean square error difference between 2 images
float PILFindMSE(PIL_PAGE *pRefPage, PIL_PAGE *pTestPage)
{
    //	int x, y;
    //	unsigned char *pSrc, *pDest;
    //	unsigned long ulSum;
    
    if (pRefPage->iWidth != pTestPage->iWidth || pRefPage->iHeight != pTestPage->iHeight || pRefPage->cBitsperpixel != pTestPage->cBitsperpixel)
        return -1.0; // error
    return 0.0;
    
} /* PILFindMSE() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : JPEGDecodeMCUStats(BUFFERED_BITS *, JPEGDATA *, int *)     *
 *                                                                          *
 *  PURPOSE    : Decompress a macro block of JPEG data. Only the DC value   *
 *               is saved, and statistics are collected on the A/C coeffs.  *
 *                                                                          *
 ****************************************************************************/
int JPEGDecodeMCUStats(BUFFERED_BITS *bb, JPEGDATA *pJPEG, int *iDCPredictor, int *piHisto)
{
#ifdef _64BITS
    uint64_t ulCode, ulTemp;
#else
    uint32_t ulCode, ulTemp;
#endif
    unsigned char *pEnd,*pZig;
    signed char cCoeff;
    unsigned short *pFast;
    unsigned char ucHuff, ucIndex, *pucFast;
    uint32_t usHuff; // this prevents an unnecessary & 65535 for shorts
    BIGUINT ulBitOff, ulBits; // local copies to allow compiler to use register vars
    unsigned char *pBuf;
#define MIN_DCT_THRESHOLD 8
    
    ulBitOff = bb->ulBitOff;
    ulBits = bb->ulBits;
    pBuf = bb->pBuf;
    
    pZig = (unsigned char *)&cZigZag2[1];
    pEnd = (unsigned char *)&cZigZag2[64];
    
    if (ulBitOff > (REGISTER_WIDTH-17)) // need to get more data
    {
        pBuf += (ulBitOff >> 3);
        ulBitOff &= 7;
#ifdef _64BITS
        ulBits = MOTOEXTRALONG(pBuf);
#else
        ulBits = MOTOLONG(pBuf);
#endif
    }
    
    // get the DC component
    pucFast = (unsigned char *)pJPEG->pHuffDCFast;
    ulCode = (ulBits >> (REGISTER_WIDTH - 12 - ulBitOff)) & 0xfff; // get as lower 12 bits
    if (ulCode >= 0xf80) // it's a long code
        ulCode = (ulCode & 0xff); // point to long table and trim to 7-bits + 0x80 offset into long table
    else
        ulCode >>= 6; // it's a short code, use first 6 bits only
    ucHuff = pucFast[ulCode];
    cCoeff = (signed char)pucFast[ulCode+512];
    if (ucHuff == 0) // invalid code
        return PIL_ERROR_DECOMP;
    ulBitOff += (ucHuff >> 4); // add the Huffman length
    ucHuff &= 0xf; // get the actual code (SSSS)
    if (ucHuff) // if there is a change to the DC value
    { // get the 'extra' bits
        if (cCoeff)
        {
            (*iDCPredictor) += cCoeff;
        }
        else
        {
            if (ulBitOff > (REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            ulCode = ulBits << ulBitOff;
#ifdef _64BITS
            ulTemp = ~(uint64_t) (((int64_t) ulCode) >> 63); // slide sign bit across other 63 bits
#else
            ulTemp = ~(uint32_t)(((int32_t)ulCode)>>31); // slide sign bit across other 31 bits
#endif
            ulCode >>= (REGISTER_WIDTH - ucHuff);
            ulCode -= ulTemp>>(REGISTER_WIDTH-ucHuff);
            ulBitOff += ucHuff; // add bit length
            (*iDCPredictor) += (int)ulCode;
        }
    }
    if (*iDCPredictor < -100) // only count MCUs that aren't dark
    {
        piHisto = NULL;
    }
    // Now get the other 63 AC coefficients
    pFast = (unsigned short *)pJPEG->pHuffACFast;
    if (pJPEG->b11Bit) // 11-bit "slow" tables used
    {
// DEBUG
//        if (pJPEG->pHuffACFast == pJPEG->huffacFast[1]) // second table
//            pFast = (unsigned short *)&pJPEG->ucAltHuff[0];
        while (pZig < pEnd)
        {
            if (ulBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            ulCode = (ulBits >> (REGISTER_WIDTH - 16 - ulBitOff)) & 0xffff; // get as lower 16 bits
            if (ulCode >= 0xf000) // first 4 bits = 1, use long table
                ulCode = (ulCode & 0x1fff);
            else
                ulCode >>= 4; // use lower 12 bits (short table)
            usHuff = pFast[ulCode];
            if (usHuff == 0) // invalid code
                return PIL_ERROR_DECOMP;
            ulBitOff += (usHuff >> 8); // add length
            usHuff &= 0xff; // get code (RRRR/SSSS)
            if (usHuff == 0) // no more AC components
            {
                goto mcu_done;
            }
            if (ulBitOff > (REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            pZig += (usHuff >> 4);  // get the skip amount (RRRR)
            usHuff &= 0xf; // get (SSSS) - extra length
            if (pZig < pEnd && usHuff && piHisto)
            {
                ulCode = ulBits << ulBitOff;
                ulCode >>= (REGISTER_WIDTH - usHuff);
                ucIndex = *pZig;
                // If magnitude is big enough
                if (ulCode*pJPEG->sQuantTable[ucIndex] > MIN_DCT_THRESHOLD)
                {
                    piHisto[ucIndex]++; // count this as a useful AC coefficient
                }
            }
            ulBitOff += usHuff; // add (SSSS) extra length
            pZig++;
        } // while
    }
    else // 10-bit "fast" tables used
    {
        while (pZig < pEnd)
        {
            if (ulBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            ulCode = (ulBits >> (REGISTER_WIDTH - 16 - ulBitOff)) & 0xffff; // get as lower 16 bits
            if (ulCode >= 0xfc00) // first 6 bits = 1, use long table
                ulCode = (ulCode & 0x7ff); // (ulCode & 0x3ff) + 0x400;
            else
                ulCode >>= 6; // use lower 10 bits (short table)
            usHuff = pFast[ulCode];
            if (usHuff == 0) // invalid code
                return PIL_ERROR_DECOMP;
            ulBitOff += (usHuff >> 8); // add length
            usHuff &= 0xff; // get code (RRRR/SSSS)
            if (usHuff == 0) // no more AC components
            {
                goto mcu_done;
            }
            if (ulBitOff >(REGISTER_WIDTH - 17)) // need to get more data
            {
                pBuf += (ulBitOff >> 3);
                ulBitOff &= 7;
#ifdef _64BITS
                ulBits = MOTOEXTRALONG(pBuf);
#else
                ulBits = MOTOLONG(pBuf);
#endif
            }
            pZig += (usHuff >> 4);  // get the skip amount (RRRR)
            usHuff &= 0xf; // get (SSSS) - extra length
            if (pZig < pEnd && usHuff && piHisto)
            {
                ulCode = ulBits << ulBitOff;
                ulCode >>= (REGISTER_WIDTH - usHuff);
                ucIndex = *pZig;
                // If magnitude is big enough
                if (ulCode * pJPEG->sQuantTable[ucIndex] > MIN_DCT_THRESHOLD)
                {
                    piHisto[ucIndex]++; // count this as a useful AC coefficient
                }
            }
            ulBitOff += usHuff; // add (SSSS) extra length
            pZig++;
        } // while
    } // 10-bit tables
mcu_done:
    if (piHisto) // indicate this MCU is not too dark and has been counted
    {
        piHisto[0]++;
    }
    bb->pBuf = pBuf;
    bb->ulBitOff = ulBitOff;
    bb->ulBits = ulBits;
    return 0;
    
} /* JPEGDecodeMCUStats() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : PILGetQuality(PIL_PAGE *)                                  *
 *                                                                          *
 *  PURPOSE    : Given a compressed JPEG buffer, it determines the level    *
 *               of blur as quickly as possible from the MCU A/C coeffs.    *
 *  RETURNS    : blur factor: 0=perfectly sharp, 99=completely blurry       *
 *                                                                          *
 ****************************************************************************/
int PILGetQuality(PIL_PAGE *inpage)
{
    int cx, cy, x, y; //, lsize;
    signed int iDCPred0, iDCPred1, iDCPred2;
    int i, iErr;
    BUFFERED_BITS buffbits, *bb;
    JPEGDATA *pJPEG;
    //        signed short *pMCU;
    //    int *piMCUStats = NULL;
    unsigned char  cMarker, *buf;
    int iOff, iBit;
    int iBlur, iMCUCount; //, iLumaBlock, iLAvg, iLMax;
    unsigned char cDCTable0, cACTable0, cDCTable1, cACTable1, cDCTable2, cACTable2;
    int iHisto[64]; // count of DCT coefficients that meet the minimum required value
    // Histogram weighting grid
    int iTotalWeight = 344; // sum of all of the weights
    const int iWeightGrid[] = { 8,7,6,5,4,3,2,1,
        7,8,7,6,5,4,3,2,
        6,7,8,7,6,5,4,3,
        5,6,7,8,7,6,5,4,
        4,5,6,7,8,7,6,5,
        3,4,5,6,7,8,7,6,
        2,3,4,5,6,7,8,7,
        1,2,3,4,5,6,7,8};
    
    iErr = iBlur = 0;
    // Prepare to decode JPEG data
    pJPEG = PILPrepJPEGStruct(); /* jpeg tables */
    if (pJPEG == NULL)
    {
        iErr = PIL_ERROR_MEMORY;
        goto pilgetquality_z;
    }
    for (i=0; i<4; i++)
    {
        pJPEG->JPCI[i].h_samp_factor = 1;
        pJPEG->JPCI[i].v_samp_factor = 1;
    }
    memset(iHisto, 0, sizeof(iHisto));
    
    pJPEG->ulHeaderFlags = 0; // reset header status flags
    
    buf = inpage->pData; // point to raw JPEG data
    iOff = inpage->iOffset;
    iBit = 0;  /* Pointer into data stream */
    if (MOTOSHORT(buf) != 0xffd8) /* Do we start with an SOI marker? */
    {
        iErr = PIL_ERROR_UNSUPPORTED;
        goto pilgetquality_z;
    }
    JPEGGetSOI(pJPEG); /* Process Start Of Image info */
    cMarker = JPEGProcessTables(buf, &iOff, pJPEG, inpage->iDataSize + inpage->iOffset, inpage);
    if (cMarker != 0xda) // we should have processed all of the header up to the SOS
    {
        iErr = PIL_ERROR_BADHEADER;
        goto pilgetquality_z;
    }
    // we now have the image size as read from the Start Of Frame header
    inpage->iWidth = pJPEG->cx;
    inpage->iHeight = pJPEG->cy;
    if (pJPEG->iMode != 0xc0 && pJPEG->iMode != 0xc1 && pJPEG->iMode != 0xc2 && pJPEG->iMode != 0xc3) // we only handle baseline DCT jpeg, extended DCT, progressive DCT, and lossless Huffman
    {
        iErr = PIL_ERROR_UNSUPPORTED;
        goto pilgetquality_z;
    }
    pJPEG->iScan = 0; // get info ready for first scan (of multiscan progressive file)
    pJPEG->iHuffOffset[0] = 0; // use already-loaded Huff table for first scan
    pJPEG->iScanOffset[0] = 0; // first scan offset is always 0
    JPEGGetSOS(buf, &iOff, pJPEG);
    if (pJPEG->ucComponentsInScan < pJPEG->ucNumComponents) // the image has the scans encoded individually, treat it like a progressive JPEG
    {
        pJPEG->iOptions |= PIL_CONVERT_PROGRESSIVE;
        pJPEG->iMode = 0xc2;
    }
    if ((pJPEG->iMode == 0xc1 || pJPEG->iMode == 0xc3) && pJPEG->ucNumComponents != 1) // we only support grayscale for lossless and extended jpeg
    {
        iErr = PIL_ERROR_UNSUPPORTED;
        goto pilgetquality_z;
    }
    pJPEG->iScan++; // at least 1 scan
    // create huffman tables
    if (JPEGMakeHuffTables(pJPEG, FALSE)) // make Huffman tables for thumbnail decode since we don't need the MCU A/C coefficient values
    {
        iErr = PIL_ERROR_UNSUPPORTED;
        goto pilgetquality_z;
    }
    // reorder and fix the quantization table for decoding
    JPEGFixQuantD(pJPEG);
    JPEGInitTables(pJPEG);
//    if (pJPEG->iOptions & PIL_CONVERT_SIMD)
//        iOff = JPEGSimpleFilter_SIMD(inpage, iOff, pJPEG, NULL, 1, NULL, NULL, FALSE); // remove stuffed 0's and marker bytes to speed up decode
//    else
        iOff = JPEGSimpleFilter(inpage, iOff, pJPEG, NULL, 1, NULL, NULL, FALSE); // remove stuffed 0's and marker bytes to speed up decode
    iBit = 0;  // point to start of image data stream
    pJPEG->iDataSize = /*inpage->iOffset +*/ inpage->iDataSize;
    bb = &buffbits;
#ifdef _64BITS
    bb->ulBits = MOTOEXTRALONG(&inpage->pData[iOff]); // preload first 8 bytes
#else
    bb->ulBits = MOTOLONG(&inpage->pData[iOff]); // preload first 4 bytes
#endif
    //   iOff += (REGISTER_WIDTH>>3);
    bb->pBuf = &inpage->pData[iOff];
    bb->ulBitOff = iBit;
    bb->ulDataSize = inpage->iDataSize - iOff;
    //        pMCU = &pJPEG->pMCUs[0];
    iBit = 0;  // each scan starts at bit 0
    
    cDCTable0 = pJPEG->JPCI[0].dc_tbl_no;
    cACTable0 = pJPEG->JPCI[0].ac_tbl_no;
    cDCTable1 = pJPEG->JPCI[1].dc_tbl_no;
    cACTable1 = pJPEG->JPCI[1].ac_tbl_no;
    cDCTable2 = pJPEG->JPCI[2].dc_tbl_no;
    cACTable2 = pJPEG->JPCI[2].ac_tbl_no;
    
    //        lsize = PILCalcSize(inpage->iWidth, 8);
    iDCPred0 = iDCPred1 = iDCPred2 = 0;
    
    //        iLAvg = iLMax = 0; // reset values we care about
    iMCUCount = (inpage->iWidth + 15) >> 3;
    iMCUCount *= ((inpage->iHeight+15) >> 3); // number of luma blocks
    //    piMCUStats = (int *)PILIOAlloc(iMCUCount * sizeof(int));
    //        iLumaBlock = 0;
    switch (pJPEG->jpegsample) // set up the parameters for the different subsampling options
    {
        case 0x00: // hacked value to handle grayscale
        case 0x11:
            cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
            cy = (inpage->iHeight + 7)>>3;
            break;
        case 0x12:
            cx = (inpage->iWidth + 7)>>3;  // number of MCU blocks
            cy = (inpage->iHeight + 15)>>4;
            break;
        case 0x21:
            cx = (inpage->iWidth + 15)>>4;  // number of MCU blocks
            cy = (inpage->iHeight + 7)>>3;
            break;
        case 0x22:
            cx = (inpage->iWidth + 15)>>4;  // number of MCU blocks
            cy = (inpage->iHeight + 15)>>4;
            break;
        default: // to suppress compiler warning
            cx = cy = 0;
            break;
    }
    cy >>= 1; // only need to process the top half of the image to get the same info
    for (y=0; y<cy; y++)
    {
        //        printf("cx=%d, cy=%d, y=%d, iLumaBlock=%d, iMCUCount=%d\n",cx, cy, y, iLumaBlock, iMCUCount);
        for (x=0; x<cx; x++)
        {
            if (bb->pBuf > &inpage->pData[inpage->iDataSize+4])
                return PIL_ERROR_DECOMP; // problem
            pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable0];
            pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable0];
            // do the first luminance component
            iErr = JPEGDecodeMCUStats(bb, pJPEG, &iDCPred0, iHisto);
            //            piMCUStats[iLumaBlock++] = iDCPred0;
            // do the second luminance component
            if (pJPEG->jpegsample > 0x11) // subsampling
            {
                iErr |= JPEGDecodeMCUStats(bb,  pJPEG, &iDCPred0, iHisto);
                //                piMCUStats[iLumaBlock++] = iDCPred0;
                if (pJPEG->jpegsample == 0x22)
                {
                    iErr |= JPEGDecodeMCUStats(bb, pJPEG, &iDCPred0, iHisto);
                    //                    piMCUStats[iLumaBlock++] = iDCPred0;
                    iErr |= JPEGDecodeMCUStats(bb, pJPEG, &iDCPred0, iHisto);
                    //                    piMCUStats[iLumaBlock++] = iDCPred0;
                } // if 2:2 subsampling
            } // if subsampling used
            if (pJPEG->jpegsample) // if color
            {
                // first chroma
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable1];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable1];
                iErr |= JPEGDecodeMCUStats(bb, pJPEG, &iDCPred1, NULL);
                // second chroma
                pJPEG->pHuffACFast = pJPEG->huffacFast[cACTable2];
                pJPEG->pHuffDCFast = pJPEG->huffdcFast[cDCTable2];
                iErr |= JPEGDecodeMCUStats(bb, pJPEG, &iDCPred2, NULL);
                if (iErr)
                    return iErr; // decoding error, stop
            } // if color components present
            
            if (pJPEG->iResInterval)
            {
                if (--pJPEG->iResCount == 0)
                {
                    pJPEG->iResCount = pJPEG->iResInterval;
                    iDCPred0 = iDCPred1 = iDCPred2 = 0; // reset DC predictors
                    if (bb->ulBitOff & 7) // need to start at the next even byte
                    {
                        bb->ulBitOff += (8 - (bb->ulBitOff & 7));  // new restart interval starts on byte boundary
                    }
                }
            }
        }
    }
    
pilgetquality_z:
    if (iErr == 0)
    {
        int /*iTotalLuma,*/ iThreshold;
        iThreshold = iHisto[0]/100;
        //        qsort(piMCUStats, iLumaBlock, sizeof(int), int_cmp);
        iBlur = 0;
        for (x=1; x<64; x++)
        {
            if (iHisto[x] < iThreshold) // too few - count it as blurry
            {
                iBlur += iWeightGrid[x];
            }
        }
        iBlur = (iBlur*100)/iTotalWeight; // get as a percentage
        
        //            iTotalLuma = 0;
        //        for (x=0; x<iLumaBlock; x++)
        //        {
        //            iTotalLuma += piMCUStats[x];
        //        }
        //        iLAvg = iTotalLuma / iLumaBlock;
        //        printf("sorted Luma min=%d, median=%d, mean=%d, N-1=%d\n", piMCUStats[0], piMCUStats[iLumaBlock/2], iLAvg, piMCUStats[iLumaBlock-1]);
        //        printf("sorted AC coeff min=%d, median=%d, mean=%d, N-1=%d\n", pucDCTStats[0], pucDCTStats[iLumaBlock/2], iSAvg, pucDCTStats[iLumaBlock-1]);
        //        if (piBlur != NULL) *piBlur = iBlur;
        //        if (piLumaAvg != NULL) *piLumaAvg = iLAvg;
        //        if (piLumaMedian != NULL) *piLumaMedian = piMCUStats[iLumaBlock/2];
    }
    
    if (pJPEG != NULL) PILIOFree(pJPEG);
    //    if (piMCUStats != NULL) PILIOFree(piMCUStats);
    
    if (iErr == 0)
    {
        iErr = iBlur;
    }
    return iErr;
} /* PILGetQuality() */
